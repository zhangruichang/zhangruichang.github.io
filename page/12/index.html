<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 12 页 | Richard</title>
  <meta name="author" content="Richard">
  
  <meta name="description" content="理查德爱闹">
  
  
  
  <meta property="og:site_name" content="Richard"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta property="og:image" content="undefined"/>
  
   <link rel="apple-touch-icon" href="/icon.png" />
   <link rel="shortcut icon" href="/favicon.png" >
   <link rel="alternate" href="http://xxx.xx/atom.xml" title="Richard" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
</head>


<body>
  <div id="content" class="inner">
    <aside id="sidebar" class="alignleft">
      <div class="navigationBar">
        <a href="/">Richard</a>
      </div>
    	
  <nav class="widget" id="menu">
	<ul>
    
      <li class="cell"><a class="next" href="/">Home</a><li>
    
      <li class="cell"><a class="next" href="/archives/">Archives</a><li>
    
      <li class="cell"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a><li>
    
      <li class="cell"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a><li>
    
      <li class="cell"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a><li>
    
    </ul>
</nav>

  <div class="widget weibo">
  <iframe width="100%" height="750" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=750&fansRow=2&ptype=1&speed=0&skin=6&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2689136623&verifier=c139aa37&dpc=1"></iframe>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/AVL/">AVL</a><small>1</small></li>
  
    <li><a href="/categories/BT/">BT</a><small>1</small></li>
  
    <li><a href="/categories/Binary-Tree/">Binary Tree</a><small>1</small></li>
  
    <li><a href="/categories/BinaryTree/">BinaryTree</a><small>1</small></li>
  
    <li><a href="/categories/C/">C</a><small>3</small></li>
  
    <li><a href="/categories/C++/">C++</a><small>1</small></li>
  
    <li><a href="/categories/DFA/">DFA</a><small>1</small></li>
  
    <li><a href="/categories/DFS/">DFS</a><small>1</small></li>
  
    <li><a href="/categories/DP/">DP</a><small>3</small></li>
  
    <li><a href="/categories/GCD/">GCD</a><small>1</small></li>
  
    <li><a href="/categories/Linklist/">Linklist</a><small>1</small></li>
  
    <li><a href="/categories/Machine-Learning/">Machine Learning</a><small>1</small></li>
  
    <li><a href="/categories/Recursive/">Recursive</a><small>1</small></li>
  
    <li><a href="/categories/STL/">STL</a><small>1</small></li>
  
    <li><a href="/categories/Trie/">Trie</a><small>1</small></li>
  
    <li><a href="/categories/Union-find-set/">Union-find set</a><small>1</small></li>
  
    <li><a href="/categories/add-num/">add num</a><small>1</small></li>
  
    <li><a href="/categories/algorithm/">algorithm</a><small>15</small></li>
  
    <li><a href="/categories/app/">app</a><small>1</small></li>
  
    <li><a href="/categories/backtrack/">backtrack</a><small>2</small></li>
  
    <li><a href="/categories/bfs/">bfs</a><small>1</small></li>
  
    <li><a href="/categories/bfs,-dfs/">bfs, dfs</a><small>1</small></li>
  
    <li><a href="/categories/binary-search/">binary search</a><small>2</small></li>
  
    <li><a href="/categories/binary-tree/">binary tree</a><small>5</small></li>
  
    <li><a href="/categories/bit/">bit</a><small>1</small></li>
  
    <li><a href="/categories/bit-operation/">bit operation</a><small>2</small></li>
  
    <li><a href="/categories/blog/">blog</a><small>1</small></li>
  
    <li><a href="/categories/c-language/">c language</a><small>2</small></li>
  
    <li><a href="/categories/catalan/">catalan</a><small>1</small></li>
  
    <li><a href="/categories/coding/">coding</a><small>2</small></li>
  
    <li><a href="/categories/complex-condition-anaysis/">complex condition anaysis</a><small>1</small></li>
  
    <li><a href="/categories/cpp/">cpp</a><small>14</small></li>
  
    <li><a href="/categories/cpp-string/">cpp string</a><small>1</small></li>
  
    <li><a href="/categories/data-structure/">data structure</a><small>4</small></li>
  
    <li><a href="/categories/dfs/">dfs</a><small>1</small></li>
  
    <li><a href="/categories/dfs,-non-recursive/">dfs, non-recursive</a><small>1</small></li>
  
    <li><a href="/categories/digit/">digit</a><small>1</small></li>
  
    <li><a href="/categories/dp/">dp</a><small>8</small></li>
  
    <li><a href="/categories/ds/">ds</a><small>2</small></li>
  
    <li><a href="/categories/easy-programming/">easy programming</a><small>1</small></li>
  
    <li><a href="/categories/experience/">experience</a><small>1</small></li>
  
    <li><a href="/categories/gechao-principle/">gechao principle</a><small>1</small></li>
  
    <li><a href="/categories/git/">git</a><small>1</small></li>
  
    <li><a href="/categories/greedy-problem/">greedy problem</a><small>1</small></li>
  
    <li><a href="/categories/hash/">hash</a><small>1</small></li>
  
    <li><a href="/categories/heap/">heap</a><small>2</small></li>
  
    <li><a href="/categories/hexo-configuration/">hexo configuration</a><small>1</small></li>
  
    <li><a href="/categories/hihocode/">hihocode</a><small>1</small></li>
  
    <li><a href="/categories/install-os/">install os</a><small>1</small></li>
  
    <li><a href="/categories/integer/">integer</a><small>1</small></li>
  
    <li><a href="/categories/kmp/">kmp</a><small>1</small></li>
  
    <li><a href="/categories/latex/">latex</a><small>1</small></li>
  
    <li><a href="/categories/linklist/">linklist</a><small>9</small></li>
  
    <li><a href="/categories/linux/">linux</a><small>1</small></li>
  
    <li><a href="/categories/loading-force/">loading force</a><small>1</small></li>
  
    <li><a href="/categories/logic/">logic</a><small>1</small></li>
  
    <li><a href="/categories/math/">math</a><small>3</small></li>
  
    <li><a href="/categories/math-rule/">math rule</a><small>1</small></li>
  
    <li><a href="/categories/matlab-programming/">matlab programming</a><small>1</small></li>
  
    <li><a href="/categories/mod/">mod</a><small>1</small></li>
  
    <li><a href="/categories/novel/">novel</a><small>1</small></li>
  
    <li><a href="/categories/number-theory/">number theory</a><small>1</small></li>
  
    <li><a href="/categories/permutation/">permutation</a><small>2</small></li>
  
    <li><a href="/categories/probability/">probability</a><small>1</small></li>
  
    <li><a href="/categories/programming/">programming</a><small>1</small></li>
  
    <li><a href="/categories/quick-and-right-coding/">quick and right coding</a><small>1</small></li>
  
    <li><a href="/categories/scanf/">scanf</a><small>1</small></li>
  
    <li><a href="/categories/screen/">screen</a><small>1</small></li>
  
    <li><a href="/categories/screen-alg/">screen alg</a><small>1</small></li>
  
    <li><a href="/categories/sequence/">sequence</a><small>1</small></li>
  
    <li><a href="/categories/sorting/">sorting</a><small>1</small></li>
  
    <li><a href="/categories/string/">string</a><small>1</small></li>
  
    <li><a href="/categories/swap/">swap</a><small>1</small></li>
  
    <li><a href="/categories/time-complexity/">time complexity</a><small>1</small></li>
  
    <li><a href="/categories/vote/">vote</a><small>1</small></li>
  
    <li><a href="/categories/web/">web</a><small>2</small></li>
  
    <li><a href="/categories/数字规律/">数字规律</a><small>1</small></li>
  
    <li><a href="/categories/树形DP/">树形DP</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/BST/" style="font-size: 12.50px;">BST</a><a href="/tags/BT/" style="font-size: 15.00px;">BT</a><a href="/tags/Backtrack/" style="font-size: 10.00px;">Backtrack</a><a href="/tags/Bayesian-graph-model/" style="font-size: 10.00px;">Bayesian graph model</a><a href="/tags/C/" style="font-size: 17.50px;">C</a><a href="/tags/C++/" style="font-size: 10.00px;">C++</a><a href="/tags/Combinations/" style="font-size: 10.00px;">Combinations</a><a href="/tags/DFA/" style="font-size: 10.00px;">DFA</a><a href="/tags/DP/" style="font-size: 17.50px;">DP</a><a href="/tags/GCD/" style="font-size: 10.00px;">GCD</a><a href="/tags/OO/" style="font-size: 10.00px;">OO</a><a href="/tags/Order/" style="font-size: 10.00px;">Order</a><a href="/tags/Permutation/" style="font-size: 10.00px;">Permutation</a><a href="/tags/PostOrder/" style="font-size: 10.00px;">PostOrder</a><a href="/tags/STL/" style="font-size: 10.00px;">STL</a><a href="/tags/Trie/" style="font-size: 10.00px;">Trie</a><a href="/tags/Union-find-set/" style="font-size: 10.00px;">Union-find set</a><a href="/tags/add-num/" style="font-size: 10.00px;">add num</a><a href="/tags/algorithm/" style="font-size: 20.00px;">algorithm</a><a href="/tags/app/" style="font-size: 10.00px;">app</a><a href="/tags/array/" style="font-size: 17.50px;">array</a><a href="/tags/back-n-node/" style="font-size: 10.00px;">back n node</a><a href="/tags/backtrack/" style="font-size: 10.00px;">backtrack</a><a href="/tags/bfs/" style="font-size: 12.50px;">bfs</a><a href="/tags/binary-search/" style="font-size: 15.00px;">binary search</a><a href="/tags/binary-search-tree/" style="font-size: 10.00px;">binary search tree</a><a href="/tags/bit/" style="font-size: 15.00px;">bit</a><a href="/tags/brute-force/" style="font-size: 12.50px;">brute force</a><a href="/tags/c/" style="font-size: 10.00px;">c</a><a href="/tags/c-language/" style="font-size: 12.50px;">c language</a><a href="/tags/catalan/" style="font-size: 10.00px;">catalan</a><a href="/tags/category-analysis/" style="font-size: 10.00px;">category analysis</a><a href="/tags/char/" style="font-size: 10.00px;">char*</a><a href="/tags/cin/" style="font-size: 10.00px;">cin</a><a href="/tags/coding/" style="font-size: 15.00px;">coding</a><a href="/tags/combination/" style="font-size: 10.00px;">combination</a><a href="/tags/complement/" style="font-size: 10.00px;">complement</a><a href="/tags/complex/" style="font-size: 12.50px;">complex</a><a href="/tags/complex-condition-analysis/" style="font-size: 12.50px;">complex condition analysis</a><a href="/tags/condition-analysis/" style="font-size: 10.00px;">condition analysis</a>
  </div>
</div>


    	<footer id="footer" class="inner"><div class="copyright">
  
  &copy; 2015 Richard
  
</div>



</footer>
    </aside>
    
    
    <div id="hidden-navigationBar" class="navigationBar">
      <a href="/">Richard</a>
    </div>
    <div id="main-col" class="alignright">
    <div id="wrapper">
      
  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/23/BFS-Knight/">BFS-Knight</a></h1>
  

      <time datetime="2014-07-23T06:49:20.000Z"><a href="/2014/07/23/BFS-Knight/">7月 23 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>看到群里童鞋说这个scanf会挂，于是我试了下，poj已提交网页就挂了，不知道为啥。</p>
<p>朴素的bfs，之前dfs练得多一些，图的dfs相比树的因为更复杂，需要visit来避免重复访问。poj2243, 这道就是基本的bfs了，好像也没有剪枝的策略。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;math.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;time.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;limits.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;iomanip&gt;</span>
<span class="comment">//#include &lt;unordered_set&gt;</span>
<span class="preprocessor">#<span class="keyword">define</span> Min(a,b) (((a) &lt; (b)) ? (a) : (b))</span>
<span class="preprocessor">#<span class="keyword">define</span> Max(a,b) (((a) &gt; (b)) ? (a) : (b))</span>
<span class="preprocessor">#<span class="keyword">define</span> read freopen("in.txt","r",stdin)</span>
<span class="preprocessor">#<span class="keyword">define</span> write freopen("out.txt","w",stdout)</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">struct</span> node
{
    <span class="keyword">int</span> row;
    <span class="keyword">int</span> col;
    <span class="keyword">int</span> path;

};

<span class="keyword">int</span> main()
{
    <span class="comment">//read;</span>
    <span class="comment">//write;</span>
    <span class="keyword">char</span> s[<span class="number">3</span>],e[<span class="number">3</span>];
    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s,e))
    {
        <span class="comment">//cin&gt;&gt;e;</span>

        node start,end;
        start.col=s[<span class="number">0</span>]-<span class="string">'a'</span>;
        start.row=s[<span class="number">1</span>]-<span class="string">'1'</span>;
        start.path=<span class="number">0</span>;
        end.col=e[<span class="number">0</span>]-<span class="string">'a'</span>;
        end.row=e[<span class="number">1</span>]-<span class="string">'1'</span>;

        <span class="stl_container"><span class="built_in">queue</span>&lt;node&gt;</span> q;

        q.push(start);
        node p;
        <span class="keyword">while</span>(!q.empty())
        {
            p=q.front();
            q.pop();
            <span class="keyword">if</span>(p.row==end.row &amp;&amp; p.col== end.col)
            {
                <span class="keyword">break</span>;
            }

            <span class="keyword">if</span>(p.row-<span class="number">2</span> &gt;=<span class="number">0</span> &amp;&amp; p.col+<span class="number">1</span>&lt;=<span class="number">7</span>)
            {
                node nd;
                nd.row=p.row-<span class="number">2</span>;nd.col=p.col+<span class="number">1</span>;
                nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }

            <span class="keyword">if</span>(p.row-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; p.col+<span class="number">2</span>&lt;=<span class="number">7</span>)
            {
                node nd;
                nd.row=p.row-<span class="number">1</span>;nd.col=p.col+<span class="number">2</span>;
                nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
            <span class="keyword">if</span>(p.row+<span class="number">1</span> &lt;=<span class="number">7</span> &amp;&amp; p.col+<span class="number">2</span>&lt;=<span class="number">7</span>)
            {
                node nd;
                nd.row=p.row+<span class="number">1</span>;nd.col=p.col+<span class="number">2</span>;
                nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
            <span class="keyword">if</span>(p.row+<span class="number">2</span> &lt;=<span class="number">7</span> &amp;&amp; p.col+<span class="number">1</span>&lt;=<span class="number">7</span>)
            {
                node nd;
                nd.row=p.row+<span class="number">2</span>;nd.col=p.col+<span class="number">1</span>;
                nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
            <span class="keyword">if</span>(p.row+<span class="number">2</span> &lt;=<span class="number">7</span> &amp;&amp; p.col-<span class="number">1</span>&gt;=<span class="number">0</span>)
            {
                node nd;
                nd.row=p.row+<span class="number">2</span>;nd.col=p.col-<span class="number">1</span>;
                nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
            <span class="keyword">if</span>(p.row+<span class="number">1</span> &lt;=<span class="number">7</span> &amp;&amp; p.col-<span class="number">2</span>&gt;=<span class="number">0</span>)
            {
                node nd;
                nd.row=p.row+<span class="number">1</span>;nd.col=p.col-<span class="number">2</span>;nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
            <span class="keyword">if</span>(p.row-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; p.col-<span class="number">2</span>&gt;=<span class="number">0</span>)
            {
                node nd;
                nd.row=p.row-<span class="number">1</span>;nd.col=p.col-<span class="number">2</span>;nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
            <span class="keyword">if</span>(p.row-<span class="number">2</span> &gt;=<span class="number">0</span> &amp;&amp; p.col-<span class="number">1</span>&gt;=<span class="number">0</span>)
            {
                node nd;
                nd.row=p.row-<span class="number">2</span>;nd.col=p.col-<span class="number">1</span>;nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
        }

        <span class="built_in">cout</span>&lt;&lt;<span class="string">"To get from "</span>&lt;&lt;s&lt;&lt;<span class="string">" to "</span>&lt;&lt;e&lt;&lt;<span class="string">" takes "</span>&lt;&lt;p.path&lt;&lt;<span class="string">" knight moves."</span>&lt;&lt;endl;
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 23 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/23/Recode-SubsetsSnum/">Recode SubsetsSnum</a></h1>
  

      <time datetime="2014-07-23T06:32:19.000Z"><a href="/2014/07/23/Recode-SubsetsSnum/">7月 23 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>看到邹博写的permutation，发现参数比较有意思，是from to这种，后来想想，确实这种比较make sense，之前写的的什么selectk，k，selectn,n都非常容易在边界之类的出错，递归出口处的逻辑等等，这种非常清晰，于是<br>学习邹博的coding风格重写了subsetsnum 问题。</p>
<p>先写了一个朴素的，遍历完2^n搜索空间的朴素，from是起点，to是终点，所以这么调用Sum(a, 0,n-1,sumx);表示从a[from…to]里面找到子集和为sumx的集合，<br>后来发现，这样每次都去想到底是n还是n-1，出口是k&gt;n还是k==n呢，每次都先写一个，然后拿个例子去测，还是邹博这种写法比较规范。</p>
<pre><code><span class="keyword">void</span> Sum(<span class="keyword">int</span> *a, <span class="keyword">int</span> <span class="keyword">from</span>, <span class="keyword">int</span> to, <span class="keyword">int</span> sumx)
{
    <span class="keyword">if</span>(<span class="keyword">from</span>&gt;to)
    {
        <span class="keyword">int</span> sum=<span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=to;i++)
            sum+=a[i]*<span class="keyword">select</span>[i];
        <span class="keyword">if</span>(sum==sumx)
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=to;i++)
                <span class="keyword">if</span>(<span class="keyword">select</span>[i])
                    cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;
            cout&lt;&lt;endl;
        }
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">select</span>[<span class="keyword">from</span>]=<span class="keyword">false</span>;
        Sum(a,<span class="keyword">from</span>+<span class="number">1</span>,to, sumx);
        <span class="keyword">select</span>[<span class="keyword">from</span>]=<span class="keyword">true</span>;
        Sum(a,<span class="keyword">from</span>+<span class="number">1</span>,to,sumx);
    }
}
</code></pre><p>一直都考虑到这种很多无用的搜索，例如之前和已经超了，还要去遍历，显然浪费了时间，于是将和&lt;0的剪枝，但是之前写总会出问题，改成这种写法决定试试：</p>
<pre><code>void Cut_Sum(int <span class="keyword">from</span>, int <span class="keyword">to</span>, int sumx)
{


    <span class="keyword">if</span>(sumx&lt;<span class="number">0</span>) <span class="constant">return</span>;
    <span class="keyword">else</span> <span class="keyword">if</span>(sumx==<span class="number">0</span>)
    {
        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&gt;=<span class="keyword">to</span>;i<span class="comment">--)</span>
        {
            <span class="keyword">if</span>(selectn[i])
                cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;
        }
        cout&lt;&lt;endl;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">from</span>&gt;<span class="keyword">to</span>)
<span class="command">        return</span>;
    <span class="keyword">else</span>
    {
        selectn[<span class="keyword">from</span>]=<span class="constant">false</span>;
        Cut_Sum(<span class="keyword">from</span>+<span class="number">1</span>,<span class="keyword">to</span>,sumx);
        selectn[<span class="keyword">from</span>]=<span class="constant">true</span>;
        Cut_Sum(<span class="keyword">from</span>+<span class="number">1</span>,<span class="keyword">to</span>,sumx-a[<span class="keyword">from</span>]);
    }
}
</code></pre><p>后来和上面朴素的结果比一比发现又错了，递归程序改改又挂了o(╯□╰)o</p>
<p>1,2,3,4,5，6 sum=6<br>又来了阴影，打算重新模拟一遍，发现了问题，其实不是完全乱了，而是在回溯到2 4的时候，我把5 6也打印出来了，发现这时候5 6 的select都为true，难怪print出来，怎么会出这个问题，为啥原来的没有？<br>后来分析一遍，发现区别了，原来每次找到解都要遍历完6个数，因此后面的自然变为false了，而我现在剪枝的话，前面一开始从false到true后是没有复原到false的，然后又从0-&gt;to print出来当然误以为5 6都选上了，所以解决方案<br>是只把0-&gt;from-1的根据select print出来，注意是from-1，因为sum=0 是处理0-&gt;from之后得出的和，from+1还没看，所以把上面sumx=0的for改为</p>
<pre><code><span class="keyword">for</span>(int <span class="built_in">i</span>=from-<span class="number">1</span>;<span class="built_in">i</span>&gt;=<span class="number">0</span>;<span class="built_in">i</span>--)
</code></pre><p>改成后面到前面是因为一道题目要求从大到小排序，我已开始把数组升序排了。<br>因此这是递归版剪枝的子集和问题代码，但是OJ由于时间掐的严，还是TLE了，因为递归还是很多重复调用，要改成非递归的，不过我都忘记了。。。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 23 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/22/quick-and-right-coding/">quick and right coding</a></h1>
  

      <time datetime="2014-07-22T12:25:40.000Z"><a href="/2014/07/22/quick-and-right-coding/">7月 22 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>昨天看了下邹博的PPT，邹博是负责July团队负责字符串一块的，包括Manachester算法，KMP，BP，字符串排列(其实是回溯法了)等等，<br>有一个不太重要的地方，就是邹博的代码比较短，而且看起来逻辑比较漂漂，而我的经常逻辑复杂，还写半天，还经常出bug，于是写点总结。</p>
<p>先拿最长回文子串朴素O(n^2)代码这个case来看，遍历回文串中心，我代码可能有问题，以为不需要首尾两个字符了，因为肯定是1了，但是忘记考虑偶数长回文子串了，如果后面Index=1(0-base)的没有考虑01为中心的偶长传可能就会有问题了，<br>末尾也是一样的。自己漏考虑。</p>
<pre><code><span class="keyword">int</span> maxdrome_centre(<span class="keyword">string</span> str)
{
    <span class="keyword">if</span>(str.<span class="keyword">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> maxlen=<span class="number">1</span>,<span class="keyword">max</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;str.<span class="keyword">size</span>()-<span class="number">1</span>;i++)
    {
        <span class="keyword">max</span>=<span class="number">1</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(str.<span class="keyword">size</span>()-<span class="number">1</span>)/<span class="number">2</span>;j++)<span class="comment">//two</span>
        {
            <span class="keyword">if</span>(i-j&gt;=<span class="number">0</span> &amp;&amp; i+j &lt;=str.<span class="keyword">size</span>()-<span class="number">1</span>)
            {
                <span class="keyword">if</span>(str[i-j] == str[i+j])
                    <span class="keyword">max</span>+=<span class="number">2</span>;
                <span class="keyword">else</span>
                    <span class="keyword">break</span>;
            }
            <span class="keyword">else</span>
                <span class="keyword">break</span>;
        }
        <span class="keyword">if</span>(<span class="keyword">max</span>&gt;maxlen)
            maxlen=<span class="keyword">max</span>;
        <span class="keyword">max</span>=<span class="number">1</span>;
        <span class="keyword">if</span>(str[i]==str[i+<span class="number">1</span>])
        {
            <span class="keyword">max</span>++;
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(str.<span class="keyword">size</span>()-<span class="number">2</span>)/<span class="number">2</span>;j++)
            {
                <span class="keyword">if</span>(i-j&gt;=<span class="number">0</span> &amp;&amp; i+<span class="number">1</span>+j&lt;=str.<span class="keyword">size</span>()-<span class="number">1</span> )
                {
                    <span class="keyword">if</span>(str[i-j]==str[i+<span class="number">1</span>+j])
                        <span class="keyword">max</span>+=<span class="number">2</span>;
                    <span class="keyword">else</span>
                        <span class="keyword">break</span>;
                }
                <span class="keyword">else</span>
                    <span class="keyword">break</span>;
            }
            <span class="keyword">if</span>(<span class="keyword">max</span>&gt;maxlen)
                maxlen=<span class="keyword">max</span>;
        }


    }
    <span class="keyword">return</span> maxlen;
}
</code></pre><p>看看这个代码里面，还嵌套了break，for条件判断之后，里面又判断了越界问题，其实是有重复的，for里面的条件其实没有必要，完全可以用if里面的替换掉，因为只要头尾都每越界，就可以一直两边extend，于是如果越界了，还break，如果写到for<br>条件里，刚好不用break了，里面如果长度相等就extend，没有的话break，这个是比较合理的，也需要的。而且这个max没必要每次加2，因为完全可以根据j计算出来。</p>
<p>因此代码修改后变成如下的：</p>
<pre><code><span class="keyword">int</span> maxdrome_centre(<span class="keyword">string</span> str)
{
    <span class="keyword">if</span>(str.<span class="keyword">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> maxlen=<span class="number">1</span>;<span class="comment">//total max, at least 1</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=str.<span class="keyword">size</span>()-<span class="number">1</span>;i++)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i-j&gt;=<span class="number">0</span> &amp;&amp; i+j &lt;=str.<span class="keyword">size</span>()-<span class="number">1</span>;j++)<span class="comment">//odd</span>
        {
            <span class="keyword">if</span>(str[i-j] != str[i+j])
                <span class="keyword">break</span>;
        }
        <span class="keyword">max</span>=<span class="number">2</span><span class="variable">*j</span>+<span class="number">1</span>;
        <span class="keyword">if</span>(<span class="keyword">max</span>&gt;maxlen)
            maxlen=<span class="keyword">max</span>;

        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;(i-j&gt;=<span class="number">0</span>) &amp;&amp; (i+j+<span class="number">1</span>) &lt;=str.<span class="keyword">size</span>()-<span class="number">1</span>;j++)<span class="comment">//odd</span>
        {
            <span class="keyword">if</span>(str[i-j] != str[i+j+<span class="number">1</span>])
                <span class="keyword">break</span>;
        }
        <span class="keyword">max</span>=<span class="number">2</span><span class="variable">*j</span>++<span class="number">2</span>;
        <span class="keyword">if</span>(<span class="keyword">max</span>&gt;maxlen)
            maxlen=<span class="keyword">max</span>;
    }
    <span class="keyword">return</span> maxlen;
}
</code></pre><p>这个逻辑几乎和邹博一样了，所以总结一下自己coding的一些不好的思维和设计逻辑的习惯<br>1.不要去根据不等式去计算i或者j的范围，这是计算机做的事情，例如i-j&gt;=0 i+j&lt;=str.size()-1 这个我有时候可能回想着推出i j范围，然后写在条件语句，这个其实直接写会比较好，计算机会处理好的<br>2.写逻辑语句要想清楚是否两个条件有重叠有包含关系，只要选那个更严格的条件就可以了，否则逻辑更复杂，例如我for里面先去限制j最大只能extend (n-1)/2长度，再在里面加if限制两边越界，其实越界包含了前者，<br>只需要这个条件，因此直接放到for条件里，这样少了break，还有计算长度直接有j决定，所以不需要里面每次max+2，当然这个问题会轻一点，但是没想到不应该。<br>3.另外后面偶数长度还先加if判断是否第一个成立，完全可以放到循环里面，不然逻辑复杂，易出bug，还有一个内部的max没必要，因为每次都是计算当期的与总的比较，不是两次max比较，也没想清楚。</p>
<p>总之代码写的还是naive，还是要多读别人的代码，例如fawkes，adhoc，邹博等，现在要求代码要写的快，逻辑简单清晰，精炼，越垄长的容易bug</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 22 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/22/Dijstra-proof/">Dijstra proof</a></h1>
  

      <time datetime="2014-07-22T06:44:23.000Z"><a href="/2014/07/22/Dijstra-proof/">7月 22 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>看到09CS 考研DS第一道大题，是对Dijstra的变形，问是否正确，于是回顾这一经典的greedy算法。</p>
<p>算法思想和代码之前已经联系过了，但是这道题目涉及到了正确性证明，如果变形了是否保证正确性，尽管答案只是举了一个反例来说明，但是我还是打算回顾下<br>当时的proof。其实一直都不算真正意义的理解了。</p>
<p>利用数学归纳的思想：</p>
<p>集合分为close-set表示，已经算出最短路径的点击，open-set为剩余的点击。</p>
<p>1(初始条件). 一开始肯定是source点u了，因为dist为0，不可能有比他更短的了。假设第二个点p，现在证明p一定是u-&gt;p为p的最短路径。<br>假设不是，假设存在open-set点x，使得u-&gt;x x-&gt;p为最短路径，那么u-&gt;x一定比u-&gt;p短(边&gt;0的性质)，x应该比p先加入close-set，与一直矛盾</p>
<p>2(递推证明).加入当前close-set有些点，那么现在加入p，那么u-&gt;p的最短路径的点一定都在close-set里。<br>假设不是，假设路径出现了一个点x在opens-set(假设只是路径最后一个点在open-set,其他情况是转化为这个的吧),那么u-&gt;x x-&gt;p比u-&gt;p(中间全是close-set中点)要短，那么u-&gt;x比u-&gt;p短，x应该比p先加入close-set，<br>产生矛盾。</p>
<p>思路来源这里<br><a href="http://blog.csdn.net/dog250/article/details/5303310" target="_blank" rel="external">http://blog.csdn.net/dog250/article/details/5303310</a> </p>
<p>另外还附上一个童鞋另一种思维方式的理解正确性 <a href="http://my.oschina.net/mustang/blog/56216" target="_blank" rel="external">http://my.oschina.net/mustang/blog/56216</a></p>
<p>当年算法书的证明感觉不make sense，所以弃掉了。</p>
<p>另外今天看到了一个priority_queue 也是在<queue>里面的，都是单向队列，只是加了优先级排序。</queue></p>
<p><dequeu> 则是双向队列，两边都可以插和删，</dequeu></p>
<p>STL与堆相关的主要是 make_heap push_heap, pop_heap 这样一些algorithm里的函数，用vector容器来装，可以实现heap</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 22 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/22/CockTailSort/">CockTailSort</a></h1>
  

      <time datetime="2014-07-21T16:11:47.000Z"><a href="/2014/07/22/CockTailSort/">7月 22 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>今天看到鸡尾酒排序，看名字就像了解下，之前好像有稍微听过，但是具体不知道是啥。</p>
<p>是冒泡排序的改进版，原来每次冒最大(小)到最后面，现在两端来回冒，这样有啥好处呢？<br>例如 23451这样的 只要一来一回就排好了，但是bubblesort却要很多次。</p>
<p>所以写算法，感觉是n/2个来回，n为偶正好冒完所有，n为奇，除掉中间的元素，最后肯定也是定好位置的，因为其他n-1个元素都订好位置了。<br>另外和bubblesort一样，加swap flag，如果一来或者一回没有交换，那么就排好序了，调用C++11的swap函数。</p>
<p>后来看了下wikipedia的，感觉实现不太一样，他是直接用swap就来判断外部循环，思路也是一致，每个来回长度都要缩减2，</p>
<pre><code><span class="keyword">void</span> CockTailSort(<span class="keyword">int</span>*a, <span class="keyword">int</span> n)
{
    <span class="keyword">bool</span> isswap;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)
    {
        isswap=<span class="keyword">false</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&lt;=n-i-<span class="number">1</span>;j++)
        {
            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])
                swap(a[j],a[j+<span class="number">1</span>]),isswap=<span class="keyword">true</span>;

        }
        <span class="keyword">if</span>(isswap==<span class="keyword">false</span>) <span class="keyword">break</span>;
        isswap=<span class="keyword">false</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> j=n-i-<span class="number">1</span>;j&gt;=i;j--)
        {
            <span class="keyword">if</span>(a[j-<span class="number">1</span>]&gt;a[j])
                swap(a[j],a[j-<span class="number">1</span>]),isswap=<span class="keyword">true</span>;
        }
        <span class="keyword">if</span>(isswap==<span class="keyword">false</span>) <span class="keyword">break</span>;
    }
}
</code></pre>
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 22 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/21/trim-variant-c-cpp-string/">trim variant c cpp string</a></h1>
  

      <time datetime="2014-07-21T12:33:56.000Z"><a href="/2014/07/21/trim-variant-c-cpp-string/">7月 21 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>实现trim的variant，将多个空格变为1个。但是逻辑似乎对我来说短时间不简单啊。</p>
<p>我开始尝试的是C++字符串，一个istringstream搞定，但是其实也会有问题，后来发现要试试C的，不然有点像调用了一个库或者class的感觉。</p>
<pre><code><span class="keyword">char</span> * trim(<span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">int</span> i=<span class="number">0</span>;
    <span class="keyword">int</span> len=strlen(<span class="keyword">str</span>),startpos;
    <span class="keyword">char</span>* a=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];

    <span class="keyword">int</span> offset=<span class="number">0</span>;
    <span class="keyword">while</span>(i&lt;len)
    {
        startpos=i;
        <span class="keyword">while</span>(i&lt;len&amp;&amp;<span class="keyword">str</span>[i]!=<span class="string">' '</span>)
            i++;
        <span class="keyword">if</span>(i==len) <span class="keyword">break</span>;
        <span class="keyword">for</span>(j=startpos;j&lt;i;j++)
        {
            a[offset]=<span class="keyword">str</span>[j];
            offset++;
        }
        a[offset]=<span class="string">' '</span>;
        offset++;

        <span class="keyword">while</span>(i&lt;len&amp;&amp;<span class="keyword">str</span>[i]==<span class="string">' '</span>)
            i++;
    }
    a[offset]=<span class="string">'\0'</span>;
    strcpy(<span class="keyword">str</span>,a);
    delete[] a;
    <span class="keyword">return</span> <span class="keyword">str</span>;
}
</code></pre><p>上面代码有点问题的，break早了，最后一个非空格的串还没copy过去，另外改成strncpy，提高可读性</p>
<pre><code><span class="keyword">char</span> * trim_new(<span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">int</span> i=<span class="number">0</span>,j;
    <span class="keyword">int</span> len=strlen(<span class="keyword">str</span>),startpos;
    <span class="keyword">char</span>* a=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];

    <span class="keyword">int</span> offset=<span class="number">0</span>;
    <span class="keyword">while</span>(i&lt;len)
    {
        startpos=i;
        <span class="keyword">while</span>(i&lt;len&amp;&amp;<span class="keyword">str</span>[i]!=<span class="string">' '</span>)
            i++;
        strncpy(a+offset,<span class="keyword">str</span>+startpos,i-startpos);
        <span class="comment">/*
        for(j=startpos;j&lt;i;j++)
        {
            a[offset]=str[j];
            offset++;
        }
        */</span>
        offset+=i-startpos;
        <span class="keyword">if</span>(i==len) <span class="keyword">break</span>;
        a[offset]=<span class="string">' '</span>;
        offset++;

        <span class="keyword">while</span>(i&lt;len&amp;&amp;<span class="keyword">str</span>[i]==<span class="string">' '</span>)
            i++;
    }
    a[offset]=<span class="string">'\0'</span>;
    strcpy(<span class="keyword">str</span>,a);
    delete[] a;
    <span class="keyword">return</span> <span class="keyword">str</span>;
}    
</code></pre><p>我已开始犯了一个严重，但是我一直因为没弄清楚字符数组，字符串的区别导致的，上一篇总结好了。我用char a[]=”” 最后return a, 发现其实返回之后这块地址因为是栈的被销毁了，所以挂了。。。。<br>于是改成堆，但是又要释放空间这样比较好，然后只能拷贝回str，而且逻辑似乎不好，好不如直接在源串上改。</p>
<p>于是有了下面两个指针的代码，i指向当前处理好的字符串后一个位置，j指向后面待处理的字符串，记得开始记录startpos，所以是[startpos,j) copy回 i开始的位置，里面有个地方容易忽视，就是如果最后面是非空格的一串，后面要避免被赋上空格，或者直接break返回<br>也可以的，不break也可以因为后面condition控制好了越界的情况。</p>
<pre><code><span class="keyword">char</span> *trim(<span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">int</span> len=strlen(<span class="keyword">str</span>);

    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,startpos;
    <span class="keyword">while</span>(j&lt;len)
    {
        startpos=j;
        <span class="keyword">while</span>(j&lt;len &amp;&amp; <span class="keyword">str</span>[j]!=<span class="string">' '</span>)
            j++;
        strncpy(<span class="keyword">str</span>+i,<span class="keyword">str</span>+startpos, j-startpos);

        i+=j-startpos;

        <span class="keyword">if</span>(j&lt;len)<span class="comment">//no more space add</span>
        {
            <span class="keyword">str</span>[i]=<span class="string">' '</span>;
            i++;
        }


        <span class="keyword">while</span>(j&lt;len &amp;&amp; <span class="keyword">str</span>[j]==<span class="string">' '</span>)
            j++;
    }
    <span class="keyword">str</span>[i]=<span class="string">'\0'</span>;

    <span class="keyword">return</span> <span class="keyword">str</span>;
}
</code></pre><p>另外还有一个简单的C++ istringstream版的，但是好像有问题，例如开头一串空格的一个空格就丢了，因为里面封装了太多了，改起来不易。。。</p>
<pre><code><span class="keyword">char</span> *trim(<span class="keyword">char</span> *<span class="keyword">str</span>)
{
    string strcpp=<span class="keyword">str</span>;
    istringstream istr(<span class="keyword">str</span>);
    istr&gt;&gt;outstr;
    <span class="keyword">while</span>(istr&gt;&gt;split)
        outstr+=<span class="string">" "</span>+split;


    strcpy(<span class="keyword">str</span>,outstr.c_str());

    <span class="keyword">return</span> <span class="keyword">str</span>;
}
</code></pre><p>今天再次写这个程设题，总结了一些经验，如果先找非空格，后找空格似乎控制麻烦，就换成先找空格后找费空格，代码很好控制，而且如果能一个一个copy就尽量这种，不要通过计算坐标<br>使得代码还麻烦，尽量不要把break出去的处理，在里面各个分支处理好就可以了。</p>
<pre><code>更简洁的就地双指针遍历版本如下：

<span class="keyword">char</span>* trimspace(<span class="keyword">char</span>* cstr)
{
    <span class="keyword">int</span> cstrlen=<span class="built_in">strlen</span>(cstr);
    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,start;
    <span class="keyword">while</span>(i&lt;cstrlen)
    {
        <span class="comment">//start=i;</span>
        <span class="keyword">bool</span> hasspace=<span class="keyword">false</span>;
        <span class="keyword">while</span>(i&lt;cstrlen &amp;&amp; cstr[i]==<span class="string">' '</span>)
            i++, hasspace=<span class="keyword">true</span>;

        <span class="keyword">if</span>(hasspace==<span class="keyword">true</span>)
            cstr[j]=<span class="string">' '</span>,j++;
        <span class="keyword">if</span>(i==cstrlen)
        {
            cstr[j]=<span class="string">'\0'</span>;
            <span class="keyword">break</span>;
        }
        <span class="keyword">while</span>(i&lt;cstrlen&amp;&amp; cstr[i]!=<span class="string">' '</span>)
            cstr[j++]=cstr[i++];
        <span class="keyword">if</span>(i==cstrlen)
            cstr[j]=<span class="string">'\0'</span>;
    }
    <span class="keyword">return</span> cstr;
}
</code></pre>
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 21 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/21/c-cpp-convert,-char-char-a[]/">c cpp convert, char char a</a></h1>
  

      <time datetime="2014-07-21T11:57:22.000Z"><a href="/2014/07/21/c-cpp-convert,-char-char-a[]/">7月 21 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>对于这一块，fawks大神毫无疑问已经到了一个境界了，我还是个学习的菜鸟。</p>
<p>我当时学的时候，就觉得里面的语法太复杂了，而且各种陷阱，一不小心就掉到坑里去了。。。</p>
<p>先来两个case：</p>
<pre><code><span class="keyword">char</span>* <span class="operator">a</span>=<span class="string">"fawks"</span>
<span class="keyword">char</span> <span class="operator">a</span>[]=<span class="string">"fawks"</span>
</code></pre><p>下面本文从几个方面来比较区别</p>
<ol>
<li><p>两个的是前者a是字符串指针，后者a是字符数组。具体的来说，两者都会在常量区(常量区，堆，栈(通常说的堆栈), 全局\静态存储区)申请一个空间存放fawks这个字符串，<br>然后前者在栈申请一个空间存放字符串指针a，*86 占4B，值为这块常量区的首地址，但是如果cout&lt;&lt;a的时候又会输出这个字符串，而不会输出a的地址，之前李青老师的书记得写过，这是<br>C++的智能处理，包括输出字符数组首地址也是自动输出字符串内容。后者则是将常量区字符串copy到一个栈，然后首地址就是a的地址，这个是字符数组。并且要注意前者最好是写成</p>
<p> const char*a =”fawks”</p>
</li>
</ol>
<p>因为不能通过a来修改字符串所在常量区的值，所以const会比较安全，但是后面修改a的指向又是可以的。</p>
<ol>
<li><p>后面继续赋值：</p>
<p> a=”zrc”</p>
</li>
</ol>
<p>这句话对于前者是可以的，因为把栈中指针a的值改为zrc的地址，a指向了常量区另一个区域zrc的首地址，而后者是不可以的，因为a已经固定下来了指向一个栈中fawks的首地址，字符数组只能初始化不能赋值。</p>
<ol>
<li>另外还有一个区别要注意<br> sizeof(a);</li>
</ol>
<p>这句话对于前者输出4(*86),因为这个指针占得空间是4个字节，因为32bit地址，8bit占一个Byte，如果字节寻址的话(一般这么理解)，所以占4个存储单元。而后者则是输出5，注意与strlen(a)的区别，<br>因为sizeof()是看占得内存空间大小，所以包含结束符\0(ASCII 0)， strlen是字符串长度，不包含结束符。</p>
<p>4.所以如果函数返回一个char<em>, 如果你定义的char a[]=””, 然后return a就会挂，虽然过程是先返回了a指向的地址，然后再结束函数，但是这块是栈空间，函数结束就销毁了这块栈，所以位置是野值。。。<br>而后者是字符串存在常量去，随着程序开始就在那直到程序结束，所以char</em>a =””, return a完全没问题，而且函数先返回，后销毁栈变量也保证了他的正确性，a是栈中的一个指针变量。</p>
<ol>
<li>数组(char a[])可以转化为指针(char* a)，指向字符串的指针，但是指针未必可以转为数组，因为如果指向字符串常量的话，那么就不能作为数组了，因为没法修改它们的值。</li>
</ol>
<p>另外要注意字符串常量如果赋值(不是初始化)给char* 可能有警告，例如</p>
<pre><code><span class="keyword">char</span> *s;
s=<span class="string">"hello"</span>;
</code></pre><p>但是char* s=”hello” 是可以的，其实还是加个const安全些。附上</p>
<pre><code>string <span class="keyword">str</span>=(<span class="keyword">char</span>*)s;
<span class="keyword">char</span> *s=<span class="keyword">str</span>.c_str();
</code></pre><p>上面一句可以，二句不可以的，因为c_str()返回const char<em> ,不可以const char</em> 赋给char*, 但是反过来可以，我付给一个保证不修改内容的指针的嘛</p>
<pre><code><span class="keyword">const</span> <span class="built_in">char</span>* s=(<span class="built_in">char</span>*)<span class="built_in">cstr</span>;
</code></pre><p>引用 <a href="http://www.zhihu.com/question/20779337" target="_blank" rel="external">http://www.zhihu.com/question/20779337</a><br><a href="http://blog.csdn.net/hackbuteer1/article/details/6706562" target="_blank" rel="external">http://blog.csdn.net/hackbuteer1/article/details/6706562</a></p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 21 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/21/c-cpp-string-in-out-summary/">c cpp string in out summary</a></h1>
  

      <time datetime="2014-07-21T09:39:28.000Z"><a href="/2014/07/21/c-cpp-string-in-out-summary/">7月 21 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>比较熟悉的大神可以飘过了。。。之前对于C C++ string char* 尤其是输入的一堆东西弄得晕头转向，主要是用getline 输入string来处理，但是<br>如果让写C风格的，可能我就挂了。。。</p>
<p>getline(istream&amp; istr, string str, delim)//一般是用这个来输入字符串的</p>
<p>后来看到一个很像的cin.getline(char* str, delim=’\n’), 如果是读一行，还是建议写\n吧，默认参数这么多指不定那条搞晕了= =  如果是写C++，尽量用前者好像</p>
<p>于是后面有出来了 gets fgets scanf(), 这么一堆输入char<em>的函数，gets网上说是不安全的，因为没有设置输入缓存区，有溢出的风险，尽量<br>用fgets去代替，但是谁知道呢：<br>fgets(char </em>str, int num, FILE<em> stream),当然File</em> 也可以传入stdin来表示从标准输入，有点奇怪，后来查了才知道stdin就是File*类型的。<br>但是我后来漏看了cplusplus文档，有个重要的漏了，就是fgets如果输入的最后有个\n,最后读到str里面的字符串也会加一个\n,这不得不说是个巨大的隐患，还是应该相信fawks大神的，<br>用gets，先不管隐患，至少目前编的代码还不会有溢出的隐患。</p>
<p>cin&gt;&gt;输入的话，默认delim 是 space \t 和\n,这个要记住，因为没有参数的，所以数字由于中间不可能有这些delim，可以安全用，但是字符串不是通过<br>这些delim来区分的，所以完全可能中间有这些字符，用cin就悲剧了，cplusplus官网也说cin是notorious的，</p>
<p>scanf() ACMer C C++混编混C的部分主要是由于C++流输入输出比较慢，采用C的函数直接把输入写到内存地址处来提高效率。<br>scanf(“%d”, &amp;x);记住这个是输入地址，和printf只需要print值不一样</p>
<p>另外要特别留意输入int之后的string，如果敲回车的话，因为fgets gets getline cin.getline 这一系列输入字符串都是默认\n结束的，而如果前面整数是敲回车结束的(多数是这样的)，那么<br>后面输入字符串的就是空串，因为\n还留在输入缓冲区里，那么这些读取直到\n就相当于读了空串了，所以最好之前再读取一次把空串读掉，其实scanf(%c)会有这个问题，scanf(%s) cin不会存在这个问题，但是字符串中间又空格就截断了。</p>
<p>总结下来tips就是，输入C字符串用gets可以不指定长度，感觉似乎方便，如果不写大的项目，隐患也还好，fgets需要指定长度和源stdin，可能麻烦点，也可以用cin.getline,而且这个优点在于还有<br>delim参数，因此如果有其他要求的话可能只能用cin.getline了。</p>
<p>C++字符串必须是getline(cin,str,delim=’\n’),输入字符串特别当心前面有int输入的时候，是否留了一个\n在缓冲区里，之前还有做法是cin.clear来清空。<br>另外stdin和cin是同步的，cin是C++的，但是好像stdin好像是标准输入，默认是键盘，如果需要freopen重定向的时候，一般都用stdin</p>
<p>基本delim默认都是\n, 例如getline(string::getline), cin.getline(istream::getline), cin是空格，\t \n来区分整数或者字符串的，用在字符串可能就挂了。</p>
<p>特别注意cin.getline(char*str, int num, delim=’\n’) 里面的num是指包含结束符的</p>
<p>另外今天看到一个代码还是不清楚为啥</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="keyword">int</span> main()
{
    <span class="keyword">char</span> str[<span class="number">8</span>];
    <span class="built_in">cin</span>.getline(str, <span class="number">5</span>);
    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;endl;
    <span class="built_in">cin</span>.getline(str, <span class="number">5</span>);
    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;endl;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>代码来自 <a href="http://www.cnblogs.com/A-Song/archive/2012/01/29/2331204.html" target="_blank" rel="external">http://www.cnblogs.com/A-Song/archive/2012/01/29/2331204.html</a> 对notorious的cin进行了一番批评似乎</p>
<p>34哥说过了，因为有一个问题，第一次输入就因为截断了，flag置1，然后后面就不读了。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 21 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/20/back-k-node-in-linklist/">back k node in linklist</a></h1>
  

      <time datetime="2014-07-20T15:37:33.000Z"><a href="/2014/07/20/back-k-node-in-linklist/">7月 20 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>今天偶然看到09CS考研题，DS的最后一题，之前肯定是做过的，但是今天看到又忘记了，面试问到估计后悔死了。。。</p>
<p>求链表倒数第k个结点，k&gt;=1, 这种题时属于另一类，并不会渐进意义上降低时间复杂度，但是可以减少比较次数，其实当数据量打上去之后，也会有明显的提升。<br>我还是想到最朴素的遍历一遍求长度，然后在便利到l-k+1个。</p>
<p>后来看到答案，设置两个指针，一开始就间隔k一直移后指针到尾，直接返回前一指针就可以啦。我愣是没想起来。<br>相比之前的算法，我感觉指针移动的次数是一样的，只是不需要记录链表长度这样一个变量而已啦，都是移动l+l-k次指针吧，但是舆论还是觉得后面的算法要好，感觉高端点么。。。所谓的逼格高。。。</p>
<p>于是总结链表经典题目的解法好像很多都是用多个指针，我当时都没想到多用几个指针，然后要么是快慢指针(每次移动的速度恒定，且不一样)，要么是interval 指针，始终保持<br>k的距离，感觉这几种思路都是这样，还有逆置链表是三个指针，prev，p, pnext这三个。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 20 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/20/数组跳跃遍历减少比较次数/">数组跳跃遍历减少比较次数</a></h1>
  

      <time datetime="2014-07-20T14:59:30.000Z"><a href="/2014/07/20/数组跳跃遍历减少比较次数/">7月 20 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>这道题目找了一个同学一起想，后来发现题目是野路子来的，最后题目意思理解除了偏差，衰。。。。再次表示诚挚的抱歉，是我错了。。。不过正好拓宽了思路，也把另一种问法解决了</p>
<p>原题描述：<br>在相邻元素相差1的数组中查找某一特定元素第一次出现的位置(非遍历)</p>
<p>通过各种渠道传到我这里，就变成了：<br>数组A中任意两个相邻元素大小相差1，现给定这样的数组A和目标整数t，找出t在数组A中的位置。</p>
<p>我想先自己思考，于是也没细究题目，认为题目是指找出所有的t的index出来，如果元素不重复的话，那就太简单了，直接定位i=|t-a[0]|，如果是的话返回index，不是的话，直接退出循环说找不到了。<br>我已开始以为这个是在时间复杂度渐进意义上要从线性减少，首先想到的是对数，但是感觉又想不到对数复杂度的算法。</p>
<p>思考这种题目，感觉就是需要归纳一些性质出来，提高效率，不论能够降低时间复杂度，都至少可以减少次数吧。</p>
<p>性质1：如果两个元素a[i] a[j]的差和index差相等，那么之间的元素一定是从(a[i],a[j])之间逐个递增或递减，也即不可能出现等于a[i]或a[j]</p>
<p>性质2：相邻2个元素一定是奇偶性相反，所以如果当前t和i同奇偶性,则解不可能是i-1 i+1的话，也一定只可能是i+2，不可能是i+1, i+3,</p>
<p>所以针对这些性质，如果对于问题输出所有t的index的话，我有了下面的代码：</p>
<pre><code>void FindXIndex(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> <span class="keyword">x</span>)
{
    <span class="keyword">int</span> xi,j,tmp;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)
    {
        <span class="keyword">if</span>(a[i]==<span class="keyword">x</span>)
        {
            xi=i;
            <span class="keyword">break</span>;
        }
    }
    <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span> "</span>, xi);
    <span class="keyword">while</span>(<span class="keyword">abs</span>(j-xi)&gt;=<span class="number">2</span>)
    {
        <span class="keyword">if</span>(<span class="keyword">abs</span>(a[j]-a[xi])==<span class="keyword">abs</span>(j-xi))
            <span class="keyword">break</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(a[j]==<span class="keyword">x</span>)
        {
            <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span> "</span>, j);
            <span class="keyword">if</span>(xi&lt;j)
            {
                tmp=xi, xi=j, j=tmp+<span class="number">1</span>;
            }
            <span class="keyword">else</span>
            {
                tmp=xi, xi=j, j=tmp-<span class="number">1</span>;
            }
        }
        <span class="keyword">else</span> 
        {
            <span class="keyword">if</span>(xi&lt;j) j--;
            <span class="keyword">else</span> j++;
        }
    }
    <span class="keyword">return</span>;
}
</code></pre><p>先从找到一个t的index，然后从另一端向这段搜索，如果存在差值等于index差值，则直接返回，因为中间不可能还有t了，也即区间收缩到0了。所以循环的条件是区间长度是否大于1，如果等于1的话也不用了，只有一个元素，必为已经搜过的xi，<br>且程序里a[xi]=t的。然后j始终从当前值向xi靠近，注意根据和xi大小关系，判断++ 还是 —</p>
<p>这个算法是输出所有的index，后来看了下题目，原始不需要全部，好吧，自己做了一道新题。。。。</p>
<p>如果是只要返回任意一个，当然效率尽可能高，也即如何最快找到t的一个index，可以先从一端开始，例如0，先和a[0]比较，|t-a[0]|+0,是可能的t的位置，而且从(0 , |t-a[0]|+0)之间 是不可能出现解的，因为最快的增长(下降)速度才能使得边界达到t，<br>如果t=a[0]的话，0也可能, 所以第一步就大胆往前跳，同时第一步跳到的一定是奇偶性和t一致的点，所以改点两边的点和t奇偶性反，不可能是解，于是乎可以大胆的两步一跳。</p>
<pre><code><span class="keyword">int</span> findpos(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> v)  
{  
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">abs</span>(v-a[<span class="number">0</span>]); i &lt; n; i+=<span class="number">2</span>)  
        <span class="keyword">if</span>(a[i] == v)  
            <span class="keyword">return</span> i;  
    <span class="keyword">return</span> -<span class="number">1</span>;  
}
</code></pre><p>代码来自：<a href="http://blog.csdn.net/u010590166/article/details/17250653#cpp" target="_blank" rel="external">http://blog.csdn.net/u010590166/article/details/17250653#cpp</a><br>后来发现这个其实还不够优，看到下面童鞋的代码，好像更优<br><a href="http://m.blog.csdn.net/blog/pein0119/11678997" target="_blank" rel="external">http://m.blog.csdn.net/blog/pein0119/11678997</a><br>不止是第一步跳跃，而是每次都是跳跃前进，直到找到或者遍历完位置，</p>
<pre><code><span class="built_in">i</span>=<span class="built_in">abs</span>(a<span class="matrix">[i]</span>-t);
</code></pre><p>通过这句代码来实现的。</p>
<p>另外再加深一下印象，C语言的scanf 后面参数是地址， printf后面是变量，为什么是这样呢？思考一下原因更容易记住用法，因为输入是要把变量从键盘输到内存某个地址去，自然需要地址了，而打印只需要这个值传过来就行了，例如输出缓冲区，<br>实际上C++已经封装好了一切，所以不需要我们考虑，一律都是变量名了。C语言会更底层一些。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 20 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<nav id="pagination">
  
    <a href="/page/11/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/13/" class="alignright next">下一页</a>
  
</nav></div>
    </div>
    <div class="tabbar" onload="divideTabBar()">
	
      <div class="tabbaritem"><a class="next" href="/">Home</a></div>
    
      <div class="tabbaritem"><a class="next" href="/archives/">Archives</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a></div>
    
</div>


  </div>
</body>
</html>