<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 4 页 | Richard</title>
  <meta name="author" content="Richard">
  
  <meta name="description" content="理查德爱闹">
  
  
  
  <meta property="og:site_name" content="Richard"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta property="og:image" content="undefined"/>
  
   <link rel="apple-touch-icon" href="/icon.png" />
   <link rel="shortcut icon" href="/favicon.png" >
   <link rel="alternate" href="http://xxx.xx/atom.xml" title="Richard" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
</head>


<body>
  <div id="content" class="inner">
    <aside id="sidebar" class="alignleft">
      <div class="navigationBar">
        <a href="/">Richard</a>
      </div>
    	
  <nav class="widget" id="menu">
	<ul>
    
      <li class="cell"><a class="next" href="/">Home</a><li>
    
      <li class="cell"><a class="next" href="/archives/">Archives</a><li>
    
      <li class="cell"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a><li>
    
      <li class="cell"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a><li>
    
      <li class="cell"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a><li>
    
    </ul>
</nav>

  <div class="widget weibo">
  <iframe width="100%" height="750" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=750&fansRow=2&ptype=1&speed=0&skin=6&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2689136623&verifier=c139aa37&dpc=1"></iframe>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Binary-Tree/">Binary Tree</a><small>1</small></li>
  
    <li><a href="/categories/DFS/">DFS</a><small>1</small></li>
  
    <li><a href="/categories/DP/">DP</a><small>1</small></li>
  
    <li><a href="/categories/Recursive/">Recursive</a><small>1</small></li>
  
    <li><a href="/categories/algorithm/">algorithm</a><small>7</small></li>
  
    <li><a href="/categories/binary-search/">binary search</a><small>2</small></li>
  
    <li><a href="/categories/binary-tree/">binary tree</a><small>3</small></li>
  
    <li><a href="/categories/bit/">bit</a><small>1</small></li>
  
    <li><a href="/categories/bit-operation/">bit operation</a><small>2</small></li>
  
    <li><a href="/categories/blog/">blog</a><small>1</small></li>
  
    <li><a href="/categories/cpp/">cpp</a><small>9</small></li>
  
    <li><a href="/categories/cpp-string/">cpp string</a><small>1</small></li>
  
    <li><a href="/categories/data-structure/">data structure</a><small>3</small></li>
  
    <li><a href="/categories/dfs/">dfs</a><small>1</small></li>
  
    <li><a href="/categories/dp/">dp</a><small>2</small></li>
  
    <li><a href="/categories/ds/">ds</a><small>1</small></li>
  
    <li><a href="/categories/hash/">hash</a><small>1</small></li>
  
    <li><a href="/categories/hexo-configuration/">hexo configuration</a><small>1</small></li>
  
    <li><a href="/categories/hihocode/">hihocode</a><small>1</small></li>
  
    <li><a href="/categories/kmp/">kmp</a><small>1</small></li>
  
    <li><a href="/categories/linklist/">linklist</a><small>4</small></li>
  
    <li><a href="/categories/permutation/">permutation</a><small>2</small></li>
  
    <li><a href="/categories/quick-and-right-coding/">quick and right coding</a><small>1</small></li>
  
    <li><a href="/categories/web/">web</a><small>2</small></li>
  
    <li><a href="/categories/数字规律/">数字规律</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/BST/" style="font-size: 10.00px;">BST</a><a href="/tags/BT/" style="font-size: 10.00px;">BT</a><a href="/tags/Backtrack/" style="font-size: 10.00px;">Backtrack</a><a href="/tags/Combinations/" style="font-size: 10.00px;">Combinations</a><a href="/tags/DP/" style="font-size: 10.00px;">DP</a><a href="/tags/Order/" style="font-size: 10.00px;">Order</a><a href="/tags/Permutation/" style="font-size: 10.00px;">Permutation</a><a href="/tags/algorithm/" style="font-size: 20.00px;">algorithm</a><a href="/tags/array/" style="font-size: 15.00px;">array</a><a href="/tags/backtrack/" style="font-size: 10.00px;">backtrack</a><a href="/tags/binary-search/" style="font-size: 12.50px;">binary search</a><a href="/tags/bit/" style="font-size: 15.00px;">bit</a><a href="/tags/brute-force/" style="font-size: 12.50px;">brute force</a><a href="/tags/c/" style="font-size: 10.00px;">c</a><a href="/tags/char/" style="font-size: 10.00px;">char*</a><a href="/tags/coding/" style="font-size: 10.00px;">coding</a><a href="/tags/complement/" style="font-size: 10.00px;">complement</a><a href="/tags/complex/" style="font-size: 12.50px;">complex</a><a href="/tags/complex-condition-analysis/" style="font-size: 10.00px;">complex condition analysis</a><a href="/tags/configuire/" style="font-size: 10.00px;">configuire</a><a href="/tags/convert/" style="font-size: 10.00px;">convert</a><a href="/tags/cpp/" style="font-size: 15.00px;">cpp</a><a href="/tags/cpp，inheritance/" style="font-size: 10.00px;">cpp，inheritance</a><a href="/tags/cycle/" style="font-size: 10.00px;">cycle</a><a href="/tags/data-structure/" style="font-size: 17.50px;">data structure</a><a href="/tags/data-type/" style="font-size: 12.50px;">data type</a><a href="/tags/digit/" style="font-size: 10.00px;">digit</a><a href="/tags/divide/" style="font-size: 10.00px;">divide</a><a href="/tags/divide-2/" style="font-size: 10.00px;">divide 2</a><a href="/tags/domain/" style="font-size: 10.00px;">domain</a><a href="/tags/dp/" style="font-size: 15.00px;">dp</a><a href="/tags/find/" style="font-size: 10.00px;">find</a><a href="/tags/finding-rule/" style="font-size: 10.00px;">finding rule</a><a href="/tags/git/" style="font-size: 10.00px;">git</a><a href="/tags/github/" style="font-size: 10.00px;">github</a><a href="/tags/graph/" style="font-size: 10.00px;">graph</a><a href="/tags/greedy/" style="font-size: 10.00px;">greedy</a><a href="/tags/hash/" style="font-size: 10.00px;">hash</a><a href="/tags/head-process/" style="font-size: 10.00px;">head process</a><a href="/tags/hexo/" style="font-size: 12.50px;">hexo</a>
  </div>
</div>


    	<footer id="footer" class="inner"><div class="copyright">
  
  &copy; 2014 Richard
  
</div>



</footer>
    </aside>
    
    
    <div id="hidden-navigationBar" class="navigationBar">
      <a href="/">Richard</a>
    </div>
    <div id="main-col" class="alignright">
    <div id="wrapper">
      
  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/19/BinaryAdd/">BinaryAdd</a></h1>
  

      <time datetime="2014-07-19T11:48:46.000Z"><a href="/2014/07/19/BinaryAdd/">7月 19 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>这个题真的是自己摔了好多跤才爬起来的。。。自己还是考虑问题不全面，在软件测试的时候，估计会摔得更惨。。。<br>一开始想两种方案，二进制加，后者转十进制加，然后转回二进制，心想二进制加还要reverse才好加，不然对不齐，于是十进制，结果溢出了，用最大的unsigned long long还是溢出，这个可是20位十进制啊。。。<br>所以这种题目设计的就不是用十进制加法，而是要自己去实现一个加法，考虑各种情况，就像int的 +一样。</p>
<p>于是开始考虑情况，需要forward表示进位，然后还有长度不一样多出的怎么办，而且首先要reverse的，这样才对得齐。。。<br>于是由一般的写起，a[i]+b[i]+forward-2 &gt;= &lt;0来判断是否进位，然后后面也forward变为0 1,相应的，=0的我已开始忘记赋了，只记得比较重要的，进位需要赋1.。。<br>长度超出了怎么办？一定不能越界，于是判断是否超出任意一个的长度，如果超出了，且有进位，还要注意，可能一直进位，所以不能直接append后面多出的，如果forward=0 就append，然后还有最后多出一个<br>进位还要单独加一个”1”。我主要是一开始没有想清楚就coding，然后后面一个一个改，还是弄了一会儿，另外指针后移是每一个都后移，其他的break，我已开始最后全部 if else case都写了++，最后里面分支有的又<br>写了++，这个也忘记了。感觉这个逻辑的复杂度不亚于atoi函数的。。。。</p>
<p>summary：forward=0 且至少一个越界，直接append后面多出的部分，因为后面不再进位(注意此处两个都越界可以放到其中任意一个里，因为substr() startpos如果长度超过了，则返回空串，刚好符合要求)<br>         forward=1 且至少一个越界，区分拿一个越界，然后加上a[i]+foward 看是否有进位，i++(这里两个都越界要单独处理，因为访问b[i]会越界，不想substr()能够tackle这种case，然后看如果进位，直接+”1”)<br>         都不越界(forward=0 1可以统一起来)， 普通处理<br>附上代码：</p>
<pre><code><span class="keyword">string</span> addBinary(<span class="keyword">string</span> a, <span class="keyword">string</span> b)
    {
        reverse(a.begin(),a.end());
        reverse(b.begin(),b.end());
        <span class="keyword">int</span> forward=<span class="number">0</span>,i=<span class="number">0</span>;
        <span class="keyword">string</span> c=<span class="string">""</span>;
        <span class="keyword">while</span>(<span class="number">1</span>)
        {
            <span class="keyword">if</span>(forward==<span class="number">0</span> &amp;&amp; (i&gt;= a.<span class="keyword">size</span>() || i&gt;= b.<span class="keyword">size</span>()))
            {
                <span class="keyword">if</span>(i&gt;= a.<span class="keyword">size</span>())
                {
                    c+=b.substr(i);
                }
                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;= b.<span class="keyword">size</span>())
                    c+=a.substr(i);
                <span class="keyword">break</span>;
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(forward==<span class="number">1</span> &amp;&amp; (i&gt;= a.<span class="keyword">size</span>() || i&gt;= b.<span class="keyword">size</span>()))
            {
                <span class="keyword">if</span>(i&gt;=a.<span class="keyword">size</span>() &amp;&amp; i&lt; b.<span class="keyword">size</span>())
                {
                    <span class="keyword">if</span>(b[i]-<span class="string">'0'</span>+forward&gt;=<span class="number">2</span>)
                    {

                        c+=char(b[i]-<span class="string">'0'</span>+forward-<span class="number">2</span>+<span class="string">'0'</span>);
                        forward=<span class="number">1</span>;
                    }
                    <span class="keyword">else</span>
                    {
                        c+=char(b[i]-<span class="string">'0'</span>+forward+<span class="string">'0'</span>);
                        forward=<span class="number">0</span>;

                    }
                    i++;
                }
                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=b.<span class="keyword">size</span>() &amp;&amp; i&lt; a.<span class="keyword">size</span>())
                {
                    <span class="keyword">if</span>(a[i]-<span class="string">'0'</span>+forward&gt;=<span class="number">2</span>)
                    {

                        c+=char(a[i]-<span class="string">'0'</span>+forward-<span class="number">2</span>+<span class="string">'0'</span>);
                        forward=<span class="number">1</span>;
                    }
                    <span class="keyword">else</span>
                    {
                        c+=char(a[i]-<span class="string">'0'</span>+forward+<span class="string">'0'</span>);
                        forward=<span class="number">0</span>;

                    }
                    i++;
                }
                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=b.<span class="keyword">size</span>() &amp;&amp; i&gt;= a.<span class="keyword">size</span>())
                {
                    c+=<span class="string">"1"</span>;
                    <span class="keyword">break</span>;

                }

            }
            <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;a.<span class="keyword">size</span>()&amp;&amp;i&lt;b.<span class="keyword">size</span>())
            {
                <span class="keyword">if</span>(a[i]-<span class="string">'0'</span>+b[i]-<span class="string">'0'</span>+forward&gt;=<span class="number">2</span>)
                {

                    c+=char(a[i]-<span class="string">'0'</span>+b[i]-<span class="string">'0'</span>+forward-<span class="number">2</span>+<span class="string">'0'</span>);
                    forward=<span class="number">1</span>;
                }
                <span class="keyword">else</span>
                {
                    c+=char(a[i]-<span class="string">'0'</span>+b[i]-<span class="string">'0'</span>+forward+<span class="string">'0'</span>);
                    forward=<span class="number">0</span>;
                }
                i++;
            }

            <span class="comment">//i++;</span>
        }
        reverse(c.begin(),c.end());
        <span class="keyword">return</span> c;
    }
</code></pre><p>记得最后要reverse回来</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 19 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/19/Min-Path-Num--Typical-DP/">Min Path Num--Typical DP</a></h1>
  

      <time datetime="2014-07-19T09:08:54.000Z"><a href="/2014/07/19/Min-Path-Num--Typical-DP/">7月 19 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>我和刘辉师兄坐在一起，就是你做事情，我突然哈哈大笑，然后我做做事情，你突然哈哈大笑O(∩_∩)O</p>
<p>这道题目属于容易看出的DP，从曹博PPT了看到例子后就反应更快了，不过感觉这个已经是曹博PPT最容易make sense的DP了= =<br>二维表格记录DP，初始化0 0， 以及0 j， i 0, 这样保证后面计算的子问题前面都计算出来了，注意下表不越界，还有就是<br>leetcode题目都没给数据范围，因此都不敢用全局变量了，正如fawks大神说的，global的比较简单，于是我还是用heap了。。。</p>
<p>附上代码：</p>
<pre><code><span class="keyword">int</span> Min(<span class="keyword">int</span> x, <span class="keyword">int</span> y)
    {
        <span class="keyword">if</span>(x&lt;y) <span class="keyword">return</span> x;
        <span class="keyword">else</span> <span class="keyword">return</span> y;
    }
    <span class="keyword">int</span> minPathSum(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> &amp;grid) {
        <span class="keyword">int</span> row=grid.size();
        <span class="keyword">if</span>(row==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">int</span> col=grid.at(<span class="number">0</span>).size();
        <span class="keyword">if</span>(col==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;

        <span class="keyword">int</span> **dp=<span class="keyword">new</span> <span class="keyword">int</span>*[row];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)
            dp[i]=<span class="keyword">new</span> <span class="keyword">int</span>[col];

        dp[<span class="number">0</span>][<span class="number">0</span>]=grid.at(<span class="number">0</span>).at(<span class="number">0</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col;j++)
            dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j-<span class="number">1</span>]+grid.at(<span class="number">0</span>).at(j);
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row;i++)
            dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid.at(i).at(<span class="number">0</span>);

        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=row-<span class="number">1</span>;i++)
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=col-<span class="number">1</span>;j++)
            {
                dp[i][j]=Min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid.at(i).at(j);
            }
        }
        <span class="keyword">int</span> max=dp[row-<span class="number">1</span>][col-<span class="number">1</span>];


        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)
            <span class="keyword">delete</span>[] dp[i];
        <span class="keyword">delete</span>[] dp;
        <span class="keyword">return</span> max;
    }
</code></pre><p>里面需要注意的是没有C++11，所以没有min可能。。。另外我每次都是写完general case再在前面加exception case的，比较舒服，之前一次提交还忘记返回值了= =<br>自己要逐渐转向不debug，因为后面纸上代码比较多些，直接在leetcode写了，眼睛看了submit</p>
<p>另外今天突然意识到vector可以当数组用的[], 之前一直at写起来麻烦，但是[]不越界检查，后果自负，我还是习惯[]呢，只是list就没有[]了。。<br><a href="http://zhuyanfeng.com/archives/783" target="_blank" rel="external">http://zhuyanfeng.com/archives/783</a></p>
<p>最近发现小米手机Wifi老是断，其他的小米却没有。感觉排除了wifi信号的问题，于是还是之前一直怀疑的系统故意设计这样，节约资源，例如电之类的，不需要的时候自动断掉，但是我需要的时候<br>也经常断掉啊%&gt;_&lt;%，之前查到好像是德州电器写的wifi驱动里面代码有这么节约资源的设计，好像点到wifi他才连上。。。不太确定，之前想找找帖子解决这个问题的，一直没搞定o(╯□╰)o</p>
<p>一个阿三和我说，她又认识了一个美女，而且是fb主动勾引他的。。。这位可真是把把妹当成一生的主题啊，他还尤其喜欢Chinese girls，尤其是她们的hair style，说一看背后就知道中国女孩，她们都<br>比印度女孩漂亮，还问我是不是jealous = =</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 19 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/19/from-Word-Break-to-substr-function-note/">from Word Break to substr function note</a></h1>
  

      <time datetime="2014-07-19T08:35:44.000Z"><a href="/2014/07/19/from-Word-Break-to-substr-function-note/">7月 19 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p><a href="https://oj.leetcode.com/problems/word-break/" target="_blank" rel="external">https://oj.leetcode.com/problems/word-break/</a><br>这道题目不是重点，重点是用string::substr的一点体会。<br>substr(size_t pos, size_t len=string::npos)</p>
<p>这个是substr的document，默认第二个参数npos表示取到字符串源串最后面，而且特别注意都是size_t类型，<br>我有一次掉到坑里去了，第二个参数一定要是&gt;=0的，如果负数就会返回整个源串，要特别注意，另外pos也是&gt;=0，这个倒好理解。<br>而且这个比较好，只有一种参数列表，这样比较容易记忆使用，当然如果参数列表多，用多了一般也是用自己比较熟悉的那一种。</p>
<p>代码是错的，有些case不行，可能需要回溯，类似dfs这种</p>
<pre><code><span class="keyword">bool</span> wordBreak(<span class="built_in">string</span> s, <span class="stl_container"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;</span> &amp;dict) {
        <span class="keyword">if</span>(s==<span class="string">""</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">while</span>(<span class="number">1</span>)
        {
            <span class="keyword">if</span>(s==<span class="string">""</span>)
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="keyword">bool</span> found=<span class="keyword">false</span>;
            <span class="keyword">int</span> startpos;
            <span class="built_in">string</span> substr1,substr2;
            <span class="keyword">for</span>(<span class="stl_container"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;</span>::iterator it=dict.begin();it!=dict.end();it++)
            {
                <span class="keyword">if</span>((startpos=s.find(*it))!=<span class="built_in">string</span>::npos)
                {
                    found=<span class="keyword">true</span>;
                    <span class="keyword">if</span>(startpos-<span class="number">1</span>&gt;=<span class="number">0</span>)
                        substr1=s.substr(<span class="number">0</span>,startpos);
                    <span class="keyword">else</span>
                        substr1=<span class="string">""</span>;

                    <span class="built_in">string</span> substr2=s.substr(startpos+(*it).size(),s.size()-(startpos+(*it).size()));
                    s=substr1+substr2;
                }
            }
            <span class="keyword">if</span>(found==<span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        }
    }
</code></pre>
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 19 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/19/Gas-Station/">Gas Station</a></h1>
  

      <time datetime="2014-07-19T08:15:50.000Z"><a href="/2014/07/19/Gas-Station/">7月 19 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>这道题目，有点难。我没想出线性算法，写了一个朴素的n^2的，最后TLE了，感觉很像最大字段和，最后看了题解，也确实如此，但是可能还是理解不够透彻吧，想起那句名言：</p>
<p>What I can not create, I can not understand.</p>
<p>所以还是只停留在运用这些经典题目的算法上，而没有完全掌握这一类题。<br>题目是<a href="https://oj.leetcode.com/problems/gas-station/" target="_blank" rel="external">https://oj.leetcode.com/problems/gas-station/</a><br>思路比较朴素，转化为每一站gasi-costi的diff，那么照这样一个starti，使得sum(starti,j)&gt;=0 for j=starti-&gt;(starti-1+n)%n, 这里可能有loop，要取模变回来，抽象成这样一个<br>等价问题是不难的，但是后面如何一次遍历，就确定这个starti是难的。</p>
<p>注意题目说了只有唯一解，这个很重要，后面强的性质是基于这个条件的。</p>
<p>性质1：如果sum(starti,i)加起来<0,且sum(starti,k)>=0 starti&lt;=k&lt;i, 则最后一个i之前一直到starti都不可能是解</0,且sum(starti,k)></p>
<p>证明: 因为sum(starti,i)<0, 若存在i<="k<starti为解，由于sum(starti,k-1)">=0 (由已知得到，除掉加到i sum<0, 前面都="">=0,不然是加不到这里的)，则sum(k,i)=sum(starti,i)-sum(starti,k-1)&lt;0, 因此<br>以k为起始的n个和里有一个必&lt;0,所以k不可能是解。</0,></0,></p>
<p>性质2：如果sum(1,n)&lt;0,则返回-1</p>
<p>哈哈，这个性质比较简单，我自己加的~~~</p>
<p>因此根据上述确立算法，如果起始开始，随意哪个作为起始都可以，加到第一次sum<0, 则前面的不可能是解，排除，记录解的变量j排除掉前面，j="i+1," sum="0，表示从新开始找一段和<0的index范围，排除掉之后" 最后退出loop时="" j记录的是前面几段负和的后一个index，同时看总和<0="" 的话返回-1，="" 总和都付不可能有节，因为任意一个必须n个sum="">0,且任意一个接都包含总和；否则，返回j,这是需要利用题目只有唯一解性质的，<br>因为后面可能还有节，但是题目说了唯一解，因此这个正确，但是可能最后一个元素 n 前面有段sum&lt;0 那j岂不等于n+1越界了？这个不可能出现，因为如果出现，势必前面全是一段一段的sum&lt;0, 总和&lt;0 在另一个分支里面<br>O(∩_∩)O哈哈~</0,></p>
<p>赋上代码，</p>
<pre><code><span class="keyword">int</span> canCompleteCircuit(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &amp;gas, <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &amp;cost)
    {
        <span class="keyword">if</span>(gas.size()==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;
        <span class="keyword">int</span> n=gas.size();
        <span class="keyword">int</span> sum=<span class="number">0</span>,j=<span class="number">0</span>,total=<span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)
        {
            sum+=gas[i]-cost[i];
            total+=gas[i]-cost[i];
            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)
            {
                j=i+<span class="number">1</span>;
                sum=<span class="number">0</span>;
            }
        }
        <span class="keyword">if</span>(total&lt;<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> j;
    }
</code></pre><p>另外赋上看的两个题解，<br><a href="http://leetcodenotes.wordpress.com/2013/11/21/leetcode-gas-station-%E8%BD%AC%E5%9C%88%E7%9A%84%E5%8A%A0%E6%B2%B9%E7%AB%99%E7%9C%8B%E8%83%BD%E4%B8%8D%E8%83%BD%E8%B5%B0%E4%B8%80%E5%9C%88/" target="_blank" rel="external">http://leetcodenotes.wordpress.com/2013/11/21/leetcode-gas-station-%E8%BD%AC%E5%9C%88%E7%9A%84%E5%8A%A0%E6%B2%B9%E7%AB%99%E7%9C%8B%E8%83%BD%E4%B8%8D%E8%83%BD%E8%B5%B0%E4%B8%80%E5%9C%88/</a><br><a href="http://blog.csdn.net/kenden23/article/details/14106137" target="_blank" rel="external">http://blog.csdn.net/kenden23/article/details/14106137</a></p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 19 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/19/CycleList-Trap/">CycleList Trap</a></h1>
  

      <time datetime="2014-07-19T03:48:25.000Z"><a href="/2014/07/19/CycleList-Trap/">7月 19 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>之前总结了这种带环链表检测，包括两个链表相交，对于快慢指针如何确保找到环头还进行了proof，但是写代码的时候，还是犯了一个错误：</p>
<pre><code>class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;
        ListNode* slow=head, *fast=head-&gt;<span class="keyword">next</span>;
        <span class="keyword">while</span>(slow!=<span class="literal">NULL</span> &amp;&amp; fast !=<span class="literal">NULL</span>)
        {
            <span class="keyword">if</span>(slow==fast) <span class="keyword">break</span>;
            slow=slow-&gt;<span class="keyword">next</span>;
            <span class="keyword">if</span>(fast-&gt;<span class="keyword">next</span>==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;
            fast=fast-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
        }

        <span class="keyword">if</span>(slow==<span class="literal">NULL</span> || fast ==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;
        ListNode* p=head;
        <span class="keyword">while</span>(p!=slow)
        {
            p=p-&gt;<span class="keyword">next</span>;
            slow=slow-&gt;<span class="keyword">next</span>;
        }
        <span class="keyword">return</span> p;
    }

};
</code></pre><p>我把slow 和fast的起始就错开了一个结点，主要是怕后面while<br>会一开始误判相等而推出循环，但是这样证明fast从起点开始走2k+1， slow走k，因此结果是错的，所以必须fast slow同一起跑线，这样才公平嘛，人生也是如此。因此后面的break语句放到后面，或者while改成我很少写的<br>至少执行一遍的do while loop。<br>于是改写后的代码：</p>
<pre><code>class Solution {
<span class="keyword">public</span>:
    ListNode <span class="subst">*</span>detectCycle(ListNode <span class="subst">*</span>head) {
        <span class="keyword">if</span>(head<span class="subst">==</span><span class="built_in">NULL</span>) <span class="keyword">return</span> <span class="built_in">NULL</span>;
        ListNode<span class="subst">*</span> slow<span class="subst">=</span>head, <span class="subst">*</span>fast<span class="subst">=</span>head;
        <span class="keyword">do</span>
        {
            slow<span class="subst">=</span>slow<span class="subst">-&gt;</span>next;
            <span class="keyword">if</span>(fast<span class="subst">-&gt;</span>next<span class="subst">==</span><span class="built_in">NULL</span>) <span class="keyword">return</span> <span class="built_in">NULL</span>;
            fast<span class="subst">=</span>fast<span class="subst">-&gt;</span>next<span class="subst">-&gt;</span>next;
            <span class="keyword">if</span>(slow<span class="subst">==</span>fast) break;
        }<span class="keyword">while</span>(slow<span class="subst">!=</span><span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> fast <span class="subst">!=</span><span class="built_in">NULL</span>);

        <span class="keyword">if</span>(slow<span class="subst">==</span><span class="built_in">NULL</span> <span class="subst">||</span> fast <span class="subst">==</span><span class="built_in">NULL</span>) <span class="keyword">return</span> <span class="built_in">NULL</span>;
        ListNode<span class="subst">*</span> p<span class="subst">=</span>head;
        <span class="keyword">while</span>(p<span class="subst">!=</span>slow)
        {
            p<span class="subst">=</span>p<span class="subst">-&gt;</span>next;
            slow<span class="subst">=</span>slow<span class="subst">-&gt;</span>next;
        }
        <span class="keyword">return</span> p;
    }

};
</code></pre><p>我当时还在想如果整个就是一个循环链表 ，该返回什么？这个代码又会返回什么？ 以为测试样例不会出现，实际还真出现了，模拟一下，就是返回链表头结点作为环头，实际也是对的，链表从结点开始，第一个进入环的<br>就是头结点嘛<del>~</del></p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 19 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/18/ReOrderList/">ReOrderList</a></h1>
  

      <time datetime="2014-07-18T03:52:09.000Z"><a href="/2014/07/18/ReOrderList/">7月 18 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>再次遇到又爱又恨的linklist，这是必须卖过的坎，好像某软喜欢考Linklist相关的，包括CopyRandomLinklist，两个Linklist第一个交点等等。<br>这道是13年MS笔试的最后一题，几个月前做的时候，是纸上写，好像不是太难，1 2 3 4 -&gt; 1 4 2 3, 也即两项index和相同这样一个一个pair排列，立马要想到处理奇偶个结点的情况。<br>可以这么思考，index 从 1 2 3 4 map到 1 4 2 3, 将后面逆置，然后逐个插入到前面的linklist，思路不难，但是Linklist一定要写好，还是要把诸多情况考虑清楚的。</p>
<ol>
<li>遍历求长度 n</li>
<li>找到后半的第一个结点 n/2</li>
<li>后半reverse， n/2</li>
<li>后半插入到前半中 n/2</li>
</ol>
<p>第二步要考虑奇偶性，如果奇数需要多移动一个点，后半reverse使用三个指针，注意不丢next指针，插入也是这样。</p>
<p>附上代码：</p>
<pre><code> <span class="literal">void</span> reorderList(ListNode <span class="subst">*</span>head)
 {
     <span class="keyword">if</span>(head<span class="subst">==</span><span class="built_in">NULL</span> <span class="subst">||</span> head<span class="subst">-&gt;</span>next<span class="subst">==</span><span class="built_in">NULL</span> <span class="subst">||</span> head<span class="subst">-&gt;</span>next<span class="subst">-&gt;</span>next<span class="subst">==</span><span class="built_in">NULL</span>) <span class="keyword">return</span> ;

     ListNode<span class="subst">*</span> p<span class="subst">=</span>head;
     int l<span class="subst">=</span><span class="number">0</span>;
     <span class="keyword">while</span>(p) p<span class="subst">=</span>p<span class="subst">-&gt;</span>next,l<span class="subst">++</span>;<span class="comment">//imitate adhoc's code style</span>


     p<span class="subst">=</span>head;
     int i<span class="subst">=</span><span class="number">0</span>;
     ListNode<span class="subst">*</span> prev;
     <span class="keyword">while</span>(i<span class="subst">&lt;</span>l/<span class="number">2</span>) prev<span class="subst">=</span>p,p<span class="subst">=</span>p<span class="subst">-&gt;</span>next ,i<span class="subst">++</span>;<span class="comment">//imitate adhoc's code style</span>

     <span class="keyword">if</span>(l<span class="subst">%</span><span class="number">2</span><span class="subst">==</span><span class="number">1</span>) prev<span class="subst">=</span>p,p<span class="subst">=</span>p<span class="subst">-&gt;</span>next;<span class="comment">//odd, p to be (l-1)/2+1 node, prev to be center</span>


     ListNode<span class="subst">*</span> pnext, <span class="subst">*</span>pprev<span class="subst">=</span><span class="built_in">NULL</span>;
     <span class="keyword">while</span>(p<span class="subst">!=</span><span class="built_in">NULL</span>)<span class="comment">//reverse, pprev, p,pnext</span>
     {
         pnext<span class="subst">=</span>p<span class="subst">-&gt;</span>next;
         p<span class="subst">-&gt;</span>next<span class="subst">=</span>pprev;
         pprev<span class="subst">=</span>p;
         p<span class="subst">=</span>pnext;
     }

     prev<span class="subst">-&gt;</span>next<span class="subst">=</span><span class="built_in">NULL</span>;<span class="comment">//center link to reversed list node, avoid first part last node point to second part first node, which lead to loop linklist</span>
         <span class="comment">//pprev;</span>

     p<span class="subst">=</span>head;ListNode<span class="subst">*</span> q<span class="subst">=</span>pprev, <span class="subst">*</span>qnext;
     <span class="keyword">while</span>(q<span class="subst">!=</span><span class="built_in">NULL</span><span class="subst">&amp;&amp;</span>p<span class="subst">!=</span><span class="built_in">NULL</span>)
     {
         pnext<span class="subst">=</span>p<span class="subst">-&gt;</span>next;<span class="comment">//record p original next</span>
         qnext<span class="subst">=</span>q<span class="subst">-&gt;</span>next;

         p<span class="subst">-&gt;</span>next<span class="subst">=</span>q;
         q<span class="subst">-&gt;</span>next<span class="subst">=</span>pnext;

         p<span class="subst">=</span>pnext;
         q<span class="subst">=</span>qnext;
     }
 }
</code></pre><p>还好这次没有调试太久，遇到的问题有：</p>
<ol>
<li>Showlist测试忘记pnext导致死循环= =</li>
<li>代码敲错的问题，while里面三句逗号连接，模仿一博，结果i++前面敲成; 号了o(╯□╰)o reverse最后一个p=pnext 敲成p=p-&gt;next 这种问题最2了，浪费很多时间</li>
<li>最关键的一个bug，后面reverse之后，我之前是把他和前面链接成一个链表了，千万不要，因为后面p q往后指的时候，最后一次loop  p链最后一个指到q第一个了，于是链表循环了，除非里面加逻辑特殊处理，简洁的<br>办法就是两个链表断开，不要链接，因为后面链接的头结束reverse后是知道的(pprev)，不会丢失，只要不丢point就行了。</li>
</ol>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 18 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/17/Pointer-传递陷阱/">Pointer 传递陷阱</a></h1>
  

      <time datetime="2014-07-17T15:50:28.000Z"><a href="/2014/07/17/Pointer-传递陷阱/">7月 17 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>今天试了一道leetcode简单题，发现出现了一个很奇怪的错误，leetcode是按照层序的顺序来构建二叉树的，如果当前层都没有元素了，就不print，也就结束了，如果父亲没有 jing号(markdown语法都不知道怎么print jing号，他是强调的含义o(╯□╰)o)<br>也不print，总是有点怪怪的，可能和CreatBT这个函数有关，举个例子<br>   1<br>  / \<br> 2   3<br>    /<br>   4<br>    \<br>     5</p>
<p>构建BT的序列是 “{1,2,3,#,#,4,#,#,5}”， 如果二叉树显示的不好。详见<a href="https://oj.leetcode.com/problems/symmetric-tree/" target="_blank" rel="external">https://oj.leetcode.com/problems/symmetric-tree/</a></p>
<p>思路就是层序遍历，因为要区分层，所以采用了编程之美的经典算法(我没有看清题目说明，题目说了初始的next都是NULL，其实不需要区分层的，普通队列层序遍历就可以了，没有赋next的刚好都是应该赋NULL = = 就当又温习了一遍这个算法)，<br>vector模拟一个队列，利用current和last区分层，具体详见编程之美。题目说的constant空间 感觉好瞎啊，这个必须遍历BT，要么递归，要么用栈(先中后序)，要么队列(层序)，logn的空间我感觉都少不了的。。。。队列极端装了一层的点，<br>最大是最多结点的一层，2^(h-1)=n/2, h=下限(logn)+1 或者 上限(log(n+1)), 栈则是h，O(logn),递归也是栈一样，O(logn)</p>
<pre><code><span class="keyword">void</span> connect(TreeLinkNode *root)
{
    <span class="keyword">if</span>(root==NULL) <span class="keyword">return</span>;
    <span class="stl_container"><span class="built_in">vector</span>&lt;TreeLinkNode* &gt;</span> vec;
    vec.push_back(root);
    <span class="keyword">int</span> current=<span class="number">0</span>;
    TreeLinkNode* lastp;
    <span class="keyword">while</span>(current&lt;vec.size())
    {
        <span class="keyword">int</span> last=vec.size();<span class="comment">//the final one's next one</span>
        <span class="keyword">int</span> i=<span class="number">0</span>;
        <span class="keyword">while</span>(current&lt;last)
        {
            TreeLinkNode* p=vec.at(current);
            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)
                lastp-&gt;next=p;<span class="comment">//level first one, do not have last</span>

            lastp=p;
            <span class="built_in">cout</span>&lt;&lt;p-&gt;val;
            <span class="keyword">if</span>(p-&gt;left)
                vec.push_back(p-&gt;left);
            <span class="keyword">if</span>(p-&gt;right)
                vec.push_back(p-&gt;right);
            current++;
            i++;
        }
        lastp-&gt;next=NULL;<span class="comment">//level last next is null</span>
        <span class="built_in">cout</span>&lt;&lt;endl;
    }
}
</code></pre><p>后来发现第一个case死活过不了，而且感觉很奇怪，<br>Input:    {0}<br>Output:    0<br>Expected:    {0,#}<br>{0，#}是啥样的二叉树啊，如果是0 输出就是0啊，如果是有个左(右)孩子1，就是{0,1,#}({0,#,1})。。。不知道这个啥意思。。。导致现在都没过。。。<br>悲剧了，昨天收到邮件，一个回复说你的cout要删掉= = o(╯□╰)o 我才知道这个低级的错误，往往我们会忽视最简单的错误，而且写的这个可以处理各种二叉树，于是后面一道也过了。。。。</p>
<p>另外看到一个递归算法，中科大的一个童鞋写的，他也利用了初始值为NULL这个性质，将BT分为left right 两个BT，然后递归，两个子BT处理完了，还有一部分next没处理，也即两个BT 每一层，left最后一个指向right第一个，用一个用个<br>while一直探下去直到没有了为止</p>
<pre><code><span class="literal">void</span> connect(TreeLinkNode <span class="subst">*</span>root) {  
        <span class="keyword">if</span>( root <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">||</span> root<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">||</span> root<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span> )        <span class="comment">//{0}  有一个为空就不处理，其实不会出现left right一个空一个不空的，因为题目说了完全BT，而且即使有了，算法也会出问题。。。。</span>
        {  
           <span class="keyword">return</span>;  
        }  

        TreeLinkNode <span class="subst">*</span>p, <span class="subst">*</span>q;  
        p <span class="subst">=</span> root<span class="subst">-&gt;</span>left;  
        q <span class="subst">=</span> root<span class="subst">-&gt;</span>right;  
        p<span class="subst">-&gt;</span>next <span class="subst">=</span> q;  
        <span class="keyword">while</span>( p<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> q<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> )<span class="comment">//处理两个子BT之间的那些指针  </span>
        {  
            p <span class="subst">=</span> p<span class="subst">-&gt;</span>right;  
            q <span class="subst">=</span> q<span class="subst">-&gt;</span>left;  
            p<span class="subst">-&gt;</span>next <span class="subst">=</span> q;  
        }  

        connect( root<span class="subst">-&gt;</span>left );  
        connect( root<span class="subst">-&gt;</span>right );  
    }
</code></pre><p>看起来是elegant, 但是不能处理非完全二叉树，很有局限性，例如1左-&gt;2右-&gt;3， 2只有左子树4，无右子树，那么这个4是需要指向右孩子3子树的下一层第一个结点，这个指针指不到这个地方，这大概也是为啥这个题目分了两类吧。。。。<br><a href="https://wangxj.blog.ustc.edu.cn/?p=31" target="_blank" rel="external">https://wangxj.blog.ustc.edu.cn/?p=31</a></p>
<p>于是乎打算自己构建一颗二叉树来测，回想起当年CM老师教的(先序遍历)递归构建二叉树的算法(中序和后序递归建立BT可能会有问题，不太确定)，当时记得融神还不太熟悉这个算法，自己一个一个的手动insert左孩子或者右孩子。。。<br>于是乎我写一遍，一遍没好，调递归算法是最蛋疼的，你无法想象蛋会有多疼，一层一层的局部变量进去，我是先序或者某个序输出来看的，递归一定要记得有出口。后来终于发现了一个忽视的问题，指针传递其实也是值传递，也即传递这个指针变量的<br>值(地址值，指向一个变量存储的地址)，然后里面都是new出来的结点，于是穿进去之后，会是OS分配的一个新的某个地址，于是传入的参数就指不到这个地址了，于是树挂了。。。。我发现CM老师的课件也有这个问题好像当时还没人纠正。。。<br>这里应当也必须改为指针的引用传递，这样才可以保证传入的是指针变量，让这个指针变量申请一个新的堆空间，地址存在这个指针变量里。</p>
<p>修改后的先序遍历构建二叉树代码(-1 表示此处空)</p>
<pre><code><span class="title">void</span> <span class="type">Create</span>(<span class="type">TreeLinkNode</span>* &amp; root)
{
    int <span class="typedef"><span class="keyword">data</span>;</span>
    cin&gt;&gt;<span class="typedef"><span class="keyword">data</span>;</span>
    <span class="keyword">if</span>(<span class="typedef"><span class="keyword">data</span> == -1) root=<span class="type">NULL</span>;</span>
    <span class="keyword">else</span>
    {
        root=new <span class="type">TreeLinkNode</span>(<span class="typedef"><span class="keyword">data</span>);</span>
        <span class="type">Create</span>(root-&gt;left);
        <span class="type">Create</span>(root-&gt;right);
    }
}
</code></pre><p>这个递归其实也是有递归出口的，看起来大家都习惯了一上来必须是递归出口。如果输入-1，就不递归了，递归出口的定义就是这个分支不会继续递归下去，而是在有限步后就停止了，这也是某歌07年的笔试题里一个选择提到过的。<br>另外自己Copy代码的时候，经常会出问题，虽然fawks大神当时也建议我copy一些，提高效率，但是我总会忘记把改改的改完，例如先序Copy到中序，只有定义的函数名改了，里面递归调用没改，于是出现了一种全新的遍历顺序 #_#</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 17 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/16/bit-shift/">bit shift</a></h1>
  

      <time datetime="2014-07-16T04:03:20.000Z"><a href="/2014/07/16/bit-shift/">7月 16 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>位运算在原来学数逻时候是第一次系统接触，包括后面计组等课都陆续加以巩固，但是<br>实际cpp的时候却很少用，其实乘2 除2的操作到了底层都是位运算，左移右移可以极大的提高效率，据某度某科说提高60%<br>于是稍微回顾一下，用的数是int类型，4B，32bit，补码编码，-2^31-2^31-1, 据说某歌面试极其喜欢位运算。</p>
<p>正数右移1位，高位补0，等于整数/2操作，奇数丢失精度<br>负数右移1位，高位补1，等于整数/2操作，奇数丢失精度，但是-1右移等于-1，与-1/2=0结果不一致，好像奇负数都会丢失精度，好像右移和/2 还会差一。。。例如-5/2=-2,-5&gt;&gt;2=-3….</p>
<p>正数左移1位，低位补0，等于整数乘2操作，除符号位最高位为1(01000…000~01111…11111这2^30个数)会上溢出(&gt;=2^30，乘2后&gt;=2^31超出2^31-1的正数上界)导致结果出错<br>负数左移1位，低位补0，等于整数乘2操作，除去符号位，最高位为0时下溢出(从十进制数来看，-2*30左移乘2到-2^31刚好到负数下界，-(2^30+1)开始下溢，一直到-(2^30+2^30-1)=-(2^31-1) 外加特殊的<br>-2^31都会下溢。按照补码取反加1，也即10000…0001到101111…1111外加1000…00000这2^30-1+1=2^30个数会下溢，所以总结来看，就是如果负数的话，当数值部分最高位为0) 导致结果出错。</p>
<p>然后之前还有总结神奇的异或操作，求数组中唯一不出现偶数次的数，与可以判断更快的判断奇偶性(与0X0001与)等等。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 16 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/15/C++语法/">C++语法</a></h1>
  

      <time datetime="2014-07-15T07:34:12.000Z"><a href="/2014/07/15/C++语法/">7月 15 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>C++语法，还有一块，泛型编程，和继承都丢的差不多了，泛型编程好像没怎么用过。。。<br>据说好像金融方面，C++比较缺。。。</p>
<p>另外今天倒腾了下Code Block，及其蛋疼，终于体会到VS debug的强大了，VS是非常好的方便debug的IDE。。。</p>
<p>另外发现algorithm里有merge函数，包括sort，merge其实不一定要用容器的iterator作为参数，数组指针也是一样的，但是要记住，sort(first,last), 表示的排序范围是 [first, last),<br>这也和iterator的 end()表示容器最后一个元素的后一个元素相吻合。</p>
<p>sort(begin,end,compare())里的compare函数，</p>
<p>bool compare(cosnt T&amp; a,const T&amp;b)<br>{<br>    return a.data&lt;b.data;//a&lt;b, true, means ascending sort<br>}</p>
<p>ctsdio stdio.h 也即c<strong>*</strong>和  <strong>*</strong>.h 这两个lib的差别<br>后者现有，因为是里面的，后来有了C++，为了和他兼容，名字改为cstdio,内容几乎一样，只不过都在std::这个名字空间里，所以如果不加using namespace std, 会报错的，如果写C++代码建议用前者。<br><a href="http://bbs.csdn.net/topics/280066862" target="_blank" rel="external">http://bbs.csdn.net/topics/280066862</a></p>
<p>另外今天读了一下张一博大神的代码，先不说DP算法，主要是编码风格和习惯，里面有些东西是ACMer的习惯，定义很多宏和typedef 加快后面coding的速度，包括连vector的push_back都缩写为PB了，确实这样后面的coding可以更加集中于算法，<br>而不是某些库函数多敲几个字母。像这种三元组丢到vector里，我绝对会定义node，里面三个成员变量，他则是用了两次pair，外加宏定义直接变为MP3了。。。<br>define MP3(a,b,c) make_pair( a , make_pair(b,c) )<br>还有long long类型的数据类型由于多了字母，后面频繁出现，因此缩写为LL是很明智的做法，也是一个typedef<br>typedef long long       LL  ;<br>包括还有二维数组，我一般都不会考虑vector&lt;&gt; a[] 这样的vector数组，或者二维数组，或者vector &lt; vector<int> &gt;类似这种，可能leetcode看多了。。。不过这种vector 数组好处是每个长度可以变化，不过vector嵌套vector也可以，二维数组<br>用下标控制也可以的。</int></p>
<p>另外还有一个小细节，我注意到了，代码里很多while里面多个，然后一个;   我一直不知道while 或者if里面，只要,隔开 都算一句，所以相当于不用括号也可以多写几个statement，我之前好像一直都没怎么尝试过这种写法。</p>
<pre><code>if ( j == ZERO ) F[<span class="link_label">i</span>][<span class="link_reference">j</span>] = 1 , G[<span class="link_label">i</span>][<span class="link_reference">j</span>] = 0 ;
</code></pre>
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 15 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/15/MatrixSpiral/">MatrixSpiral</a></h1>
  

      <time datetime="2014-07-15T07:18:10.000Z"><a href="/2014/07/15/MatrixSpiral/">7月 15 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>顺时针打印，看起来是普通的程设题，不需要复杂的数据结构，但是还是会遇到很多问题，边界和循环很复杂。</p>
<p>我的思路就是一次打印一圈，然后往里循环，直到里面没有了为止，但是例如第一行是全部打印，还是留一个，因此有两种方案，我觉得留一个这种可以保持四条边统一，所以选择这种，<br>事实好像前者的答案代码会更加清晰o(╯□╰)o<br>然后先写最外层的4个循环，然后试图加个level参数k进4个loop，倒不难，写出了伪代码，</p>
<pre><code>k<span class="subst">=</span><span class="number">0</span>
<span class="keyword">while</span>()
{
    for(i<span class="subst">=</span><span class="number">1</span><span class="subst">+</span>k,j<span class="subst">=</span><span class="number">1</span><span class="subst">+</span>k<span class="subst">-&gt;</span>n<span class="subst">-</span><span class="number">1</span><span class="attribute">-k</span>) <span class="subst">++</span>

    for(j<span class="subst">=</span>n<span class="attribute">-k</span>,i<span class="subst">=</span><span class="number">1</span><span class="subst">+</span>k<span class="subst">-&gt;</span>m<span class="subst">-</span><span class="number">1</span><span class="attribute">-k</span>) <span class="subst">++</span>

    for(i<span class="subst">=</span>m<span class="attribute">-k</span>,j<span class="subst">=</span>n<span class="attribute">-k</span><span class="subst">-&gt;</span><span class="number">2</span><span class="subst">+</span>k) <span class="subst">--</span>

    for(j<span class="subst">=</span><span class="number">1</span><span class="subst">+</span>k,i<span class="subst">=</span>m<span class="attribute">-k</span><span class="subst">-&gt;</span><span class="number">2</span><span class="subst">+</span>k) <span class="subst">--</span>

    k<span class="subst">++</span>;
}
</code></pre><p>但是测试的时候，发现3_3 5_5这种 矩阵中心的打印不到，后来发现了一个问题，就是最后剩的一行，一列这种，于是总结下行的时候如果行数<br>等于上行的，也即上下重叠，说明下行没元素了，显然右列也没元素了。右列也是如此，于是加了一下逻辑判断的代码，并且最早也漏了循环结束条件，这里正好补上，以为对了= =</p>
<pre><code>k<span class="subst">=</span><span class="number">0</span>
<span class="keyword">while</span>()
{
    for(i<span class="subst">=</span><span class="number">1</span><span class="subst">+</span>k,j<span class="subst">=</span><span class="number">1</span><span class="subst">+</span>k<span class="subst">-&gt;</span>n<span class="subst">-</span><span class="number">1</span><span class="attribute">-k</span>) <span class="subst">++</span>

    for(j<span class="subst">=</span>n<span class="attribute">-k</span>,i<span class="subst">=</span><span class="number">1</span><span class="subst">+</span>k<span class="subst">-&gt;</span>m<span class="subst">-</span><span class="number">1</span><span class="attribute">-k</span>) <span class="subst">++</span>


    <span class="keyword">if</span>(m<span class="attribute">-k</span><span class="subst">==</span><span class="number">1</span><span class="subst">+</span>k)
    {
        spiralnum<span class="built_in">.</span>push_back(matrix<span class="built_in">.</span>at(<span class="number">1</span><span class="subst">+</span>k<span class="subst">-</span><span class="number">1</span>)<span class="built_in">.</span>at(n<span class="attribute">-k</span><span class="subst">-</span><span class="number">1</span>));
        break;
    }

    for(i<span class="subst">=</span>m<span class="attribute">-k</span>,j<span class="subst">=</span>n<span class="attribute">-k</span><span class="subst">-&gt;</span><span class="number">2</span><span class="subst">+</span>k) <span class="subst">--</span>


    <span class="keyword">if</span>(<span class="number">1</span><span class="subst">+</span>k<span class="subst">==</span>n<span class="attribute">-k</span>)
    {
        spiralnum<span class="built_in">.</span>push_back(matrix<span class="built_in">.</span>at(m<span class="attribute">-k</span><span class="subst">-</span><span class="number">1</span>)<span class="built_in">.</span>at(n<span class="attribute">-k</span><span class="subst">-</span><span class="number">1</span>));
        break;
    }

    for(j<span class="subst">=</span><span class="number">1</span><span class="subst">+</span>k,i<span class="subst">=</span>m<span class="attribute">-k</span><span class="subst">-&gt;</span><span class="number">2</span><span class="subst">+</span>k) <span class="subst">--</span>

    k<span class="subst">++</span>;
}
</code></pre><p>后来发现，4*4的死循环了，于是发现终止未必是下行和上行重合，或者右列和左列重合，也可能是下行是上行的前一行，或者右列是左列右一列，而且几个case总结出等的时候才会漏掉最后一个元素，<br>于是加上如下判断</p>
<pre><code>k<span class="subst">=</span><span class="number">0</span>
<span class="keyword">while</span>()
{
    for(i<span class="subst">=</span><span class="number">1</span><span class="subst">+</span>k,j<span class="subst">=</span><span class="number">1</span><span class="subst">+</span>k<span class="subst">-&gt;</span>n<span class="subst">-</span><span class="number">1</span><span class="attribute">-k</span>) <span class="subst">++</span>

    for(j<span class="subst">=</span>n<span class="attribute">-k</span>,i<span class="subst">=</span><span class="number">1</span><span class="subst">+</span>k<span class="subst">-&gt;</span>m<span class="subst">-</span><span class="number">1</span><span class="attribute">-k</span>) <span class="subst">++</span>

    <span class="keyword">if</span>(m<span class="attribute">-k</span><span class="subst">&lt;=</span><span class="number">1</span><span class="subst">+</span>k)
    {
        <span class="keyword">if</span>(m<span class="attribute">-k</span><span class="subst">==</span><span class="number">1</span><span class="subst">+</span>k)
            spiralnum<span class="built_in">.</span>push_back(matrix<span class="built_in">.</span>at(<span class="number">1</span><span class="subst">+</span>k<span class="subst">-</span><span class="number">1</span>)<span class="built_in">.</span>at(n<span class="attribute">-k</span><span class="subst">-</span><span class="number">1</span>));
        break;
    }

    for(i<span class="subst">=</span>m<span class="attribute">-k</span>,j<span class="subst">=</span>n<span class="attribute">-k</span><span class="subst">-&gt;</span><span class="number">2</span><span class="subst">+</span>k) <span class="subst">--</span>

    <span class="keyword">if</span>(<span class="number">1</span><span class="subst">+</span>k<span class="subst">&gt;=</span>n<span class="attribute">-k</span>)
    {
        <span class="keyword">if</span>(<span class="number">1</span><span class="subst">+</span>k<span class="subst">==</span>n<span class="attribute">-k</span>)
            spiralnum<span class="built_in">.</span>push_back(matrix<span class="built_in">.</span>at(m<span class="attribute">-k</span><span class="subst">-</span><span class="number">1</span>)<span class="built_in">.</span>at(n<span class="attribute">-k</span><span class="subst">-</span><span class="number">1</span>));
        break;
    }

    for(j<span class="subst">=</span><span class="number">1</span><span class="subst">+</span>k,i<span class="subst">=</span>m<span class="attribute">-k</span><span class="subst">-&gt;</span><span class="number">2</span><span class="subst">+</span>k) <span class="subst">--</span>

    k<span class="subst">++</span>;
}
</code></pre><p>提交leetcode 发现还是WA了= = 3_2的case多打印了一个数，后来发现，还可能是 上行的时候就没元素了，于是想再次改，发现怕前面的case又过不了，想到万能方法，直接每次for看是否vector是否装满了，<br>于是改的以下逻辑混乱的代码，AC了= =</p>
<pre><code><span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> spiralOrder(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> &amp;matrix) {
        <span class="keyword">int</span> m=matrix.size();<span class="comment">//row num</span>
        <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> spiralnum;
        <span class="keyword">if</span>(m&lt;=<span class="number">0</span>) <span class="keyword">return</span> spiralnum;
        <span class="keyword">int</span> n=matrix.at(<span class="number">0</span>).size();<span class="comment">//column num</span>
        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> spiralnum;

        <span class="keyword">int</span> k=<span class="number">0</span>;<span class="comment">//level id</span>

        <span class="keyword">int</span> i,j;
        <span class="keyword">while</span>(<span class="number">1</span>)
        {
            <span class="keyword">if</span>(spiralnum.size()==m*n) <span class="keyword">break</span>;
            <span class="keyword">for</span>(i=<span class="number">1</span>+k,j=<span class="number">1</span>+k;j&lt;=n-<span class="number">1</span>-k;j++)
                spiralnum.push_back(matrix.at(i-<span class="number">1</span>).at(j-<span class="number">1</span>));
            <span class="keyword">if</span>(spiralnum.size()==m*n) <span class="keyword">break</span>;
            <span class="keyword">for</span>(j=n-k,i=<span class="number">1</span>+k;i&lt;=m-<span class="number">1</span>-k;i++)
                spiralnum.push_back(matrix.at(i-<span class="number">1</span>).at(j-<span class="number">1</span>));
            <span class="keyword">if</span>(spiralnum.size()==m*n) <span class="keyword">break</span>;

            <span class="keyword">if</span>(m-k&lt;=<span class="number">1</span>+k)
            {
                <span class="keyword">if</span>(m-k==<span class="number">1</span>+k)
                    spiralnum.push_back(matrix.at(<span class="number">1</span>+k-<span class="number">1</span>).at(n-k-<span class="number">1</span>));
                <span class="keyword">break</span>;
            }
            <span class="keyword">for</span>(i=m-k,j=n-k;j&gt;=<span class="number">2</span>+k;j--)
                spiralnum.push_back(matrix.at(i-<span class="number">1</span>).at(j-<span class="number">1</span>));

            <span class="keyword">if</span>(<span class="number">1</span>+k&gt;=n-k)
            {
                <span class="keyword">if</span>(<span class="number">1</span>+k==n-k)
                    spiralnum.push_back(matrix.at(m-k-<span class="number">1</span>).at(n-k-<span class="number">1</span>));
                <span class="keyword">break</span>;
            }
            <span class="keyword">for</span>(j=<span class="number">1</span>+k,i=m-k;i&gt;=<span class="number">2</span>+k;i--)
                spiralnum.push_back(matrix.at(i-<span class="number">1</span>).at(j-<span class="number">1</span>));

            k++;
        }

        <span class="keyword">return</span> spiralnum;
}
</code></pre><p>后来看了剑指Offer，他是上行全部print，包括最后一个。而且要一开始想清楚，我想到后面，感觉好像就漏了几个case，再改可能就像一个project一样，看起来一个bug，一改，出来几千个o(╯□╰)o<br>逻辑已经混乱了，写这种行列的代码想起了我当年设计五子棋AI的VB代码，也是改了好多趟，最后还是有bug，只不过看起来还不错了。。。。。</p>
<p>另外发现其实自己有个不好的习惯，费了劲写完代码后，不太愿意用各种情况都包含的case去测试，这个是以后软件测试很重要的，要先想好，分为哪些测试用例。<br>最后，我看了下剑指Offer的思路 写了一个逻辑比较漂漂的MatrixSpiral算法。后面debug发现 自己右列的 for循环 rowend 写成了colend，结果测试用例 只有最后一个case差了一个元素，这简直是一个奇迹！！<br>我重新 总结了下算法思路，按照剑指Offer的，每一次(一行一列)不是 我之前想的都留一个元素，而是有的都print。按照书上的，每一次rowstart=colstart,即为start，<br>然后colend=col-1-start, rowend=row-1-start</p>
<p>于是四个循环有如下的伪代码，这里上行保证至少一行就够了，start&lt;=rowend, 右列也是保证一列可以了，不会print错，如果一列镁元素(例如一个元素被作为行print了)，后面for会控制好的。</p>
<p>if(start&lt;=rowend)//at least one row, maybe none number left<br>        {<br>            for(int j=start;j&lt;=colend;j++)//row: start col: start-&gt;colend, if col has num, start must be valid<br>                spiralnum.push_back(matrix.at(start).at(j));<br>        }</p>
<pre><code>    <span class="keyword">if</span>(start&lt;=colend)<span class="comment">//at least one row</span>
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;=rowend;i++)<span class="comment">//col: colend row:start+1-&gt;colend</span>
            spiralnum.push_back(<span class="keyword">matrix</span>.at(i).at(colend));
    }

    <span class="keyword">if</span>(start+<span class="number">1</span>&lt;=rowend)<span class="comment">//at least two rows</span>
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> j=colend-<span class="number">1</span>;j&gt;=start;j--)<span class="comment">//row: rowend col: colend-1-&gt;start</span>
            spiralnum.push_back(<span class="keyword">matrix</span>.at(rowend).at(j));
    }
    <span class="keyword">if</span>(start+<span class="number">1</span>&lt;=colend)<span class="comment">//at least two rows</span>
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i=rowend-<span class="number">1</span>;i&gt;=start+<span class="number">1</span>;i--)<span class="comment">//col: start row: rowend-1-&gt;start+1</span>
            spiralnum.push_back(<span class="keyword">matrix</span>.at(i).at(start));
    }
</code></pre><p>但是注意，下行要保证至少两行，否则会重复print上行print的，左列也是一样，start+1&lt;=rowend, 以及start+1&lt;=colend, 我习惯&lt;=，因为比较清晰范围，&lt;的话大脑还要再计算一次。<br>那么这是每一次的level 4个for print 怎么表示结束呢？ 我后来总结，如果一行 或者一列 都没有了，就结束了，故</p>
<pre><code>if(<span class="operator"><span class="keyword">start</span>&gt;colend || <span class="keyword">start</span>&gt; rowend)
    break;</span>
</code></pre><p>剑指Offer那个太扯了，谁会去这么想。。。。感觉这个比较接地气<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>附上逻辑很漂漂的代码
</pre></td></tr></table></figure>~</p>
<pre><code><span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> spiralOrder_Offer(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> &amp;matrix)
{
    <span class="keyword">int</span> row=matrix.size();<span class="comment">//row num</span>
    <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> spiralnum;
    <span class="keyword">if</span>(row&lt;=<span class="number">0</span>) <span class="keyword">return</span> spiralnum;
    <span class="keyword">int</span> col=matrix.at(<span class="number">0</span>).size();<span class="comment">//column num</span>
    <span class="keyword">if</span>(col&lt;=<span class="number">0</span>) <span class="keyword">return</span> spiralnum;

    <span class="keyword">int</span> start=<span class="number">0</span>;<span class="comment">//row start, and col start</span>

    <span class="comment">//bool PrintNum=false;</span>
    <span class="keyword">while</span>(<span class="number">1</span>)
    {
        <span class="keyword">int</span> colend=col-<span class="number">1</span>-start;
        <span class="keyword">int</span> rowend=row-<span class="number">1</span>-start;
        <span class="keyword">if</span>(start&gt;colend || start&gt; rowend)
            <span class="keyword">break</span>;

        <span class="keyword">if</span>(start&lt;=rowend)<span class="comment">//at least one row, maybe none number left</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;=colend;j++)<span class="comment">//row: start col: start-&gt;colend, if col has num, start must be valid </span>
                spiralnum.push_back(matrix.at(start).at(j));
        }

        <span class="keyword">if</span>(start&lt;=colend)<span class="comment">//at least one row</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;=rowend;i++)<span class="comment">//col: colend row:start+1-&gt;colend</span>
                spiralnum.push_back(matrix.at(i).at(colend));
        }

        <span class="keyword">if</span>(start+<span class="number">1</span>&lt;=rowend)<span class="comment">//at least two rows</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=colend-<span class="number">1</span>;j&gt;=start;j--)<span class="comment">//row: rowend col: colend-1-&gt;start</span>
                spiralnum.push_back(matrix.at(rowend).at(j));
        }
        <span class="keyword">if</span>(start+<span class="number">1</span>&lt;=colend)<span class="comment">//at least two rows</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=rowend-<span class="number">1</span>;i&gt;=start+<span class="number">1</span>;i--)<span class="comment">//col: start row: rowend-1-&gt;start+1</span>
                spiralnum.push_back(matrix.at(i).at(start));
        }

        start++;

    }
    <span class="keyword">return</span> spiralnum;
}
</code></pre><p>于是乎乘热打铁，把另一道相关的也做了，有点类似于反函数，之前是根据matrix 顺时针螺旋打印num，现在是已知num顺序，把他顺时针螺旋顺序赋给matrix，只有稍微改改就行了问题不大。</p>
<pre><code><span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> generateMatrix(<span class="keyword">int</span> n)
{
    <span class="comment">//int row=matrix.size();//row num</span>

    <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> matrix(n,n);
    <span class="comment">//vector&lt;int&gt; spiralnum;</span>
    <span class="comment">//if(row&lt;=0) return spiralnum;</span>
    <span class="comment">//int col=matrix.at(0).size();//column num</span>
    <span class="comment">//if(col&lt;=0) return spiralnum;</span>

    <span class="keyword">int</span> row=n,col=n;
    <span class="keyword">int</span> start=<span class="number">0</span>;<span class="comment">//row start, and col start</span>

    <span class="comment">//bool PrintNum=false;</span>
    <span class="keyword">int</span> k=<span class="number">1</span>;
    <span class="keyword">while</span>(<span class="number">1</span>)
    {
        <span class="keyword">int</span> colend=col-<span class="number">1</span>-start;
        <span class="keyword">int</span> rowend=row-<span class="number">1</span>-start;
        <span class="keyword">if</span>(start&gt;colend || start&gt; rowend)
            <span class="keyword">break</span>;

        <span class="keyword">if</span>(start&lt;=rowend)<span class="comment">//at least one row, maybe none number left</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;=colend;j++)<span class="comment">//row: start col: start-&gt;colend, if col has num, start must be valid </span>
            {
                matrix.at(start).at(j)=k;
                k++;

                <span class="comment">//spiralnum.push_back(matrix.at(start).at(j));</span>
            }
        }

        <span class="keyword">if</span>(start&lt;=colend)<span class="comment">//at least one row</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;=rowend;i++)<span class="comment">//col: colend row:start+1-&gt;colend</span>
            {
                matrix.at(i).at(colend)=k;
                k++;
                <span class="comment">//spiralnum.push_back(matrix.at(i).at(colend));</span>
            }
        }

        <span class="keyword">if</span>(start+<span class="number">1</span>&lt;=rowend)<span class="comment">//at least two rows</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=colend-<span class="number">1</span>;j&gt;=start;j--)<span class="comment">//row: rowend col: colend-1-&gt;start</span>
            {
                matrix.at(rowend).at(j)=k;
                k++;
                <span class="comment">//spiralnum.push_back(matrix.at(rowend).at(j));</span>
            }
        }
        <span class="keyword">if</span>(start+<span class="number">1</span>&lt;=colend)<span class="comment">//at least two rows</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=rowend-<span class="number">1</span>;i&gt;=start+<span class="number">1</span>;i--)<span class="comment">//col: start row: rowend-1-&gt;start+1</span>
            {
                matrix.at(i).at(start)=k;
                k++;
                <span class="comment">//spiralnum.push_back(matrix.at(i).at(start));</span>
            }
        }

        start++;

    }
    <span class="keyword">return</span> matrix;
}
</code></pre><p>这个问题倒不是太大，只要放个k进去，从1到n^2就可以了，但是我遇到了一个二维vector初始化的诡异问题，而且这个之前没有用过，好发现了VS与GCC, GCC3.2.3和4.4.7之间的微妙区别。<br>我先是这么弄的</p>
<pre><code><span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>&gt;</span> matrix(n,n);
</code></pre><p>VS10过了，提交，出现Compile error，提示两个&gt;&gt;离得太近，于是改成</p>
<pre><code><span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> matrix(n,n);
</code></pre><p>还是编译错误，还是这行的问题，于是拿windows下的gcc3.2.3测，也过了，有点不解。然后拿到Linux下的另一个版本GCC4.4.7，出现error了，果然GCC不同版本都会有问题，<br>这个也不是C++11新增的，于是查看帖子<br><a href="http://www.cnblogs.com/wei-li/archive/2012/06/08/2541576.html" target="_blank" rel="external">http://www.cnblogs.com/wei-li/archive/2012/06/08/2541576.html</a><br>发现要这么初始化二维vector</p>
<pre><code><span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> matrix(n,<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>(n));
</code></pre><p>也即二维vector只有装入n个 一维的vector的 构造函数参数列表，所以改了提交。</p>
<p>vector确实麻烦一些，第一他一开始是空的，而且不能访问越界，不像数组，很容易定义一个很大的数组。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 15 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/3/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/5/" class="alignright next">下一页</a>
  
</nav></div>
    </div>
    <div class="tabbar" onload="divideTabBar()">
	
      <div class="tabbaritem"><a class="next" href="/">Home</a></div>
    
      <div class="tabbaritem"><a class="next" href="/archives/">Archives</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a></div>
    
</div>


  </div>
</body>
</html>