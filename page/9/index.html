<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 9 页 | Richard</title>
  <meta name="author" content="Richard">
  
  <meta name="description" content="理查德爱闹">
  
  
  
  <meta property="og:site_name" content="Richard"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta property="og:image" content="undefined"/>
  
   <link rel="apple-touch-icon" href="/icon.png" />
   <link rel="shortcut icon" href="/favicon.png" >
   <link rel="alternate" href="http://xxx.xx/atom.xml" title="Richard" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
</head>


<body>
  <div id="content" class="inner">
    <aside id="sidebar" class="alignleft">
      <div class="navigationBar">
        <a href="/">Richard</a>
      </div>
    	
  <nav class="widget" id="menu">
	<ul>
    
      <li class="cell"><a class="next" href="/">Home</a><li>
    
      <li class="cell"><a class="next" href="/archives/">Archives</a><li>
    
      <li class="cell"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a><li>
    
      <li class="cell"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a><li>
    
      <li class="cell"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a><li>
    
    </ul>
</nav>

  <div class="widget weibo">
  <iframe width="100%" height="750" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=750&fansRow=2&ptype=1&speed=0&skin=6&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2689136623&verifier=c139aa37&dpc=1"></iframe>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/BT/">BT</a><small>1</small></li>
  
    <li><a href="/categories/Binary-Tree/">Binary Tree</a><small>1</small></li>
  
    <li><a href="/categories/BinaryTree/">BinaryTree</a><small>1</small></li>
  
    <li><a href="/categories/C/">C</a><small>1</small></li>
  
    <li><a href="/categories/C++/">C++</a><small>1</small></li>
  
    <li><a href="/categories/DFS/">DFS</a><small>1</small></li>
  
    <li><a href="/categories/DP/">DP</a><small>1</small></li>
  
    <li><a href="/categories/Linklist/">Linklist</a><small>1</small></li>
  
    <li><a href="/categories/Machine-Learning/">Machine Learning</a><small>1</small></li>
  
    <li><a href="/categories/Recursive/">Recursive</a><small>1</small></li>
  
    <li><a href="/categories/Union-find-set/">Union-find set</a><small>1</small></li>
  
    <li><a href="/categories/algorithm/">algorithm</a><small>11</small></li>
  
    <li><a href="/categories/app/">app</a><small>1</small></li>
  
    <li><a href="/categories/backtrack/">backtrack</a><small>2</small></li>
  
    <li><a href="/categories/bfs/">bfs</a><small>1</small></li>
  
    <li><a href="/categories/binary-search/">binary search</a><small>2</small></li>
  
    <li><a href="/categories/binary-tree/">binary tree</a><small>4</small></li>
  
    <li><a href="/categories/bit/">bit</a><small>1</small></li>
  
    <li><a href="/categories/bit-operation/">bit operation</a><small>2</small></li>
  
    <li><a href="/categories/blog/">blog</a><small>1</small></li>
  
    <li><a href="/categories/c-language/">c language</a><small>2</small></li>
  
    <li><a href="/categories/complex-condition-anaysis/">complex condition anaysis</a><small>1</small></li>
  
    <li><a href="/categories/cpp/">cpp</a><small>12</small></li>
  
    <li><a href="/categories/cpp-string/">cpp string</a><small>1</small></li>
  
    <li><a href="/categories/data-structure/">data structure</a><small>4</small></li>
  
    <li><a href="/categories/dfs/">dfs</a><small>1</small></li>
  
    <li><a href="/categories/dp/">dp</a><small>4</small></li>
  
    <li><a href="/categories/ds/">ds</a><small>2</small></li>
  
    <li><a href="/categories/easy-programming/">easy programming</a><small>1</small></li>
  
    <li><a href="/categories/experience/">experience</a><small>1</small></li>
  
    <li><a href="/categories/hash/">hash</a><small>1</small></li>
  
    <li><a href="/categories/heap/">heap</a><small>2</small></li>
  
    <li><a href="/categories/hexo-configuration/">hexo configuration</a><small>1</small></li>
  
    <li><a href="/categories/hihocode/">hihocode</a><small>1</small></li>
  
    <li><a href="/categories/integer/">integer</a><small>1</small></li>
  
    <li><a href="/categories/kmp/">kmp</a><small>1</small></li>
  
    <li><a href="/categories/latex/">latex</a><small>1</small></li>
  
    <li><a href="/categories/linklist/">linklist</a><small>9</small></li>
  
    <li><a href="/categories/logic/">logic</a><small>1</small></li>
  
    <li><a href="/categories/permutation/">permutation</a><small>2</small></li>
  
    <li><a href="/categories/programming/">programming</a><small>1</small></li>
  
    <li><a href="/categories/quick-and-right-coding/">quick and right coding</a><small>1</small></li>
  
    <li><a href="/categories/screen/">screen</a><small>1</small></li>
  
    <li><a href="/categories/sorting/">sorting</a><small>1</small></li>
  
    <li><a href="/categories/web/">web</a><small>2</small></li>
  
    <li><a href="/categories/数字规律/">数字规律</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/BST/" style="font-size: 12.00px;">BST</a><a href="/tags/BT/" style="font-size: 12.00px;">BT</a><a href="/tags/Backtrack/" style="font-size: 10.00px;">Backtrack</a><a href="/tags/Bayesian-graph-model/" style="font-size: 10.00px;">Bayesian graph model</a><a href="/tags/C/" style="font-size: 10.00px;">C</a><a href="/tags/C++/" style="font-size: 10.00px;">C++</a><a href="/tags/Combinations/" style="font-size: 10.00px;">Combinations</a><a href="/tags/DP/" style="font-size: 12.00px;">DP</a><a href="/tags/OO/" style="font-size: 10.00px;">OO</a><a href="/tags/Order/" style="font-size: 10.00px;">Order</a><a href="/tags/Permutation/" style="font-size: 10.00px;">Permutation</a><a href="/tags/PostOrder/" style="font-size: 10.00px;">PostOrder</a><a href="/tags/Union-find-set/" style="font-size: 10.00px;">Union-find set</a><a href="/tags/algorithm/" style="font-size: 20.00px;">algorithm</a><a href="/tags/app/" style="font-size: 10.00px;">app</a><a href="/tags/array/" style="font-size: 14.00px;">array</a><a href="/tags/back-n-node/" style="font-size: 10.00px;">back n node</a><a href="/tags/backtrack/" style="font-size: 10.00px;">backtrack</a><a href="/tags/bfs/" style="font-size: 10.00px;">bfs</a><a href="/tags/binary-search/" style="font-size: 14.00px;">binary search</a><a href="/tags/binary-search-tree/" style="font-size: 10.00px;">binary search tree</a><a href="/tags/bit/" style="font-size: 14.00px;">bit</a><a href="/tags/brute-force/" style="font-size: 12.00px;">brute force</a><a href="/tags/c/" style="font-size: 10.00px;">c</a><a href="/tags/c-language/" style="font-size: 12.00px;">c language</a><a href="/tags/category-analysis/" style="font-size: 10.00px;">category analysis</a><a href="/tags/char/" style="font-size: 10.00px;">char*</a><a href="/tags/cin/" style="font-size: 10.00px;">cin</a><a href="/tags/coding/" style="font-size: 10.00px;">coding</a><a href="/tags/combination/" style="font-size: 10.00px;">combination</a><a href="/tags/complement/" style="font-size: 10.00px;">complement</a><a href="/tags/complex/" style="font-size: 12.00px;">complex</a><a href="/tags/complex-condition-analysis/" style="font-size: 12.00px;">complex condition analysis</a><a href="/tags/condition-analysis/" style="font-size: 10.00px;">condition analysis</a><a href="/tags/configuire/" style="font-size: 10.00px;">configuire</a><a href="/tags/convert/" style="font-size: 10.00px;">convert</a><a href="/tags/cpp/" style="font-size: 18.00px;">cpp</a><a href="/tags/cpp，inheritance/" style="font-size: 10.00px;">cpp，inheritance</a><a href="/tags/cycle/" style="font-size: 10.00px;">cycle</a><a href="/tags/data-structure/" style="font-size: 16.00px;">data structure</a>
  </div>
</div>


    	<footer id="footer" class="inner"><div class="copyright">
  
  &copy; 2014 Richard
  
</div>



</footer>
    </aside>
    
    
    <div id="hidden-navigationBar" class="navigationBar">
      <a href="/">Richard</a>
    </div>
    <div id="main-col" class="alignright">
    <div id="wrapper">
      
  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/15/C++语法/">C++语法</a></h1>
  

      <time datetime="2014-07-15T07:34:12.000Z"><a href="/2014/07/15/C++语法/">7月 15 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>C++语法，还有一块，泛型编程，和继承都丢的差不多了，泛型编程好像没怎么用过。。。<br>据说好像金融方面，C++比较缺。。。</p>
<p>另外今天倒腾了下Code Block，及其蛋疼，终于体会到VS debug的强大了，VS是非常好的方便debug的IDE。。。</p>
<p>另外发现algorithm里有merge函数，包括sort，merge其实不一定要用容器的iterator作为参数，数组指针也是一样的，但是要记住，sort(first,last), 表示的排序范围是 [first, last),<br>这也和iterator的 end()表示容器最后一个元素的后一个元素相吻合。</p>
<p>sort(begin,end,compare())里的compare函数，</p>
<p>bool compare(cosnt T&amp; a,const T&amp;b)<br>{<br>    return a.data&lt;b.data;//a&lt;b, true, means ascending sort<br>}</p>
<p>ctsdio stdio.h 也即c<strong>*</strong>和  <strong>*</strong>.h 这两个lib的差别<br>后者现有，因为是里面的，后来有了C++，为了和他兼容，名字改为cstdio,内容几乎一样，只不过都在std::这个名字空间里，所以如果不加using namespace std, 会报错的，如果写C++代码建议用前者。<br><a href="http://bbs.csdn.net/topics/280066862" target="_blank" rel="external">http://bbs.csdn.net/topics/280066862</a></p>
<p>另外今天读了一下张一博大神的代码，先不说DP算法，主要是编码风格和习惯，里面有些东西是ACMer的习惯，定义很多宏和typedef 加快后面coding的速度，包括连vector的push_back都缩写为PB了，确实这样后面的coding可以更加集中于算法，<br>而不是某些库函数多敲几个字母。像这种三元组丢到vector里，我绝对会定义node，里面三个成员变量，他则是用了两次pair，外加宏定义直接变为MP3了。。。<br>define MP3(a,b,c) make_pair( a , make_pair(b,c) )<br>还有long long类型的数据类型由于多了字母，后面频繁出现，因此缩写为LL是很明智的做法，也是一个typedef<br>typedef long long       LL  ;<br>包括还有二维数组，我一般都不会考虑vector&lt;&gt; a[] 这样的vector数组，或者二维数组，或者vector &lt; vector<int> &gt;类似这种，可能leetcode看多了。。。不过这种vector 数组好处是每个长度可以变化，不过vector嵌套vector也可以，二维数组<br>用下标控制也可以的。</int></p>
<p>另外还有一个小细节，我注意到了，代码里很多while里面多个，然后一个;   我一直不知道while 或者if里面，只要,隔开 都算一句，所以相当于不用括号也可以多写几个statement，我之前好像一直都没怎么尝试过这种写法。</p>
<pre><code>if ( j == ZERO ) F[<span class="link_label">i</span>][<span class="link_reference">j</span>] = 1 , G[<span class="link_label">i</span>][<span class="link_reference">j</span>] = 0 ;
</code></pre><p>BSS段存放的是未初始化的全局和静态变量，数据段存放的是初始化后的全局和静态变量</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 15 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/15/MatrixSpiral/">MatrixSpiral</a></h1>
  

      <time datetime="2014-07-15T07:18:10.000Z"><a href="/2014/07/15/MatrixSpiral/">7月 15 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>顺时针打印，看起来是普通的程设题，不需要复杂的数据结构，但是还是会遇到很多问题，边界和循环很复杂。</p>
<p>我的思路就是一次打印一圈，然后往里循环，直到里面没有了为止，但是例如第一行是全部打印，还是留一个，因此有两种方案，我觉得留一个这种可以保持四条边统一，所以选择这种，<br>事实好像前者的答案代码会更加清晰o(╯□╰)o<br>然后先写最外层的4个循环，然后试图加个level参数k进4个loop，倒不难，写出了伪代码，</p>
<pre><code>k=<span class="number">0</span>
<span class="keyword">while</span>()
{
    <span class="keyword">for</span>(i=<span class="number">1</span>+k,j=<span class="number">1</span>+k-&gt;n-<span class="number">1</span>-k) ++

    <span class="keyword">for</span>(j=n-k,i=<span class="number">1</span>+k-&gt;m-<span class="number">1</span>-k) ++

    <span class="keyword">for</span>(i=m-k,j=n-k-&gt;<span class="number">2</span>+k) --

    <span class="keyword">for</span>(j=<span class="number">1</span>+k,i=m-k-&gt;<span class="number">2</span>+k) --

    k++;
}
</code></pre><p>但是测试的时候，发现3_3 5_5这种 矩阵中心的打印不到，后来发现了一个问题，就是最后剩的一行，一列这种，于是总结下行的时候如果行数<br>等于上行的，也即上下重叠，说明下行没元素了，显然右列也没元素了。右列也是如此，于是加了一下逻辑判断的代码，并且最早也漏了循环结束条件，这里正好补上，以为对了= =</p>
<pre><code>k=<span class="number">0</span>
<span class="keyword">while</span>()
{
    <span class="keyword">for</span>(i=<span class="number">1</span>+k,j=<span class="number">1</span>+k-&gt;n-<span class="number">1</span>-k) ++

    <span class="keyword">for</span>(j=n-k,i=<span class="number">1</span>+k-&gt;m-<span class="number">1</span>-k) ++


    <span class="keyword">if</span>(m-k==<span class="number">1</span>+k)
    {
        spiralnum.push_back(matrix.at(<span class="number">1</span>+k-<span class="number">1</span>).at(n-k-<span class="number">1</span>));
        <span class="keyword">break</span>;
    }

    <span class="keyword">for</span>(i=m-k,j=n-k-&gt;<span class="number">2</span>+k) --


    <span class="keyword">if</span>(<span class="number">1</span>+k==n-k)
    {
        spiralnum.push_back(matrix.at(m-k-<span class="number">1</span>).at(n-k-<span class="number">1</span>));
        <span class="keyword">break</span>;
    }

    <span class="keyword">for</span>(j=<span class="number">1</span>+k,i=m-k-&gt;<span class="number">2</span>+k) --

    k++;
}
</code></pre><p>后来发现，4*4的死循环了，于是发现终止未必是下行和上行重合，或者右列和左列重合，也可能是下行是上行的前一行，或者右列是左列右一列，而且几个case总结出等的时候才会漏掉最后一个元素，<br>于是加上如下判断</p>
<pre><code>k=<span class="number">0</span>
<span class="keyword">while</span>()
{
    <span class="keyword">for</span>(i=<span class="number">1</span>+k,j=<span class="number">1</span>+k-&gt;n-<span class="number">1</span>-k) ++

    <span class="keyword">for</span>(j=n-k,i=<span class="number">1</span>+k-&gt;m-<span class="number">1</span>-k) ++

    <span class="keyword">if</span>(m-k&lt;=<span class="number">1</span>+k)
    {
        <span class="keyword">if</span>(m-k==<span class="number">1</span>+k)
            spiralnum.push_back(matrix.at(<span class="number">1</span>+k-<span class="number">1</span>).at(n-k-<span class="number">1</span>));
        <span class="keyword">break</span>;
    }

    <span class="keyword">for</span>(i=m-k,j=n-k-&gt;<span class="number">2</span>+k) --

    <span class="keyword">if</span>(<span class="number">1</span>+k&gt;=n-k)
    {
        <span class="keyword">if</span>(<span class="number">1</span>+k==n-k)
            spiralnum.push_back(matrix.at(m-k-<span class="number">1</span>).at(n-k-<span class="number">1</span>));
        <span class="keyword">break</span>;
    }

    <span class="keyword">for</span>(j=<span class="number">1</span>+k,i=m-k-&gt;<span class="number">2</span>+k) --

    k++;
}
</code></pre><p>提交leetcode 发现还是WA了= = 3_2的case多打印了一个数，后来发现，还可能是 上行的时候就没元素了，于是想再次改，发现怕前面的case又过不了，想到万能方法，直接每次for看是否vector是否装满了，<br>于是改的以下逻辑混乱的代码，AC了= =</p>
<pre><code><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;<span class="keyword">matrix</span>) {
        <span class="keyword">int</span> m=<span class="keyword">matrix</span>.<span class="keyword">size</span>();<span class="comment">//row num</span>
        <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; spiralnum;
        <span class="keyword">if</span>(m&lt;=<span class="number">0</span>) <span class="keyword">return</span> spiralnum;
        <span class="keyword">int</span> n=<span class="keyword">matrix</span>.at(<span class="number">0</span>).<span class="keyword">size</span>();<span class="comment">//column num</span>
        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> spiralnum;

        <span class="keyword">int</span> k=<span class="number">0</span>;<span class="comment">//level id</span>

        <span class="keyword">int</span> i,j;
        <span class="keyword">while</span>(<span class="number">1</span>)
        {
            <span class="keyword">if</span>(spiralnum.<span class="keyword">size</span>()==m<span class="variable">*n</span>) <span class="keyword">break</span>;
            <span class="keyword">for</span>(i=<span class="number">1</span>+k,j=<span class="number">1</span>+k;j&lt;=n-<span class="number">1</span>-k;j++)
                spiralnum.push_back(<span class="keyword">matrix</span>.at(i-<span class="number">1</span>).at(j-<span class="number">1</span>));
            <span class="keyword">if</span>(spiralnum.<span class="keyword">size</span>()==m<span class="variable">*n</span>) <span class="keyword">break</span>;
            <span class="keyword">for</span>(j=n-k,i=<span class="number">1</span>+k;i&lt;=m-<span class="number">1</span>-k;i++)
                spiralnum.push_back(<span class="keyword">matrix</span>.at(i-<span class="number">1</span>).at(j-<span class="number">1</span>));
            <span class="keyword">if</span>(spiralnum.<span class="keyword">size</span>()==m<span class="variable">*n</span>) <span class="keyword">break</span>;

            <span class="keyword">if</span>(m-k&lt;=<span class="number">1</span>+k)
            {
                <span class="keyword">if</span>(m-k==<span class="number">1</span>+k)
                    spiralnum.push_back(<span class="keyword">matrix</span>.at(<span class="number">1</span>+k-<span class="number">1</span>).at(n-k-<span class="number">1</span>));
                <span class="keyword">break</span>;
            }
            <span class="keyword">for</span>(i=m-k,j=n-k;j&gt;=<span class="number">2</span>+k;j--)
                spiralnum.push_back(<span class="keyword">matrix</span>.at(i-<span class="number">1</span>).at(j-<span class="number">1</span>));

            <span class="keyword">if</span>(<span class="number">1</span>+k&gt;=n-k)
            {
                <span class="keyword">if</span>(<span class="number">1</span>+k==n-k)
                    spiralnum.push_back(<span class="keyword">matrix</span>.at(m-k-<span class="number">1</span>).at(n-k-<span class="number">1</span>));
                <span class="keyword">break</span>;
            }
            <span class="keyword">for</span>(j=<span class="number">1</span>+k,i=m-k;i&gt;=<span class="number">2</span>+k;i--)
                spiralnum.push_back(<span class="keyword">matrix</span>.at(i-<span class="number">1</span>).at(j-<span class="number">1</span>));

            k++;
        }

        <span class="keyword">return</span> spiralnum;
}
</code></pre><p>后来看了剑指Offer，他是上行全部print，包括最后一个。而且要一开始想清楚，我想到后面，感觉好像就漏了几个case，再改可能就像一个project一样，看起来一个bug，一改，出来几千个o(╯□╰)o<br>逻辑已经混乱了，写这种行列的代码想起了我当年设计五子棋AI的VB代码，也是改了好多趟，最后还是有bug，只不过看起来还不错了。。。。。</p>
<p>另外发现其实自己有个不好的习惯，费了劲写完代码后，不太愿意用各种情况都包含的case去测试，这个是以后软件测试很重要的，要先想好，分为哪些测试用例。<br>最后，我看了下剑指Offer的思路 写了一个逻辑比较漂漂的MatrixSpiral算法。后面debug发现 自己右列的 for循环 rowend 写成了colend，结果测试用例 只有最后一个case差了一个元素，这简直是一个奇迹！！<br>我重新 总结了下算法思路，按照剑指Offer的，每一次(一行一列)不是 我之前想的都留一个元素，而是有的都print。按照书上的，每一次rowstart=colstart,即为start，<br>然后colend=col-1-start, rowend=row-1-start</p>
<p>于是四个循环有如下的伪代码，这里上行保证至少一行就够了，start&lt;=rowend, 右列也是保证一列可以了，不会print错，如果一列镁元素(例如一个元素被作为行print了)，后面for会控制好的。</p>
<p>if(start&lt;=rowend)//at least one row, maybe none number left<br>        {<br>            for(int j=start;j&lt;=colend;j++)//row: start col: start-&gt;colend, if col has num, start must be valid<br>                spiralnum.push_back(matrix.at(start).at(j));<br>        }</p>
<pre><code>    <span class="keyword">if</span>(start&lt;=colend)<span class="comment">//at least one row</span>
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;=rowend;i++)<span class="comment">//col: colend row:start+1-&gt;colend</span>
            spiralnum.push_back(<span class="keyword">matrix</span>.at(i).at(colend));
    }

    <span class="keyword">if</span>(start+<span class="number">1</span>&lt;=rowend)<span class="comment">//at least two rows</span>
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> j=colend-<span class="number">1</span>;j&gt;=start;j--)<span class="comment">//row: rowend col: colend-1-&gt;start</span>
            spiralnum.push_back(<span class="keyword">matrix</span>.at(rowend).at(j));
    }
    <span class="keyword">if</span>(start+<span class="number">1</span>&lt;=colend)<span class="comment">//at least two rows</span>
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i=rowend-<span class="number">1</span>;i&gt;=start+<span class="number">1</span>;i--)<span class="comment">//col: start row: rowend-1-&gt;start+1</span>
            spiralnum.push_back(<span class="keyword">matrix</span>.at(i).at(start));
    }
</code></pre><p>但是注意，下行要保证至少两行，否则会重复print上行print的，左列也是一样，start+1&lt;=rowend, 以及start+1&lt;=colend, 我习惯&lt;=，因为比较清晰范围，&lt;的话大脑还要再计算一次。<br>那么这是每一次的level 4个for print 怎么表示结束呢？ 我后来总结，如果一行 或者一列 都没有了，就结束了，故</p>
<pre><code>if(<span class="operator"><span class="keyword">start</span>&gt;colend || <span class="keyword">start</span>&gt; rowend)
    break;</span>
</code></pre><p>剑指Offer那个太扯了，谁会去这么想。。。。感觉这个比较接地气</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">附上逻辑很漂漂的代码</div></pre></td></tr></table></figure>

<p>~</p>
<pre><code><span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder_Offer(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;<span class="keyword">matrix</span>)
{
    <span class="keyword">int</span> row=<span class="keyword">matrix</span>.<span class="keyword">size</span>();<span class="comment">//row num</span>
    <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; spiralnum;
    <span class="keyword">if</span>(row&lt;=<span class="number">0</span>) <span class="keyword">return</span> spiralnum;
    <span class="keyword">int</span> col=<span class="keyword">matrix</span>.at(<span class="number">0</span>).<span class="keyword">size</span>();<span class="comment">//column num</span>
    <span class="keyword">if</span>(col&lt;=<span class="number">0</span>) <span class="keyword">return</span> spiralnum;

    <span class="keyword">int</span> start=<span class="number">0</span>;<span class="comment">//row start, and col start</span>

    <span class="comment">//bool PrintNum=false;</span>
    <span class="keyword">while</span>(<span class="number">1</span>)
    {
        <span class="keyword">int</span> colend=col-<span class="number">1</span>-start;
        <span class="keyword">int</span> rowend=row-<span class="number">1</span>-start;
        <span class="keyword">if</span>(start&gt;colend || start&gt; rowend)
            <span class="keyword">break</span>;

        <span class="keyword">if</span>(start&lt;=rowend)<span class="comment">//at least one row, maybe none number left</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;=colend;j++)<span class="comment">//row: start col: start-&gt;colend, if col has num, start must be valid </span>
                spiralnum.push_back(<span class="keyword">matrix</span>.at(start).at(j));
        }

        <span class="keyword">if</span>(start&lt;=colend)<span class="comment">//at least one row</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;=rowend;i++)<span class="comment">//col: colend row:start+1-&gt;colend</span>
                spiralnum.push_back(<span class="keyword">matrix</span>.at(i).at(colend));
        }

        <span class="keyword">if</span>(start+<span class="number">1</span>&lt;=rowend)<span class="comment">//at least two rows</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=colend-<span class="number">1</span>;j&gt;=start;j--)<span class="comment">//row: rowend col: colend-1-&gt;start</span>
                spiralnum.push_back(<span class="keyword">matrix</span>.at(rowend).at(j));
        }
        <span class="keyword">if</span>(start+<span class="number">1</span>&lt;=colend)<span class="comment">//at least two rows</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=rowend-<span class="number">1</span>;i&gt;=start+<span class="number">1</span>;i--)<span class="comment">//col: start row: rowend-1-&gt;start+1</span>
                spiralnum.push_back(<span class="keyword">matrix</span>.at(i).at(start));
        }

        start++;

    }
    <span class="keyword">return</span> spiralnum;
}
</code></pre><p>于是乎乘热打铁，把另一道相关的也做了，有点类似于反函数，之前是根据matrix 顺时针螺旋打印num，现在是已知num顺序，把他顺时针螺旋顺序赋给matrix，只有稍微改改就行了问题不大。</p>
<pre><code><span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; generateMatrix(<span class="keyword">int</span> n)
{
    <span class="comment">//int row=matrix.size();//row num</span>

    <span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="keyword">matrix</span>(n,n);
    <span class="comment">//vector&lt;int&gt; spiralnum;</span>
    <span class="comment">//if(row&lt;=0) return spiralnum;</span>
    <span class="comment">//int col=matrix.at(0).size();//column num</span>
    <span class="comment">//if(col&lt;=0) return spiralnum;</span>

    <span class="keyword">int</span> row=n,col=n;
    <span class="keyword">int</span> start=<span class="number">0</span>;<span class="comment">//row start, and col start</span>

    <span class="comment">//bool PrintNum=false;</span>
    <span class="keyword">int</span> k=<span class="number">1</span>;
    <span class="keyword">while</span>(<span class="number">1</span>)
    {
        <span class="keyword">int</span> colend=col-<span class="number">1</span>-start;
        <span class="keyword">int</span> rowend=row-<span class="number">1</span>-start;
        <span class="keyword">if</span>(start&gt;colend || start&gt; rowend)
            <span class="keyword">break</span>;

        <span class="keyword">if</span>(start&lt;=rowend)<span class="comment">//at least one row, maybe none number left</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;=colend;j++)<span class="comment">//row: start col: start-&gt;colend, if col has num, start must be valid </span>
            {
                <span class="keyword">matrix</span>.at(start).at(j)=k;
                k++;

                <span class="comment">//spiralnum.push_back(matrix.at(start).at(j));</span>
            }
        }

        <span class="keyword">if</span>(start&lt;=colend)<span class="comment">//at least one row</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;=rowend;i++)<span class="comment">//col: colend row:start+1-&gt;colend</span>
            {
                <span class="keyword">matrix</span>.at(i).at(colend)=k;
                k++;
                <span class="comment">//spiralnum.push_back(matrix.at(i).at(colend));</span>
            }
        }

        <span class="keyword">if</span>(start+<span class="number">1</span>&lt;=rowend)<span class="comment">//at least two rows</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=colend-<span class="number">1</span>;j&gt;=start;j--)<span class="comment">//row: rowend col: colend-1-&gt;start</span>
            {
                <span class="keyword">matrix</span>.at(rowend).at(j)=k;
                k++;
                <span class="comment">//spiralnum.push_back(matrix.at(rowend).at(j));</span>
            }
        }
        <span class="keyword">if</span>(start+<span class="number">1</span>&lt;=colend)<span class="comment">//at least two rows</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=rowend-<span class="number">1</span>;i&gt;=start+<span class="number">1</span>;i--)<span class="comment">//col: start row: rowend-1-&gt;start+1</span>
            {
                <span class="keyword">matrix</span>.at(i).at(start)=k;
                k++;
                <span class="comment">//spiralnum.push_back(matrix.at(i).at(start));</span>
            }
        }

        start++;

    }
    <span class="keyword">return</span> <span class="keyword">matrix</span>;
}
</code></pre><p>这个问题倒不是太大，只要放个k进去，从1到n^2就可以了，但是我遇到了一个二维vector初始化的诡异问题，而且这个之前没有用过，好发现了VS与GCC, GCC3.2.3和4.4.7之间的微妙区别。<br>我先是这么弄的</p>
<pre><code><span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>&gt;</span> matrix(n,n);
</code></pre><p>VS10过了，提交，出现Compile error，提示两个&gt;&gt;离得太近，于是改成</p>
<pre><code><span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> matrix(n,n);
</code></pre><p>还是编译错误，还是这行的问题，于是拿windows下的gcc3.2.3测，也过了，有点不解。然后拿到Linux下的另一个版本GCC4.4.7，出现error了，果然GCC不同版本都会有问题，<br>这个也不是C++11新增的，于是查看帖子<br><a href="http://www.cnblogs.com/wei-li/archive/2012/06/08/2541576.html" target="_blank" rel="external">http://www.cnblogs.com/wei-li/archive/2012/06/08/2541576.html</a><br>发现要这么初始化二维vector</p>
<pre><code><span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> matrix(n,<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>(n));
</code></pre><p>也即二维vector只有装入n个 一维的vector的 构造函数参数列表，所以改了提交。</p>
<p>vector确实麻烦一些，第一他一开始是空的，而且不能访问越界，不像数组，很容易定义一个很大的数组。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 15 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/14/longest-consecutive-sequences/">longest consecutive sequences</a></h1>
  

      <time datetime="2014-07-14T15:13:15.000Z"><a href="/2014/07/14/longest-consecutive-sequences/">7月 14 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>看到July群里有人提问，大家讨论很激烈。</p>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br>Given [100, 4, 200, 1, 3, 2],<br>The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<p>一开始乍看这题，首先反应就是sort然后遍历就可以了，但是时间复杂度不行。线性的算法貌似都没有思路，后来看到有人说radix sort，我一直都没反应过来，看了那些sort，居然<br>把这茬忘记了，于是回顾DS的相关课件，发现有个算法复杂度没弄明白，PPT写O(d(n+rd)) 但是我感觉就是O(d(n+r)), 其中d是最大数的位数，r是基数(10), 每一躺就是遍历链表，把他丢到当前位数合适的桶里，<br>然后把链表实现的队列链接起来，n+r感觉是，不知道为啥。。。</p>
<p>后来又有一路hash流，感觉hash一般都不会是最好的算法，因为一个hash函数的非普遍适用性使得一次查找O(1)值得怀疑，但是已经没有其他更好的方案了o(╯□╰)o<br>于是想到先建立hash，然后逐个看相邻的是否在里面，也是因为有频繁的查找，才想到hash，但是发现直接用 <int count="">这样的map可能会出现漏的情况，例如 0 1 2 -1，到了-1可能只能合并0，其实最后更新的(0 1 2)长为<br>3的序列更新在1 2那里，没有传递到0那里，导致出错，而且可能会出现重复合并等等，所以加一个left right 逻辑变量，判断是否已经合并过了，于是可以设计代码了</int></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;math.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;time.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;limits.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;iomanip&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;unordered_map&gt;</span>

<span class="preprocessor">#<span class="keyword">define</span> Min(a,b) (((a) &lt; (b)) ? (a) : (b))</span>
<span class="preprocessor">#<span class="keyword">define</span> Max(a,b) (((a) &gt; (b)) ? (a) : (b))</span>
<span class="preprocessor">#<span class="keyword">define</span> read freopen("in.txt","r",stdin)  </span>
<span class="preprocessor">#<span class="keyword">define</span> write freopen("out.txt","w",stdout)</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">struct</span> length
{
    <span class="keyword">int</span> count;
    <span class="keyword">bool</span> left;
    <span class="keyword">bool</span> right;
};
<span class="keyword">int</span> longestConsecutive(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &amp;num) {
        <span class="stl_container"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,length&gt;</span> <span class="built_in">map</span>;
        length l;
        l.count=<span class="number">1</span>;l.left=<span class="keyword">false</span>;l.right=<span class="keyword">false</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.size();i++)
        {
            <span class="keyword">if</span>(<span class="built_in">map</span>.find(num.at(i))==<span class="built_in">map</span>.end())
                <span class="built_in">map</span>[num.at(i)]=l;
        }
        <span class="stl_container"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,length&gt;</span>::iterator it;
        <span class="keyword">for</span>(it=<span class="built_in">map</span>.begin();it!=<span class="built_in">map</span>.end();it++)
        {
            <span class="keyword">if</span>(it-&gt;second.left==<span class="keyword">false</span>)
            {
                <span class="keyword">if</span>(<span class="built_in">map</span>.find(it-&gt;first-<span class="number">1</span>)!=<span class="built_in">map</span>.end() &amp;&amp; <span class="built_in">map</span>[it-&gt;first-<span class="number">1</span>].right==<span class="keyword">false</span>)
                {
                    <span class="keyword">int</span> sumlength=<span class="built_in">map</span>[it-&gt;first].count+<span class="built_in">map</span>[it-&gt;first-<span class="number">1</span>].count;
                    <span class="built_in">map</span>[it-&gt;first].count=sumlength;
                    <span class="built_in">map</span>[it-&gt;first-<span class="number">1</span>].count=sumlength;
                    it-&gt;second.left=<span class="keyword">true</span>;
                    <span class="built_in">map</span>[it-&gt;first-<span class="number">1</span>].right=<span class="keyword">true</span>;
                }
            }
            <span class="keyword">if</span>(it-&gt;second.right==<span class="keyword">false</span>)
            {
                <span class="keyword">if</span>(<span class="built_in">map</span>.find(it-&gt;first+<span class="number">1</span>)!=<span class="built_in">map</span>.end() &amp;&amp; <span class="built_in">map</span>[it-&gt;first+<span class="number">1</span>].left==<span class="keyword">false</span>)
                {
                    <span class="keyword">int</span> sumlength=<span class="built_in">map</span>[it-&gt;first].count+<span class="built_in">map</span>[it-&gt;first+<span class="number">1</span>].count;
                    <span class="built_in">map</span>[it-&gt;first].count=sumlength;
                    <span class="built_in">map</span>[it-&gt;first+<span class="number">1</span>].count=sumlength;
                    it-&gt;second.right=<span class="keyword">true</span>;
                    <span class="built_in">map</span>[it-&gt;first+<span class="number">1</span>].left=<span class="keyword">true</span>;
                }
            }
        }

        it=<span class="built_in">map</span>.begin();
        <span class="keyword">int</span> max=it-&gt;second.count;
        <span class="keyword">for</span>(it=<span class="built_in">map</span>.begin();it!=<span class="built_in">map</span>.end();it++)
        {
            <span class="keyword">if</span>(max&lt;it-&gt;second.count)
                max=it-&gt;second.count;
        }
        <span class="keyword">return</span> max;
}
<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> a[]={<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>};
    <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> num(&amp;a[<span class="number">0</span>],&amp;a[<span class="number">5</span>]);
    <span class="built_in">cout</span>&lt;&lt;longestConsecutive(num)&lt;&lt;endl;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>但是发现leetcode跑出来居然和local的不一样，我也没用静态变量啊，还有全局变量，而且之前直接贴本地完整代码，还被管理员封了贴o(╯□╰)o<br>目前还不知道为何。。。 (问题找到了，leetcode的g++ 编译选项没有 std=c++0x, 不支持C++11，unordered_map是C++11里的，我用的VS其实是支持了C++11，而我也没办法改后台编译的参数选项，<br>于是出现了不可预料的结果，于是按照管理员说法改成map，居然还过了，这个已经不是线性复杂度，是O(nlon)了，leetcode看来时间复杂度不像ACM那么严: ) 而且管理员说还有更elegant的算法，不需要用到<br>类似hash这种复杂的数据结构，我目前想到的只有radix sort，这个也是线性的，输入是int，最多丢12次桶，所以还是线性复杂度) </p>
<p>另外还有些C++知识总结：</p>
<ol>
<li><p>C++ class构造函数用冒号初始化的时候顺序是成员变量定义的顺序，和初始化顺序无关，所以会有些陷阱题<br>class A<br>{<br> int n1;<br> int n2;<br> A(): n2(1) n1(n2+1)<br>}<br>这里面其实n1先初始化，但n2未初始化，是野值，于是n1也是野值，n2=1</p>
</li>
<li><p>sizeof作用于一个内部空的结构体返回多少字节</p>
</li>
</ol>
<p>答案是1 不是0， 试想下，如果是0，这个结构体不占空间，那我定义的一个这个对象存在那里，岂不是不存在了？怎么获取他的地址，已经如何判断两个对象哪个是哪个？<br>虽然这个确实不是常规知识，但是通过逻辑思考，后面如何使用这些变量，可以推测出不为0，VS中是认为1的。</p>
<p>另外还有之前和高富帅想leetcode 通过率最低的一道题，判断二维平面 共线最多的点，想到用hash提高查找效率，但是一条直线<br>是两个参数决定的，不可能降为1个，于是想有没有两个自变量的hash函数？ 一般都是一个变量，作为key来hash的？</p>
<p>还看到剑指Offer有道题目是说，数组的数合并为一个数的最小数是多少?<br>这个感觉思路就是先看第一位，如果各不相同，就直接sort第一位就解决了，否则，对于第一位有重复的 再看，如果两两个重复，就继续看两个数的下一位，一直下去，如果多个数的话，就有点麻烦了，<br>排列情况比较多，还要看他的各位和其他数位数的关系，有点乱。。。感觉目前有的思路是这样。。。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 14 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/14/sizeof-summary/">sizeof summary</a></h1>
  

      <time datetime="2014-07-14T10:20:16.000Z"><a href="/2014/07/14/sizeof-summary/">7月 14 2014</a></time>
      
  </header>
    <div class="entry">
      
        
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 14 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/14/GetOneTimes/">GetOneTimes</a></h1>
  

      <time datetime="2014-07-14T07:10:08.000Z"><a href="/2014/07/14/GetOneTimes/">7月 14 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>计算从1到n的数字中1出现的次数<br>这道题目一看，估计是找规律，总结一套规则出来。首先暴力方法，遍历1-n，计算每个数所有1的个数，我当时居然写的一个方法更加搓，我都忘了辗转想除法，<br>以为只能从高位开始，然后先计算unsigned int最多有12位，然后从10^11此方开始，除，取结果，然后减去高位数，这样直到个位。。。</p>
<pre><code><span class="keyword">int</span> EnumGetOneNum(<span class="keyword">int</span> n)
{
    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;

    <span class="keyword">int</span> onesum=<span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)
    {
        <span class="keyword">int</span> maxten=<span class="number">11</span>;<span class="comment">//signed int or unsigned int, max 12 digit</span>
        <span class="keyword">while</span>(i&gt;<span class="number">0</span>)
        {
            <span class="keyword">int</span> digit=i/<span class="built_in">pow</span>(<span class="number">10.0</span>,maxten);
            <span class="keyword">if</span>(digit==<span class="number">1</span>)
                onesum++;
            i-=digit*<span class="built_in">pow</span>(<span class="number">10.0</span>,maxten);
            maxten--;
        }
    }
    <span class="keyword">return</span> onesum;
}
</code></pre><p>后来发现自己连基本的辗转相除法都忘了 o(╯□╰)o 可以从各位先取余，再除，可以直接从个位开始逐个获得digit，这个比从高位好，因为你不知道位数是多少，我傻乎乎的从12位开始。。<br>附上这个代码</p>
<pre><code><span class="keyword">int</span> LowToHighDigit_EnumGetOneNum(<span class="keyword">int</span> n)
{
    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;

    <span class="keyword">int</span> onesum=<span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)
    {
        <span class="keyword">int</span> maxten=<span class="number">11</span>;<span class="comment">//signed int or unsigned int, max 12 digit</span>
        <span class="keyword">while</span>(i&gt;<span class="number">0</span>)
        {
            <span class="keyword">int</span> digit=i<span class="variable">%10</span>;
            <span class="keyword">if</span>(digit==<span class="number">1</span>)
                onesum++;
            i=i/<span class="number">10</span>;
            <span class="comment">//int digit=i/pow(10.0,maxten);</span>
            <span class="comment">//if(digit==1)</span>
            <span class="comment">//    onesum++;</span>
            <span class="comment">//i-=digit*pow(10.0,maxten);</span>
            <span class="comment">//maxten--;</span>
        }
    }
    <span class="keyword">return</span> onesum;
}
</code></pre><p>接下来才是重头戏，不愧我想了那么久。。<br>我开始总结，按照位数来统计，先算个位的1，再十位 百位。。。先看10位的，10-19有10次，110-119有10次，感觉就是除掉前10个，后面差为100的等差，然后里面前面连续10个，后面都没有，<br>大致计算公式是<br>n-10=100<em>x+y (n&gt;=10)<br>sum=10</em>x+10(y&gt;=10)<br>    10*x+y+1(y&lt;10)</p>
<p>于是百位也是类似<br>n-100=1000<em>x+y (n&gt;=100)<br>sum=100</em>x+100(y&gt;=100)<br>    100*x+y+1(y&lt;100)</p>
<p>一开始还以为个位就是1 ，sum初值为1，然后从十位开始，后来测试的时候是错的，然后个位也是按照上面的，于是就有如下的代码 o(╯□╰)o</p>
<pre><code><span class="keyword">int</span> GetOneNum (<span class="keyword">int</span> n)
{
    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> <span class="keyword">sum</span>=<span class="number">0</span>;
    <span class="keyword">int</span> ten=<span class="number">1</span>;<span class="comment">//10 base</span>
    <span class="keyword">while</span>(n&gt;=ten)
    {
        <span class="keyword">int</span> x=(n-ten)/(<span class="number">10</span>*ten);
        <span class="keyword">int</span> y=(n-ten)%(<span class="number">10</span>*ten);
        <span class="keyword">sum</span>+=x*ten;
        <span class="keyword">if</span>(y&gt;=ten)
            <span class="keyword">sum</span>+=ten;
        <span class="keyword">else</span>
            <span class="keyword">sum</span>+=(y+<span class="number">1</span>);
        ten*=<span class="number">10</span>;
    }
    <span class="keyword">return</span> <span class="keyword">sum</span>;
}
</code></pre><p>剑指Offer上的是一个递归算法，我也没有往这里想，大致是把最高位和其余数字分开来处理，低的n-1位数字递归算，细节没看，大致思路这样。。。</p>
<p>今天看到CJ的微博，才发现这道题目BOP上也有，于是重新想一遍，发现居然最后归纳式子的时候有点问题一直没搞定。。。。有点慌了，解过的题目现在再次解不出了，可能是因为上次灵光一现的因素太多，没有形成general的思维<br>套路。最主要是自己想发现不知道把余数 分成两种情况考虑，虽然把十位数1的个数和N关系的函数曲线都画出来，却不知道怎么写出函数关系式，其实还是按照之前(n-10)/100式子来，最好写出n-10=100<em>x+y, 那么如果到了20~109其实和19是一样的，<br>所以把这100个数用单独的常数来处理，对于10~19 则用一个线性函数处理，当 n&gt;=20时，即(n-10)%100=y&gt;=10, sum=10</em>x+10,否则，n&lt;=19, 即(n-10)%100=y&lt;=9, sum=10*x+y+1分成这两种处理。十位的处理好了，其他类推就可以了。 </p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 14 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/14/max-num-sum/">max num sum</a></h1>
  

      <time datetime="2014-07-14T03:44:46.000Z"><a href="/2014/07/14/max-num-sum/">7月 14 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>最大字段和问题，很经典，一般经典的都是去理解性记忆，但是对于递推方程一直有点疑惑，为什么只有这两种情况？</p>
<p>dp[j]=max{dp[j-1]+a[j],a[j]}</p>
<p>各种书都说这个意义在于如果前面最优解和为负直接丢弃，这是知道公式之后才可以推导的呀。。。还记得伟哥当时激动地直接课前和沈老师说起自己想到的这个线性算法</p>
<p>我一直在想，dp[j]只有这两种可能么？ 不可能是a[j]加上前面一部分，但是不是dp[j-1]的解？</p>
<p>现在证明，不可能！已知dp[j-1]是以a[j-1]为结尾的最优解，若存在dp’[j-1]+a[j]为dp[j]，则dp’[j-1]+a[j]&gt;dp[j-1]+a[j], dp’[j-1]&gt;dp[j-1], 则子问题有更优解，这与已知矛盾，<br>因为这种就是类似于数学归纳法一样，前一步推后一步，认为前面假设的是正确的，所以dp’[j-1]+a[j] 不可能是候选的最优解，若dp[j-1]&gt;dp’[j-1]&gt;0 || dp[j-1]&gt;0&gt;dp’[j-1] 则最优解dp[j-1]+a[j] 若0&gt;dp[j-1]&gt;dp’[j-1], 则a[j]最优解，<br>所以最优解只可能是max{dp[j-1]+a[j], a[j]} 不可能是某个dp’[j-1]+a[j]的</p>
<p>其实总结下来也就是最有子结构性质啦，我之前也不知为啥已知有点疑惑。。。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 14 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/14/data-type-range/">data type range</a></h1>
  

      <time datetime="2014-07-14T03:29:27.000Z"><a href="/2014/07/14/data-type-range/">7月 14 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>数据类型一直都是麻烦事，看到剑指Offer上判溢出拿了范围更大的long long int来装可能溢出的int，于是总结各种数据类型的范围</p>
<p>int = long<br>unsigned int= unsigned long</p>
<p>这两中是最熟悉的，32bit 有符号位 -2^31~2^31-1 补码范围多一位，因为归到正数那边了，long 这个和他一样，不知道搞个这个出于什么目的。</p>
<p>long long 则是翻了一倍，64bit，unsigned long long 自然是 2^64-1 对应的数据范围，所以这个其实比较好理解，</p>
<p>double 则可以表示到10^308此方(1.79769e+308 ~ 2.22507e-308)，long double则可以惊人的1.18973e+4932 ~ 3.3621e-4932 </p>
<p>主要指导用long long 来处理范围更大的数据就可以了，2^31-1 好像是2147483647，大概12位，2^32-1是经典的4294967295，google直接计算很舒服，2^64-1是1.8446744e+19，20位，应该足够大了。</p>
<p>整数int,longlong<br><a href="http://www.cnblogs.com/xiangshancuizhu/archive/2010/12/12/1903719.html" target="_blank" rel="external">http://www.cnblogs.com/xiangshancuizhu/archive/2010/12/12/1903719.html</a><br>包含浮点数double long double等<br><a href="http://blog.csdn.net/xuexiacm/article/details/8122267" target="_blank" rel="external">http://blog.csdn.net/xuexiacm/article/details/8122267</a></p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 14 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/14/StrToInt,-not-equal-to-atoi/">StrToInt, not equal to atoi</a></h1>
  

      <time datetime="2014-07-14T02:12:30.000Z"><a href="/2014/07/14/StrToInt,-not-equal-to-atoi/">7月 14 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>这道题目当时写的leetcode那个其实还是不是非常好，因为只是和lib里atoi完全一致，但是他的很多需求很奇怪，我觉得还是要重新实现，<br>模仿July的需求来设计这个function，另外今天看到一个合法全数字的string到int的算法</p>
<pre><code><span class="built_in">int</span> num=<span class="number">0</span>;
<span class="keyword">while</span>(*<span class="built_in">string</span>!=\<span class="number">0</span><span class="comment">')</span>
{
    num=<span class="number">10</span>*num+<span class="built_in">string</span>-<span class="comment">'0';</span>
    <span class="built_in">string</span>++;
}
</code></pre><p>当时还以为有问题，但是完全手动模拟发现完全正确，我一直都是按照weight来累加，先计算位数，然后weight逐个pow(10,weight)这样，居然看到这个很新鲜。<br>后来想想，这种迭代的严格来说都有个或简单或复杂的数学递推式，例如这里 an=a(n-1) <em> 10+sn 其中下标是1-base, ai表示高位开始1到i位的十进制数，si表示从高位开始第i位数字，于是就<br>好理解了，1=0</em>10+1， 12=1<em>10+2，123=12</em>10+3，于是可以这么迭代下去计算最后的值.而且我也感觉July给的答案也不是我那个代码的样子。。。</p>
<pre><code><span class="keyword">bool</span> valid(<span class="keyword">char</span> *<span class="keyword">str</span>)
{
    <span class="keyword">int</span> i=<span class="number">0</span>;
    <span class="keyword">if</span>((<span class="keyword">str</span>[i]&lt;=<span class="string">'9'</span> &amp;&amp; <span class="keyword">str</span>[i]&gt;=<span class="string">'0'</span>) || <span class="keyword">str</span>[i] == <span class="string">'.'</span>||<span class="keyword">str</span>[i]==<span class="string">'+'</span> || <span class="keyword">str</span>[i]==<span class="string">'-'</span>)<span class="comment">//first can be dot</span>
        i++;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="keyword">int</span> dotcount=<span class="number">0</span>;
    <span class="keyword">while</span>(i&lt;strlen(<span class="keyword">str</span>))
    {
        <span class="keyword">if</span>((<span class="keyword">str</span>[i]&lt;=<span class="string">'9'</span> &amp;&amp; <span class="keyword">str</span>[i]&gt;=<span class="string">'0'</span>))
            i++;
        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">str</span>[i]==<span class="string">'.'</span>)<span class="comment">//dot can be any place</span>
        {
            i++;
            dotcount++;
            <span class="keyword">if</span>(dotcount&gt;<span class="number">1</span>)<span class="comment">//only one dot</span>
                <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">else</span> <span class="comment">//invalid char</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
<span class="keyword">bool</span> invalid=<span class="keyword">false</span>;<span class="comment">//global value for invalid input parameter</span>
<span class="keyword">int</span> StrtoInt(<span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">int</span> len;
    <span class="keyword">if</span>(<span class="keyword">str</span>==NULL) {cout&lt;&lt;<span class="string">"pointer NULL"</span>;invalid=<span class="keyword">true</span>;<span class="keyword">return</span> -<span class="number">1</span>;}<span class="comment">//-1 just can be any value, as a global value as flag</span>
    <span class="keyword">if</span>((len=strlen(<span class="keyword">str</span>))==<span class="number">0</span>) {cout&lt;&lt;<span class="string">"string NULL"</span>;invalid=<span class="keyword">true</span>;<span class="keyword">return</span> -<span class="number">1</span>;}
    <span class="keyword">if</span>(!valid(<span class="keyword">str</span>)) {cout&lt;&lt;<span class="string">"not valid string"</span>;invalid=<span class="keyword">true</span>;<span class="keyword">return</span> -<span class="number">1</span>;}
    <span class="keyword">int</span> i=<span class="number">0</span>;
    <span class="keyword">bool</span> IsNegative=<span class="keyword">false</span>;
    <span class="keyword">if</span>(<span class="keyword">str</span>[i]==<span class="string">'-'</span>)
    {
        IsNegative=<span class="keyword">true</span>;
        i++;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">str</span>[i]==<span class="string">'+'</span>)
    {
        i++;
    }
    <span class="keyword">else</span>
        ;
    <span class="keyword">int</span> num=<span class="number">0</span>;
    <span class="keyword">bool</span> overflow=<span class="keyword">false</span>;
    <span class="keyword">while</span>(i&lt;len &amp;&amp; <span class="keyword">str</span>[i]!=<span class="string">'.'</span>)
    {
        <span class="keyword">int</span> originalnum=num;
        num=<span class="number">10</span>*num+<span class="keyword">str</span>[i]-<span class="string">'0'</span>;
        <span class="keyword">if</span>(num&gt;<span class="number">0</span> &amp;&amp; originalnum &lt;<span class="number">0</span> || num&lt;<span class="number">0</span> &amp;&amp; originalnum &gt;<span class="number">0</span>)
            overflow=<span class="keyword">true</span>;
    }
    <span class="keyword">if</span>(overflow==<span class="keyword">true</span>)
    {
        cout&lt;&lt;<span class="string">"overflow"</span>;
        invalid=<span class="keyword">true</span>;
        <span class="keyword">return</span> -<span class="number">1</span>;
    }
    <span class="keyword">if</span>(i==len)
    {
        <span class="keyword">if</span>(IsNegative==<span class="keyword">true</span>)
            <span class="keyword">return</span> -num;
        <span class="keyword">else</span>
            <span class="keyword">return</span> num;
    }
    <span class="keyword">else</span>
    {
        i++;
        <span class="keyword">int</span> weight=-<span class="number">1</span>;
        <span class="keyword">while</span>(i&lt;len)
        {
            num+=pow(<span class="number">10</span>,weight)*(<span class="keyword">str</span>[i]-<span class="string">'0'</span>);<span class="comment">//int not overflow, float can not overflow</span>
            weight--;
        }
        <span class="keyword">if</span>(IsNegative==<span class="keyword">true</span>)
            <span class="keyword">return</span> -num;
        <span class="keyword">else</span>
            <span class="keyword">return</span> num;
    }
}
</code></pre><p>代码写完了，<br>1)判断char* null, 空字符串(注意两者区别)<br>2)判断string has invalid char<br>3)符号处理(记得返回也要处理)<br>4)算值，整数部分新的迭代式，避免计算整数部分位数，小数部分用weight累加(记得判溢出，只需整数部分)<br>5)后处理negative 符号</p>
<p>不确定是否完全正确= = 由于LZ没有意识到返回Int竟然还算了小数部分，抱歉。。。。</p>
<p>最后发现书上答案是不需要单独去先遍历一遍去判断非法字符的，我感觉需求和书上还有有出入，例如只有 + - 或者这种非法都是返回0 而且不标记串非法。。。而且判溢出直接与最大数去比较，不是我这种<br>累加看是否正的变为负的。。。代码还是比那个麻烦。。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 14 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/14/LCA-of-two-nodes-in-tree/">LCA of two nodes in tree</a></h1>
  

      <time datetime="2014-07-14T01:55:14.000Z"><a href="/2014/07/14/LCA-of-two-nodes-in-tree/">7月 14 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>这道题目有几个版本，不同版本解法不一，还记得徐师兄好像当年QQ还是百度笔试有这道题目，不大确定，这也是剑指Offer最后一题 (LCA= lowest common ancestor)<br>Node<em> FindLCA(Node</em> root, Node<em> p1, Node</em> p2)</p>
<ol>
<li>二叉有序树<br>利用有序的性质，如果都在当前子树左边，往左边找，若都在右边，往右边找，若一左一右，返回，非常简明，一个while循环就出来了，<br>因为每一步可以直接获得值，所以不需要递归 ，后面会遇到这种不能直接获得值得，可能就需要递归了</li>
</ol>
<p>2.三叉链表<br>一般想到的都是有parent指针，这样会比较方便一点，分别从p1 p2到root，记录到两个另外的linklist，然后转化为<br>两个linklist第一个公共结点的位置，转化为编程之美的题目，各种方法都适用，例如先记录两个长度，然后指针对齐，在逐步后移。<br>从这里我联想到一个问题，因为二叉链表和单链表不一样，肯定要单独cppy到一个linklist里，但是不能只copy值。于是联想到linklist其实最本质的是结点的地址，例如编程之美那道，<br>是找到是否两个point值相同，而不是值，于是用存指针的数组是可以模拟两个链表相交的情况的，存值是不对的。当然解法里面用存address的linklist也是一个道理。</p>
<p>3.普通二叉树<br>1.递归算法：<br>感觉设计递归的时候，总是想到设计参数就比较麻烦，于是想到了一个方法，就是写成一个描述性的语句，里面包含的东西作为参数</p>
<p>找root 中p1 p2的LCA<br>   if left tree 有p1 p2, right tree 无<br>        找left tree中p1 p2的LCA<br>    else if 左无，右有<br>        找right tree中p1 p2的LCA<br>    else 一有一无<br>        return root</p>
<p>这样的话感觉结构很清晰，里面有两类描述语句，不知道是否可以统一成一个函数的功能。感觉好像不行，可能需要写一个判断二叉树是否有p1 p2这样一个函数。</p>
<ol>
<li>非递归算法<br>模仿三叉链表，既然没有parent，那就从root开始遍历找  到p1 p2的path，copy到linklist，然后从尾部开始找两个linklist的(FCN)first common node,但是看到的代码是从公共部分的一端开始，只要相同就覆盖，<br>最后一次覆盖的也是前面开始的FCN</li>
</ol>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 14 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/12/candy/">candy</a></h1>
  

      <time datetime="2014-07-12T12:41:05.000Z"><a href="/2014/07/12/candy/">7月 12 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>需要将git的workspace移到hexo目录下才可以 hexo new ‘post’ 来生成新的.md文件。。。<br>leetcode一道candy题目，大意是每个小孩有打分，至少都有1个糖果，且比两个邻居(如果有的话)打分高的话要比邻居糖果多，求总的糖果至少多少？</p>
<p>我分析了之后，发现题目不明确，如果邻居相等的话，不知道多少，如果小于的话也没有说。这个先放下，一般是先分析general的情况。</p>
<p>一遍是不行的，因为可能后面降的时候，不知道降多少，可能不是decrease 1的降. 然后我在想，从前往后，再从后往前，其实有个解法是这样的，但我没有继续这么想。我想到的做法是，先把这些极小值点找出来，然后往上爬着增一定不会错，但是注意覆盖极大值的时候，可能被赋值两次，<br>于是要选择两者中较大的，打擂台完成。</p>
<p>先一遍遍历找极小值，然后后面遍历这个极小值index的数组，每个从两边(如果有的话)往上爬，直至极大值点。但是其实如果1 1 1 1 2 2 2 1 1 1 我就不清楚那些2应该给多少candy了，按道理的话他们都不满足比<br>两个邻居大，应该可以赋1的，但是我算出来是 2 1 2，结果还AC了，我感觉题目说不清楚。。。如果测试用例包含的情况足够的话。。。</p>
<p>最怕这种连题意都没完全理清楚，好像也没完全说清楚，但是又糊里糊涂的过了。。。</p>
<p>后来发现这位仁兄，非常简洁的两边扫描就完成了，往上增，右边也往上增，初始为1，比我的简洁多了。<br><a href="http://zhaohongze.com/wordpress/2013/12/10/leetcode-candy/" target="_blank" rel="external">http://zhaohongze.com/wordpress/2013/12/10/leetcode-candy/</a></p>
<pre><code><span class="keyword">int</span> candy(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;ratings)
{
    <span class="keyword">int</span> <span class="variable">*candy</span>=new <span class="keyword">int</span>[ratings.<span class="keyword">size</span>()]();<span class="comment">//candy number of each child</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ratings.<span class="keyword">size</span>();i++)<span class="comment">//initial 1, as some child that are not bigger than neighbors, but one bigger, one equal also one, not clear</span>
        candy[i]=<span class="number">1</span>;
    <span class="comment">//memset(candy,1,sizeof(int)*ratings.size());//this can not memset, as memeset fill Bytes with 1, which make 0001000100010001(hex) like this, which is wrong, so memset can only zero(clear)</span>
    <span class="comment">//get min array</span>
    <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; minvec;<span class="comment">//min ratings array</span>

    <span class="comment">//int *minvec=new int[ratings.size()];</span>

    <span class="keyword">int</span> k;
    <span class="comment">//create min index array</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ratings.<span class="keyword">size</span>();i++)
    {
        <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; i+<span class="number">1</span> &lt;= (ratings.<span class="keyword">size</span>()-<span class="number">1</span>) )
        {
            <span class="keyword">if</span>(ratings.at(i-<span class="number">1</span>) &gt;= ratings.at(i) &amp;&amp; ratings.at(i)&lt;=ratings.at(i+<span class="number">1</span>))<span class="comment">//&lt;= include equal or less than</span>
            {
                <span class="comment">//minvec[k]=i;</span>
                candy[i]=<span class="number">1</span>;
                <span class="comment">//k++;</span>
                minvec.push_back(i);
            }
        }
        <span class="keyword">else</span> <span class="keyword">if</span>( i-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i+<span class="number">1</span> &gt; (ratings.<span class="keyword">size</span>()-<span class="number">1</span>))
        {
            <span class="keyword">if</span>(ratings.at(i-<span class="number">1</span>) &gt;= ratings.at(i))
            {
                candy[i]=<span class="number">1</span>;
                minvec.push_back(i);
            }
        }
        <span class="keyword">else</span> <span class="keyword">if</span>( i-<span class="number">1</span> &lt; <span class="number">0</span> &amp;&amp; i+<span class="number">1</span> &lt;= (ratings.<span class="keyword">size</span>()-<span class="number">1</span>) )
        {
            <span class="keyword">if</span>(ratings.at(i)&lt;=ratings.at(i+<span class="number">1</span>))
            {
                candy[i]=<span class="number">1</span>;
                minvec.push_back(i);
            }
        }
    }

    <span class="comment">//from min to two side increase</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;minvec.<span class="keyword">size</span>();i++)
    {
        <span class="keyword">int</span> j=minvec.at(i),k=j;
        <span class="keyword">while</span>(j&gt;=<span class="number">1</span> &amp;&amp; ratings.at(j-<span class="number">1</span>) &gt; ratings.at(j))<span class="comment">//equal would be as inital value, 1</span>
        {
            <span class="keyword">if</span>(candy[j-<span class="number">1</span>] &lt; candy[j]+<span class="number">1</span>)<span class="comment">//get max of two value</span>
                candy[j-<span class="number">1</span>]=candy[j]+<span class="number">1</span>;
            j--;
        }

        j=k;
        <span class="keyword">while</span>(j&lt;=ratings.<span class="keyword">size</span>()-<span class="number">2</span> &amp;&amp; ratings.at(j) &lt; ratings.at(j+<span class="number">1</span>))
        {
            <span class="keyword">if</span>(candy[j+<span class="number">1</span>] &lt; candy[j] +<span class="number">1</span>)
                candy[j+<span class="number">1</span>]=candy[j]+<span class="number">1</span>;
            j++;
        }
    }

    <span class="keyword">int</span> mincandy=<span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ratings.<span class="keyword">size</span>();i++)
    {
        cout&lt;&lt;candy[i]&lt;&lt;<span class="string">" "</span>;
        mincandy+=candy[i];
    }
    cout&lt;&lt;endl;
    <span class="comment">//delete [] minvec;</span>
    <span class="keyword">delete</span> [] candy;
    <span class="keyword">return</span> mincandy;
}
</code></pre>
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 12 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/8/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/10/" class="alignright next">下一页</a>
  
</nav></div>
    </div>
    <div class="tabbar" onload="divideTabBar()">
	
      <div class="tabbaritem"><a class="next" href="/">Home</a></div>
    
      <div class="tabbaritem"><a class="next" href="/archives/">Archives</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a></div>
    
</div>


  </div>
</body>
</html>