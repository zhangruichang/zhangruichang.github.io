<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 3 页 | Richard</title>
  <meta name="author" content="Richard">
  
  <meta name="description" content="理查德爱闹">
  
  
  
  <meta property="og:site_name" content="Richard"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta property="og:image" content="undefined"/>
  
   <link rel="apple-touch-icon" href="/icon.png" />
   <link rel="shortcut icon" href="/favicon.png" >
   <link rel="alternate" href="http://xxx.xx/atom.xml" title="Richard" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
</head>


<body>
  <div id="content" class="inner">
    <aside id="sidebar" class="alignleft">
      <div class="navigationBar">
        <a href="/">Richard</a>
      </div>
    	
  <nav class="widget" id="menu">
	<ul>
    
      <li class="cell"><a class="next" href="/">Home</a><li>
    
      <li class="cell"><a class="next" href="/archives/">Archives</a><li>
    
      <li class="cell"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a><li>
    
      <li class="cell"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a><li>
    
      <li class="cell"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a><li>
    
    </ul>
</nav>

  <div class="widget weibo">
  <iframe width="100%" height="750" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=750&fansRow=2&ptype=1&speed=0&skin=6&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2689136623&verifier=c139aa37&dpc=1"></iframe>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Binary-Tree/">Binary Tree</a><small>1</small></li>
  
    <li><a href="/categories/DFS/">DFS</a><small>1</small></li>
  
    <li><a href="/categories/DP/">DP</a><small>1</small></li>
  
    <li><a href="/categories/Linklist/">Linklist</a><small>1</small></li>
  
    <li><a href="/categories/Recursive/">Recursive</a><small>1</small></li>
  
    <li><a href="/categories/algorithm/">algorithm</a><small>9</small></li>
  
    <li><a href="/categories/binary-search/">binary search</a><small>2</small></li>
  
    <li><a href="/categories/binary-tree/">binary tree</a><small>3</small></li>
  
    <li><a href="/categories/bit/">bit</a><small>1</small></li>
  
    <li><a href="/categories/bit-operation/">bit operation</a><small>2</small></li>
  
    <li><a href="/categories/blog/">blog</a><small>1</small></li>
  
    <li><a href="/categories/cpp/">cpp</a><small>10</small></li>
  
    <li><a href="/categories/cpp-string/">cpp string</a><small>1</small></li>
  
    <li><a href="/categories/data-structure/">data structure</a><small>4</small></li>
  
    <li><a href="/categories/dfs/">dfs</a><small>1</small></li>
  
    <li><a href="/categories/dp/">dp</a><small>2</small></li>
  
    <li><a href="/categories/ds/">ds</a><small>1</small></li>
  
    <li><a href="/categories/hash/">hash</a><small>1</small></li>
  
    <li><a href="/categories/hexo-configuration/">hexo configuration</a><small>1</small></li>
  
    <li><a href="/categories/hihocode/">hihocode</a><small>1</small></li>
  
    <li><a href="/categories/kmp/">kmp</a><small>1</small></li>
  
    <li><a href="/categories/linklist/">linklist</a><small>4</small></li>
  
    <li><a href="/categories/permutation/">permutation</a><small>2</small></li>
  
    <li><a href="/categories/quick-and-right-coding/">quick and right coding</a><small>1</small></li>
  
    <li><a href="/categories/web/">web</a><small>2</small></li>
  
    <li><a href="/categories/数字规律/">数字规律</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/BST/" style="font-size: 10.00px;">BST</a><a href="/tags/BT/" style="font-size: 10.00px;">BT</a><a href="/tags/Backtrack/" style="font-size: 10.00px;">Backtrack</a><a href="/tags/Combinations/" style="font-size: 10.00px;">Combinations</a><a href="/tags/DP/" style="font-size: 10.00px;">DP</a><a href="/tags/Order/" style="font-size: 10.00px;">Order</a><a href="/tags/Permutation/" style="font-size: 10.00px;">Permutation</a><a href="/tags/algorithm/" style="font-size: 20.00px;">algorithm</a><a href="/tags/array/" style="font-size: 15.00px;">array</a><a href="/tags/back-n-node/" style="font-size: 10.00px;">back n node</a><a href="/tags/backtrack/" style="font-size: 10.00px;">backtrack</a><a href="/tags/binary-search/" style="font-size: 15.00px;">binary search</a><a href="/tags/binary-search-tree/" style="font-size: 10.00px;">binary search tree</a><a href="/tags/bit/" style="font-size: 15.00px;">bit</a><a href="/tags/brute-force/" style="font-size: 12.50px;">brute force</a><a href="/tags/c/" style="font-size: 10.00px;">c</a><a href="/tags/char/" style="font-size: 10.00px;">char*</a><a href="/tags/cin/" style="font-size: 10.00px;">cin</a><a href="/tags/coding/" style="font-size: 10.00px;">coding</a><a href="/tags/complement/" style="font-size: 10.00px;">complement</a><a href="/tags/complex/" style="font-size: 12.50px;">complex</a><a href="/tags/complex-condition-analysis/" style="font-size: 10.00px;">complex condition analysis</a><a href="/tags/configuire/" style="font-size: 10.00px;">configuire</a><a href="/tags/convert/" style="font-size: 10.00px;">convert</a><a href="/tags/cpp/" style="font-size: 17.50px;">cpp</a><a href="/tags/cpp，inheritance/" style="font-size: 10.00px;">cpp，inheritance</a><a href="/tags/cycle/" style="font-size: 10.00px;">cycle</a><a href="/tags/data-structure/" style="font-size: 17.50px;">data structure</a><a href="/tags/data-type/" style="font-size: 12.50px;">data type</a><a href="/tags/digit/" style="font-size: 10.00px;">digit</a><a href="/tags/divide/" style="font-size: 10.00px;">divide</a><a href="/tags/divide-2/" style="font-size: 10.00px;">divide 2</a><a href="/tags/domain/" style="font-size: 10.00px;">domain</a><a href="/tags/double-linklist/" style="font-size: 10.00px;">double linklist</a><a href="/tags/dp/" style="font-size: 15.00px;">dp</a><a href="/tags/find/" style="font-size: 10.00px;">find</a><a href="/tags/finding-rule/" style="font-size: 10.00px;">finding rule</a><a href="/tags/getline/" style="font-size: 10.00px;">getline</a><a href="/tags/git/" style="font-size: 10.00px;">git</a><a href="/tags/github/" style="font-size: 10.00px;">github</a>
  </div>
</div>


    	<footer id="footer" class="inner"><div class="copyright">
  
  &copy; 2014 Richard
  
</div>



</footer>
    </aside>
    
    
    <div id="hidden-navigationBar" class="navigationBar">
      <a href="/">Richard</a>
    </div>
    <div id="main-col" class="alignright">
    <div id="wrapper">
      
  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/23/LeetCodePermutation/">LeetCodePermutation Summary</a></h1>
  

      <time datetime="2014-07-23T15:33:57.000Z"><a href="/2014/07/23/LeetCodePermutation/">7月 23 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>这里把leetcode里面permutation的题目总结一下，记得一开始看的时候，发现心里很不清楚，next_permutation也是调用库的，看了邹博的PPT<br>之后加上之前看的permutation基本思路理清楚了。</p>
<p>我直接在leetcode上coding，为了模拟纸上coding的效果</p>
<p>普通的permutation，如果换成字符串的话也是一样的：</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> permute(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &amp;num) {
        <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> permutationvec;
        permutation(num,<span class="number">0</span>,num.size()-<span class="number">1</span>,permutationvec);
        <span class="keyword">return</span> permutationvec;
    }

    <span class="keyword">void</span> permutation(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> num, <span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span>&amp; permutationvec)
    {
        <span class="keyword">if</span>(from&gt;to)
        {
            <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> eachpervec;
            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=to;i++)
                eachpervec.push_back(num[i]);
            permutationvec.push_back(eachpervec);
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=from;i&lt;=to;i++)
            {
                swap(num[from],num[i]);
                permutation(num,from+<span class="number">1</span>,to, permutationvec);
                swap(num[from],num[i]);
            }
        }
    }
};
</code></pre><p>按照邹博的函数参数风格写，感觉自己萌萌哒！！！</p>
<p>然后是带有重复数的permutation，只要加一个函数，判断里面是否a[from,i-1] 中是否有数等于a[i] 就可以了。</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> permuteUnique(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &amp;num) {
        <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> permutationvec;
        permutation(num,<span class="number">0</span>,num.size()-<span class="number">1</span>,permutationvec);
        <span class="keyword">return</span> permutationvec;
    }
    <span class="keyword">bool</span> IsSwap(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> num, <span class="keyword">int</span> from, <span class="keyword">int</span> i)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> j=from;j&lt;=i-<span class="number">1</span>;j++)
        {
            <span class="keyword">if</span>(num[i]==num[j])
                <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">void</span> permutation(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> num, <span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span>&amp; permutationvec)
    {
        <span class="keyword">if</span>(from&gt;to)
        {
            <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> eachpervec;
            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=to;i++)
                eachpervec.push_back(num[i]);
            permutationvec.push_back(eachpervec);
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=from;i&lt;=to;i++)
            {
                <span class="keyword">if</span>(!IsSwap(num,from,i)) <span class="keyword">continue</span>;
                swap(num[from],num[i]);
                permutation(num,from+<span class="number">1</span>,to, permutationvec);
                swap(num[from],num[i]);
            }
        }
    }
};
</code></pre><p>然后返回kth 排列，由于邹博所说的，next_permutation可以天然的去除里面有重复数的case，但是我已开始用next_permutation发现TLE了，显然每次都调用这个然后n!次调用非常费时间，还是普通permutation然后<br>记录下第k次的permutation的结果！</p>
<p>这里面我定义了一下类的成员，减少递归函数的参数，避免潜在的栈溢出情况，递归有一点很不好，就是如果我中间找到了结果想返回时返回不了的，因为栈已经压到这么深了，而迭代则可以通过break来达到目的。</p>
<pre><code>class Solution {
<span class="keyword">public</span>:
    <span class="keyword">string</span> result;
    <span class="keyword">int</span> kth;

    <span class="keyword">string</span> getPermutation(<span class="keyword">int</span> n, <span class="keyword">int</span> k) {
        kth=k;
        <span class="keyword">string</span> str=<span class="string">""</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)
            str+=<span class="keyword">char</span>(i+<span class="string">'0'</span>);

        permutation(str,<span class="number">0</span>,str.size()-<span class="number">1</span>);
        <span class="keyword">return</span> result;
    }

    <span class="keyword">void</span> permutation(<span class="keyword">string</span> num, <span class="keyword">int</span> <span class="keyword">from</span>, <span class="keyword">int</span> to)
    {
        <span class="keyword">if</span>(<span class="keyword">from</span>&gt;to)
        {

            <span class="comment">//string eachpervec;</span>
            <span class="comment">//for(int i=0;i&lt;=to;i++)</span>
                <span class="comment">//eachpervec.push_back(num[i]);</span>
            <span class="comment">//    eachpervec+=num[i];</span>
            kth--;
            <span class="keyword">if</span>(kth==<span class="number">0</span>)
                result=num;
            <span class="comment">//permutationvec.push_back(eachpervec);</span>
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="keyword">from</span>;i&lt;=to;i++)
            {
                swap(num[<span class="keyword">from</span>],num[i]);
                permutation(num,<span class="keyword">from</span>+<span class="number">1</span>,to);
                swap(num[<span class="keyword">from</span>],num[i]);
            }
        }
    }
};
</code></pre><p>还是TLE了o(╯□╰)o，所以还是需要非递归算法来剪枝达到 减少不必要的继续递归了，但是非递归的都忘记了o(╯□╰)o</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 23 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/23/next_permutation/">next_permutation</a></h1>
  

      <time datetime="2014-07-23T14:56:59.000Z"><a href="/2014/07/23/next_permutation/">7月 23 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>从邹博那里的算法：<br>next_permutation:<br>如果一个数后面有比他大的数，就应该有下一个字典序大的permutation了，下一个应当是与后面比他大的数里 最接近他的那个交换，因为这个才是紧接着他的permutation</p>
<ol>
<li>找最后一个数a[i]，使得后面存在比他大的数</li>
<li>找该数a[i]与后面比！！他大的数！！里最小的数a[maxmini]//一开始没想清楚，本以为1 2点两个循环可以合并，后来发现不行，必须是比a[i]大的数里找，a[i]必须循环结束了才能确定，然后maxmini 初始可以选i+1,因为至少a[i+1]&gt;a[i]的至于是不是最小则遍历一遍打擂台即可，<br>我确实不太喜欢定义一个MAXNUM，总觉得这样程序适用性会有局限性，除非万不得已，例如Dijstra算法，其实也可以去掉，但是来麻烦了，而且也没有这种做法= =</li>
<li>swap(a[i], a[maxmini])</li>
<li><p>将该数[i]后面的数排序</p>
<p> void nextpermutation(int *a, int n)<br> {</p>
<pre><code> <span class="keyword">int</span> i=n-<span class="number">1</span>;
 <span class="keyword">while</span>(i&gt;=<span class="number">1</span> &amp;&amp; a[i-<span class="number">1</span>]&gt;a[i])<span class="comment">//property</span>
 {
     i--;
 }

 <span class="keyword">if</span>(i&lt;<span class="number">1</span>)
     <span class="keyword">return</span>;
 <span class="comment">//i-1 is to be swapped</span>

 <span class="keyword">int</span> <span class="keyword">min</span>=a[i],mini=i;
 <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>;j&gt;=i;j--)
 {
     <span class="keyword">if</span>(a[j]&lt;<span class="keyword">min</span> &amp;&amp; a[j]&gt;a[i-<span class="number">1</span>])
     {
         mini=j;<span class="keyword">min</span>=a[j];
     }
 }

 swap(a[i-<span class="number">1</span>],a[mini]);
 <span class="keyword">sort</span>(a+i,a+n);<span class="comment">//sort [begin, end)</span>
</code></pre><p> }</p>
</li>
</ol>
<p>这里面有个bug，如果数字里出现重复的就挂了，因为while的目的是为了找第一次出现a[i-1]&lt;a[i]的，=都不行的，因为等于的话，交换可能是无用交换，导致后面的还是和当前的permutation一样。因此while改为</p>
<pre><code><span class="keyword">while</span>(i&gt;=<span class="number">1</span> &amp;&amp; <span class="operator">a</span>[i-<span class="number">1</span>]&gt;=<span class="operator">a</span>[i]<span class="comment">)//property</span>
</code></pre><p>另外里面找不到这样的i的时候，允许循环pemutation需要手动调整到第一个ascending顺序的permutation，因此代码改为：</p>
<pre><code><span class="keyword">if</span>(i&lt;<span class="number">1</span>)
{
    sort(<span class="literal">a</span>,<span class="literal">a</span>+n)<span class="comment">;</span>
    <span class="keyword">return</span><span class="comment">;</span>
}
</code></pre><p>试了下库函数，next_permutation是可以直接跳过重复的permutation的，所以如果重复数的话，n!次nextpermutaion就不是到起点了，而是过头了。<br>另外这里面本来是 找到i=max k (a[k]<a[k+1...n-1]中至少一个)，但是我从后向前迭代的时候，其实可以只看前后就可以了。 例如="" a="" b="" c按照这个顺序，如果="" a<b="" 的话="" 一定找到了，不论c和a的关系，但是如果a="">b 可以确定一定后面没有比a大的数么？</a[k+1...n-1]中至少一个)，但是我从后向前迭代的时候，其实可以只看前后就可以了。></p>
<p>答案是可以！因为前面如果能过来，说明逐个都是从后往前递减的，如果a&gt;b 的话， 由于b&gt;c,所以a&gt;c 也即a只要和最右判断大小即可确定后面是否有比a大的数了！</p>
<p>另外还有一点性质，就是swap之后，i+1…n-1之间一定是递减的，因为a[k]是大于a[i]里最小的，a[i]比大于后面的，因为后面的肯定都小于a[i]，而前面也肯定都是大于a[i],因为前面的数比a[k]大(之前是选出最小)，于是我意识<br>到自己不了解这个性质导致性能降低，于是里面的sort全部换成reverse。。。。</p>
<p>但是看到邹博的代码好像挺复杂的。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 23 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/23/Median-of-two-array/">Median of two array</a></h1>
  

      <time datetime="2014-07-23T13:30:51.000Z"><a href="/2014/07/23/Median-of-two-array/">7月 23 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>两个数组的中位数，这道是11CS的DS最后一题，考研的童鞋一定不会陌生，都已经做烂了，但是想想看第一次做的时候，是否能写出正确的处理所有case的代码了。<br>我也不记得当时有没有写出来了。。。。</p>
<p>这道题目很多帖子，也是经典题目<br><a href="http://wenku.baidu.com/view/114e577a27284b73f242506b" target="_blank" rel="external">http://wenku.baidu.com/view/114e577a27284b73f242506b</a><br><a href="http://liubangchuan.iteye.com/blog/1870650" target="_blank" rel="external">http://liubangchuan.iteye.com/blog/1870650</a><br><a href="http://my.oschina.net/mustang/blog/58047" target="_blank" rel="external">http://my.oschina.net/mustang/blog/58047</a><br><a href="http://blog.csdn.net/hackbuteer1/article/details/7584838" target="_blank" rel="external">http://blog.csdn.net/hackbuteer1/article/details/7584838</a></p>
<p>先来个简单的，假设两个数组等长，且sorted，假设median定义为 两个数组中 中间两个数较小的一个<br>思路大家基本都知道，就是两个数组同时二分，然后比较, a[mid1]<b[mid2], 那么a往高处走，b往低处走，如果a[mid1]="">b[mid2],那么a往低处走，b往高处走，相等的话直接返回结果。<br>思想是基于这个：中位数必&gt;=至少”一半”的数，n奇，(n-1)/2 此处写的除都是数学的除，不是C++的除，避免混淆,如果偶数，必&gt;=(n-2)/2),对于等长数组，n比为偶数</b[mid2],></p>
<p>(中位数：如果长度为奇，就是排序后中间的数，如果偶，就是中间的两个数的任意一个(leetcode定义为均值))，那么接下来代码AC(如果面试官算法非常强的话，应该是知道你的代码是否可以AC的)之前需要回答几个问题：</p>
<ol>
<li>返回的出口在哪几个地方？</li>
<li>奇偶性处理</li>
</ol>
<p>对于第一个问题，首先如果相等的话，就找到了，因为&lt;=a[mid] 的数至少(n-2)/2， &gt;=a[mid]也一样，b[mid]也一样，所以直接返回中位数了，如果a[mid1]&lt;b[mid1]，a[0…mid1-1] b[0..mid1-1]最多这么多数小于。。。。<br>突然发现好像看的答案好像只能返回偶数时两个中位数中靠前的一个。。。。。呜呜呜。。。。。。</p>
<p>大致思想是如果&lt;=a[mid]的数都不到一半了，往上移的时候可以多移一位，否则要保留mid，b[]也是一样的。</p>
<p>现附上这个两个等长数组，返回中位数(如果偶数个数时返回中间两个任意都可以的话)代码(由于没有OJ测所以未必保证正确性)：</p>
<pre><code><span class="keyword">int</span> findMedianSortedArrays_EqualSize(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)
{
    <span class="keyword">int</span> low1=<span class="number">0</span>,high1=n-<span class="number">1</span>,low2=<span class="number">0</span>,high2=n-<span class="number">1</span>;
    <span class="keyword">while</span>(low1&lt;high1 || low2&lt;high2)
    {
        <span class="keyword">int</span> mid1=(low1+high1)/<span class="number">2</span>;
        <span class="keyword">int</span> mid2=(low2+high2)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[mid1]&lt;B[mid2])
        {

            <span class="keyword">if</span>(n<span class="variable">%2</span>==<span class="number">0</span>)<span class="comment">//a[mid1] can not be median of a[]+b[], analyze...</span>
                low1=mid1+<span class="number">1</span>,high2=mid2;
            <span class="keyword">else</span>
                low1=mid1,high2=mid2;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(A[mid1]&gt;B[mid2])<span class="comment">//对称分析</span>
        {
            <span class="keyword">if</span>(n<span class="variable">%2</span>==<span class="number">0</span>)
                low2=mid2,high2=mid2-<span class="number">1</span>;
            <span class="keyword">else</span>
                low2=mid2,high2=mid2;
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">return</span> A[mid1];
        }
    }
    <span class="keyword">return</span> A[low1]&lt;B[low2]?A[low1]:B[low2];

}
</code></pre><p>这个等长的情况已经比较麻烦了，包括最后返回的这两个low1 low2的解释我还没有看到，而不等长的里面还嵌套了一个外部函数的递归，我本打算基于上述这个弄个不等长的，始终搞不出来o(╯□╰)o<br>不等长的就暂时放一放吧，这个从昨天一直搞到几天，断断续续弄，太浪费时间了，先暂时搁置吧，我用merge方向也过了leetcode，leetcode其实时间很松的。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 23 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/23/scanf-eof-cin/">scanf eof cin</a></h1>
  

      <time datetime="2014-07-23T07:05:04.000Z"><a href="/2014/07/23/scanf-eof-cin/">7月 23 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>今天发现遇到一个奇怪的问题，群里的童鞋说POJ这样写TLE</p>
<pre><code><span class="keyword">while</span>(~scanf(<span class="string">"<span class="variable">%s</span><span class="variable">%s</span>"</span>, <span class="keyword">s</span>,e))
</code></pre><p>但是这样写就AC了</p>
<pre><code><span class="keyword">while</span>(scanf(<span class="string">"<span class="variable">%s</span><span class="variable">%s</span>"</span>, <span class="keyword">s</span>,e)!=<span class="keyword">eof</span>)
</code></pre><p>后来发现，G++两个都可以，但是C++(MSVC)第一个就会TLE了</p>
<p>看了官方的scanf资料，<a href="http://www.cplusplus.com/reference/cstdio/scanf/?kw=scanf" target="_blank" rel="external">http://www.cplusplus.com/reference/cstdio/scanf/?kw=scanf</a><br>发现还是比较模糊，尤其是eof之前就有阴影，感觉有时候会很奇怪。看过一篇详细的eof博客，还是没理清头绪</p>
<pre><code><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e)
</code></pre><p>这种就不需要管eof的事情，OJ后台可能还是重定向到文件里，然后去读文件的</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 23 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/23/BFS-Knight/"></a></h1>
  

      <time datetime="2014-07-23T06:49:20.000Z"><a href="/2014/07/23/BFS-Knight/">7月 23 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>title: BFS-Knight<br>date: 2014-07-23 14:49:20<br>categories: bfs</p>
<h2 id="tags:[knight,_bfs]">tags:[knight, bfs]</h2>
<p>看到群里童鞋说这个scanf会挂，于是我试了下，poj已提交网页就挂了，不知道为啥。</p>
<p>朴素的bfs，之前dfs练得多一些，图的dfs相比树的因为更复杂，需要visit来避免重复访问。poj2243, 这道就是基本的bfs了，好像也没有剪枝的策略。</p>
<pre><code><span class="preprocessor">#include &lt;map&gt;</span>
<span class="preprocessor">#include &lt;set&gt;</span>
<span class="preprocessor">#include &lt;queue&gt;</span>
<span class="preprocessor">#include &lt;stack&gt;</span>
<span class="preprocessor">#include &lt;math.h&gt;</span>
<span class="preprocessor">#include &lt;time.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;limits.h&gt;</span>
<span class="preprocessor">#include &lt;cstring&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="preprocessor">#include &lt;iomanip&gt;</span>
//<span class="preprocessor">#include &lt;unordered_set&gt;</span>
<span class="preprocessor">#define Min(a,b) (((a) &lt; (b)) ? (a) : (b))</span>
<span class="preprocessor">#define Max(a,b) (((a) &gt; (b)) ? (a) : (b))</span>
<span class="preprocessor">#define read freopen("in.txt","r",stdin)</span>
<span class="preprocessor">#define write freopen("out.txt","w",stdout)</span>
using namespace <span class="keyword">std</span><span class="comment">;</span>

struct node
{
    int row<span class="comment">;</span>
    int col<span class="comment">;</span>
    int path<span class="comment">;</span>

}<span class="comment">;</span>

int main()
{
    //read<span class="comment">;</span>
    //write<span class="comment">;</span>
    char s[<span class="number">3</span>],e[<span class="number">3</span>]<span class="comment">;</span>
    while(~scanf(<span class="string">"%s%s"</span>,s,e))
    {
        //cin&gt;&gt;e<span class="comment">;</span>

        node start,end<span class="comment">;</span>
        start<span class="preprocessor">.col</span>=s[<span class="number">0</span>]-<span class="string">'a'</span><span class="comment">;</span>
        start<span class="preprocessor">.row</span>=s[<span class="number">1</span>]-<span class="string">'1'</span><span class="comment">;</span>
        start<span class="preprocessor">.path</span>=<span class="number">0</span><span class="comment">;</span>
        end<span class="preprocessor">.col</span>=e[<span class="number">0</span>]-<span class="string">'a'</span><span class="comment">;</span>
        end<span class="preprocessor">.row</span>=e[<span class="number">1</span>]-<span class="string">'1'</span><span class="comment">;</span>

        queue&lt;node&gt; q<span class="comment">;</span>

        q<span class="preprocessor">.push</span>(start)<span class="comment">;</span>
        node p<span class="comment">;</span>
        while(!q<span class="preprocessor">.empty</span>())
        {
            p=q<span class="preprocessor">.front</span>()<span class="comment">;</span>
            q<span class="preprocessor">.pop</span>()<span class="comment">;</span>
            if(p<span class="preprocessor">.row</span>==end<span class="preprocessor">.row</span> &amp;&amp; p<span class="preprocessor">.col</span>== end<span class="preprocessor">.col</span>)
            {
                <span class="keyword">break</span><span class="comment">;</span>
            }

            if(p<span class="preprocessor">.row</span>-<span class="number">2</span> &gt;=<span class="number">0</span> &amp;&amp; p<span class="preprocessor">.col</span>+<span class="number">1</span>&lt;=<span class="number">7</span>)
            {
                node nd<span class="comment">;</span>
                nd<span class="preprocessor">.row</span>=p<span class="preprocessor">.row</span>-<span class="number">2</span><span class="comment">;nd.col=p.col+1;</span>
                nd<span class="preprocessor">.path</span>=p<span class="preprocessor">.path</span>+<span class="number">1</span><span class="comment">;</span>
                q<span class="preprocessor">.push</span>(nd)<span class="comment">;</span>
            }

            if(p<span class="preprocessor">.row</span>-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; p<span class="preprocessor">.col</span>+<span class="number">2</span>&lt;=<span class="number">7</span>)
            {
                node nd<span class="comment">;</span>
                nd<span class="preprocessor">.row</span>=p<span class="preprocessor">.row</span>-<span class="number">1</span><span class="comment">;nd.col=p.col+2;</span>
                nd<span class="preprocessor">.path</span>=p<span class="preprocessor">.path</span>+<span class="number">1</span><span class="comment">;</span>
                q<span class="preprocessor">.push</span>(nd)<span class="comment">;</span>
            }
            if(p<span class="preprocessor">.row</span>+<span class="number">1</span> &lt;=<span class="number">7</span> &amp;&amp; p<span class="preprocessor">.col</span>+<span class="number">2</span>&lt;=<span class="number">7</span>)
            {
                node nd<span class="comment">;</span>
                nd<span class="preprocessor">.row</span>=p<span class="preprocessor">.row</span>+<span class="number">1</span><span class="comment">;nd.col=p.col+2;</span>
                nd<span class="preprocessor">.path</span>=p<span class="preprocessor">.path</span>+<span class="number">1</span><span class="comment">;</span>
                q<span class="preprocessor">.push</span>(nd)<span class="comment">;</span>
            }
            if(p<span class="preprocessor">.row</span>+<span class="number">2</span> &lt;=<span class="number">7</span> &amp;&amp; p<span class="preprocessor">.col</span>+<span class="number">1</span>&lt;=<span class="number">7</span>)
            {
                node nd<span class="comment">;</span>
                nd<span class="preprocessor">.row</span>=p<span class="preprocessor">.row</span>+<span class="number">2</span><span class="comment">;nd.col=p.col+1;</span>
                nd<span class="preprocessor">.path</span>=p<span class="preprocessor">.path</span>+<span class="number">1</span><span class="comment">;</span>
                q<span class="preprocessor">.push</span>(nd)<span class="comment">;</span>
            }
            if(p<span class="preprocessor">.row</span>+<span class="number">2</span> &lt;=<span class="number">7</span> &amp;&amp; p<span class="preprocessor">.col</span>-<span class="number">1</span>&gt;=<span class="number">0</span>)
            {
                node nd<span class="comment">;</span>
                nd<span class="preprocessor">.row</span>=p<span class="preprocessor">.row</span>+<span class="number">2</span><span class="comment">;nd.col=p.col-1;</span>
                nd<span class="preprocessor">.path</span>=p<span class="preprocessor">.path</span>+<span class="number">1</span><span class="comment">;</span>
                q<span class="preprocessor">.push</span>(nd)<span class="comment">;</span>
            }
            if(p<span class="preprocessor">.row</span>+<span class="number">1</span> &lt;=<span class="number">7</span> &amp;&amp; p<span class="preprocessor">.col</span>-<span class="number">2</span>&gt;=<span class="number">0</span>)
            {
                node nd<span class="comment">;</span>
                nd<span class="preprocessor">.row</span>=p<span class="preprocessor">.row</span>+<span class="number">1</span><span class="comment">;nd.col=p.col-2;nd.path=p.path+1;</span>
                q<span class="preprocessor">.push</span>(nd)<span class="comment">;</span>
            }
            if(p<span class="preprocessor">.row</span>-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; p<span class="preprocessor">.col</span>-<span class="number">2</span>&gt;=<span class="number">0</span>)
            {
                node nd<span class="comment">;</span>
                nd<span class="preprocessor">.row</span>=p<span class="preprocessor">.row</span>-<span class="number">1</span><span class="comment">;nd.col=p.col-2;nd.path=p.path+1;</span>
                q<span class="preprocessor">.push</span>(nd)<span class="comment">;</span>
            }
            if(p<span class="preprocessor">.row</span>-<span class="number">2</span> &gt;=<span class="number">0</span> &amp;&amp; p<span class="preprocessor">.col</span>-<span class="number">1</span>&gt;=<span class="number">0</span>)
            {
                node nd<span class="comment">;</span>
                nd<span class="preprocessor">.row</span>=p<span class="preprocessor">.row</span>-<span class="number">2</span><span class="comment">;nd.col=p.col-1;nd.path=p.path+1;</span>
                q<span class="preprocessor">.push</span>(nd)<span class="comment">;</span>
            }
        }

        cout&lt;&lt;<span class="string">"To get from "</span>&lt;&lt;s&lt;&lt;<span class="string">" to "</span>&lt;&lt;e&lt;&lt;<span class="string">" takes "</span>&lt;&lt;p<span class="preprocessor">.path</span>&lt;&lt;<span class="string">" knight moves."</span>&lt;&lt;endl<span class="comment">;</span>
    }

    return <span class="number">0</span><span class="comment">;</span>
}
</code></pre>
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 23 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/23/Recode-SubsetsSnum/">Recode SubsetsSnum</a></h1>
  

      <time datetime="2014-07-23T06:32:19.000Z"><a href="/2014/07/23/Recode-SubsetsSnum/">7月 23 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>看到邹博写的permutation，发现参数比较有意思，是from to这种，后来想想，确实这种比较make sense，之前写的的什么selectk，k，selectn,n都非常容易在边界之类的出错，递归出口处的逻辑等等，这种非常清晰，于是<br>学习邹博的coding风格重写了subsetsnum 问题。</p>
<p>先写了一个朴素的，遍历完2^n搜索空间的朴素，from是起点，to是终点，所以这么调用Sum(a, 0,n-1,sumx);表示从a[from…to]里面找到子集和为sumx的集合，<br>后来发现，这样每次都去想到底是n还是n-1，出口是k&gt;n还是k==n呢，每次都先写一个，然后拿个例子去测，还是邹博这种写法比较规范。</p>
<pre><code><span class="keyword">void</span> Sum(<span class="keyword">int</span> *a, <span class="keyword">int</span> <span class="keyword">from</span>, <span class="keyword">int</span> to, <span class="keyword">int</span> sumx)
{
    <span class="keyword">if</span>(<span class="keyword">from</span>&gt;to)
    {
        <span class="keyword">int</span> sum=<span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=to;i++)
            sum+=a[i]*<span class="keyword">select</span>[i];
        <span class="keyword">if</span>(sum==sumx)
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=to;i++)
                <span class="keyword">if</span>(<span class="keyword">select</span>[i])
                    cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;
            cout&lt;&lt;endl;
        }
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">select</span>[<span class="keyword">from</span>]=<span class="keyword">false</span>;
        Sum(a,<span class="keyword">from</span>+<span class="number">1</span>,to, sumx);
        <span class="keyword">select</span>[<span class="keyword">from</span>]=<span class="keyword">true</span>;
        Sum(a,<span class="keyword">from</span>+<span class="number">1</span>,to,sumx);
    }
}
</code></pre><p>一直都考虑到这种很多无用的搜索，例如之前和已经超了，还要去遍历，显然浪费了时间，于是将和&lt;0的剪枝，但是之前写总会出问题，改成这种写法决定试试：</p>
<pre><code>void Cut_Sum(int <span class="keyword">from</span>, int <span class="keyword">to</span>, int sumx)
{


    <span class="keyword">if</span>(sumx&lt;<span class="number">0</span>) <span class="constant">return</span>;
    <span class="keyword">else</span> <span class="keyword">if</span>(sumx==<span class="number">0</span>)
    {
        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&gt;=<span class="keyword">to</span>;i<span class="comment">--)</span>
        {
            <span class="keyword">if</span>(selectn[i])
                cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;
        }
        cout&lt;&lt;endl;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">from</span>&gt;<span class="keyword">to</span>)
<span class="command">        return</span>;
    <span class="keyword">else</span>
    {
        selectn[<span class="keyword">from</span>]=<span class="constant">false</span>;
        Cut_Sum(<span class="keyword">from</span>+<span class="number">1</span>,<span class="keyword">to</span>,sumx);
        selectn[<span class="keyword">from</span>]=<span class="constant">true</span>;
        Cut_Sum(<span class="keyword">from</span>+<span class="number">1</span>,<span class="keyword">to</span>,sumx-a[<span class="keyword">from</span>]);
    }
}
</code></pre><p>后来和上面朴素的结果比一比发现又错了，递归程序改改又挂了o(╯□╰)o</p>
<p>1,2,3,4,5，6 sum=6<br>又来了阴影，打算重新模拟一遍，发现了问题，其实不是完全乱了，而是在回溯到2 4的时候，我把5 6也打印出来了，发现这时候5 6 的select都为true，难怪print出来，怎么会出这个问题，为啥原来的没有？<br>后来分析一遍，发现区别了，原来每次找到解都要遍历完6个数，因此后面的自然变为false了，而我现在剪枝的话，前面一开始从false到true后是没有复原到false的，然后又从0-&gt;to print出来当然误以为5 6都选上了，所以解决方案<br>是只把0-&gt;from-1的根据select print出来，注意是from-1，因为sum=0 是处理0-&gt;from之后得出的和，from+1还没看，所以把上面sumx=0的for改为</p>
<pre><code><span class="keyword">for</span>(int <span class="built_in">i</span>=from-<span class="number">1</span>;<span class="built_in">i</span>&gt;=<span class="number">0</span>;<span class="built_in">i</span>--)
</code></pre><p>改成后面到前面是因为一道题目要求从大到小排序，我已开始把数组升序排了。<br>因此这是递归版剪枝的子集和问题代码，但是OJ由于时间掐的严，还是TLE了，因为递归还是很多重复调用，要改成非递归的，不过我都忘记了。。。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 23 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/22/quick-and-right-coding/">quick and right coding</a></h1>
  

      <time datetime="2014-07-22T12:25:40.000Z"><a href="/2014/07/22/quick-and-right-coding/">7月 22 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>昨天看了下邹博的PPT，邹博是负责July团队负责字符串一块的，包括Manachester算法，KMP，BP，字符串排列(其实是回溯法了)等等，<br>有一个不太重要的地方，就是邹博的代码比较短，而且看起来逻辑比较漂漂，而我的经常逻辑复杂，还写半天，还经常出bug，于是写点总结。</p>
<p>先拿最长回文子串朴素O(n^2)代码这个case来看，遍历回文串中心，我代码可能有问题，以为不需要首尾两个字符了，因为肯定是1了，但是忘记考虑偶数长回文子串了，如果后面Index=1(0-base)的没有考虑01为中心的偶长传可能就会有问题了，<br>末尾也是一样的。自己漏考虑。</p>
<pre><code><span class="keyword">int</span> maxdrome_centre(<span class="keyword">string</span> str)
{
    <span class="keyword">if</span>(str.<span class="keyword">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> maxlen=<span class="number">1</span>,<span class="keyword">max</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;str.<span class="keyword">size</span>()-<span class="number">1</span>;i++)
    {
        <span class="keyword">max</span>=<span class="number">1</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(str.<span class="keyword">size</span>()-<span class="number">1</span>)/<span class="number">2</span>;j++)<span class="comment">//two</span>
        {
            <span class="keyword">if</span>(i-j&gt;=<span class="number">0</span> &amp;&amp; i+j &lt;=str.<span class="keyword">size</span>()-<span class="number">1</span>)
            {
                <span class="keyword">if</span>(str[i-j] == str[i+j])
                    <span class="keyword">max</span>+=<span class="number">2</span>;
                <span class="keyword">else</span>
                    <span class="keyword">break</span>;
            }
            <span class="keyword">else</span>
                <span class="keyword">break</span>;
        }
        <span class="keyword">if</span>(<span class="keyword">max</span>&gt;maxlen)
            maxlen=<span class="keyword">max</span>;
        <span class="keyword">max</span>=<span class="number">1</span>;
        <span class="keyword">if</span>(str[i]==str[i+<span class="number">1</span>])
        {
            <span class="keyword">max</span>++;
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(str.<span class="keyword">size</span>()-<span class="number">2</span>)/<span class="number">2</span>;j++)
            {
                <span class="keyword">if</span>(i-j&gt;=<span class="number">0</span> &amp;&amp; i+<span class="number">1</span>+j&lt;=str.<span class="keyword">size</span>()-<span class="number">1</span> )
                {
                    <span class="keyword">if</span>(str[i-j]==str[i+<span class="number">1</span>+j])
                        <span class="keyword">max</span>+=<span class="number">2</span>;
                    <span class="keyword">else</span>
                        <span class="keyword">break</span>;
                }
                <span class="keyword">else</span>
                    <span class="keyword">break</span>;
            }
            <span class="keyword">if</span>(<span class="keyword">max</span>&gt;maxlen)
                maxlen=<span class="keyword">max</span>;
        }


    }
    <span class="keyword">return</span> maxlen;
}
</code></pre><p>看看这个代码里面，还嵌套了break，for条件判断之后，里面又判断了越界问题，其实是有重复的，for里面的条件其实没有必要，完全可以用if里面的替换掉，因为只要头尾都每越界，就可以一直两边extend，于是如果越界了，还break，如果写到for<br>条件里，刚好不用break了，里面如果长度相等就extend，没有的话break，这个是比较合理的，也需要的。而且这个max没必要每次加2，因为完全可以根据j计算出来。</p>
<p>因此代码修改后变成如下的：</p>
<pre><code><span class="keyword">int</span> maxdrome_centre(<span class="keyword">string</span> str)
{
    <span class="keyword">if</span>(str.<span class="keyword">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> maxlen=<span class="number">1</span>;<span class="comment">//total max, at least 1</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=str.<span class="keyword">size</span>()-<span class="number">1</span>;i++)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i-j&gt;=<span class="number">0</span> &amp;&amp; i+j &lt;=str.<span class="keyword">size</span>()-<span class="number">1</span>;j++)<span class="comment">//odd</span>
        {
            <span class="keyword">if</span>(str[i-j] != str[i+j])
                <span class="keyword">break</span>;
        }
        <span class="keyword">max</span>=<span class="number">2</span><span class="variable">*j</span>+<span class="number">1</span>;
        <span class="keyword">if</span>(<span class="keyword">max</span>&gt;maxlen)
            maxlen=<span class="keyword">max</span>;

        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;(i-j&gt;=<span class="number">0</span>) &amp;&amp; (i+j+<span class="number">1</span>) &lt;=str.<span class="keyword">size</span>()-<span class="number">1</span>;j++)<span class="comment">//odd</span>
        {
            <span class="keyword">if</span>(str[i-j] != str[i+j+<span class="number">1</span>])
                <span class="keyword">break</span>;
        }
        <span class="keyword">max</span>=<span class="number">2</span><span class="variable">*j</span>++<span class="number">2</span>;
        <span class="keyword">if</span>(<span class="keyword">max</span>&gt;maxlen)
            maxlen=<span class="keyword">max</span>;
    }
    <span class="keyword">return</span> maxlen;
}
</code></pre><p>这个逻辑几乎和邹博一样了，所以总结一下自己coding的一些不好的思维和设计逻辑的习惯<br>1.不要去根据不等式去计算i或者j的范围，这是计算机做的事情，例如i-j&gt;=0 i+j&lt;=str.size()-1 这个我有时候可能回想着推出i j范围，然后写在条件语句，这个其实直接写会比较好，计算机会处理好的<br>2.写逻辑语句要想清楚是否两个条件有重叠有包含关系，只要选那个更严格的条件就可以了，否则逻辑更复杂，例如我for里面先去限制j最大只能extend (n-1)/2长度，再在里面加if限制两边越界，其实越界包含了前者，<br>只需要这个条件，因此直接放到for条件里，这样少了break，还有计算长度直接有j决定，所以不需要里面每次max+2，当然这个问题会轻一点，但是没想到不应该。<br>3.另外后面偶数长度还先加if判断是否第一个成立，完全可以放到循环里面，不然逻辑复杂，易出bug，还有一个内部的max没必要，因为每次都是计算当期的与总的比较，不是两次max比较，也没想清楚。</p>
<p>总之代码写的还是naive，还是要多读别人的代码，例如fawkes，adhoc，邹博等，现在要求代码要写的快，逻辑简单清晰，精炼，越垄长的容易bug</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 22 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/22/Dijstra-proof/">Dijstra proof</a></h1>
  

      <time datetime="2014-07-22T06:44:23.000Z"><a href="/2014/07/22/Dijstra-proof/">7月 22 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>看到09CS 考研DS第一道大题，是对Dijstra的变形，问是否正确，于是回顾这一经典的greedy算法。</p>
<p>算法思想和代码之前已经联系过了，但是这道题目涉及到了正确性证明，如果变形了是否保证正确性，尽管答案只是举了一个反例来说明，但是我还是打算回顾下<br>当时的proof。其实一直都不算真正意义的理解了。</p>
<p>利用数学归纳的思想：</p>
<p>集合分为close-set表示，已经算出最短路径的点击，open-set为剩余的点击。</p>
<p>1(初始条件). 一开始肯定是source点u了，因为dist为0，不可能有比他更短的了。假设第二个点p，现在证明p一定是u-&gt;p为p的最短路径。<br>假设不是，假设存在open-set点x，使得u-&gt;x x-&gt;p为最短路径，那么u-&gt;x一定比u-&gt;p短(边&gt;0的性质)，x应该比p先加入close-set，与一直矛盾</p>
<p>2(递推证明).加入当前close-set有些点，那么现在加入p，那么u-&gt;p的最短路径的点一定都在close-set里。<br>假设不是，假设路径出现了一个点x在opens-set(假设只是路径最后一个点在open-set,其他情况是转化为这个的吧),那么u-&gt;x x-&gt;p比u-&gt;p(中间全是close-set中点)要短，那么u-&gt;x比u-&gt;p短，x应该比p先加入close-set，<br>产生矛盾。</p>
<p>思路来源这里<br><a href="http://blog.csdn.net/dog250/article/details/5303310" target="_blank" rel="external">http://blog.csdn.net/dog250/article/details/5303310</a> </p>
<p>另外还附上一个童鞋另一种思维方式的理解正确性 <a href="http://my.oschina.net/mustang/blog/56216" target="_blank" rel="external">http://my.oschina.net/mustang/blog/56216</a></p>
<p>当年算法书的证明感觉不make sense，所以弃掉了。</p>
<p>另外今天看到了一个priority_queue 也是在<queue>里面的，都是单向队列，只是加了优先级排序。</queue></p>
<p><dequeu> 则是双向队列，两边都可以插和删，</dequeu></p>
<p>STL与堆相关的主要是 make_heap push_heap, pop_heap 这样一些algorithm里的函数，用vector容器来装，可以实现heap</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 22 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/22/CockTailSort/">CockTailSort</a></h1>
  

      <time datetime="2014-07-21T16:11:47.000Z"><a href="/2014/07/22/CockTailSort/">7月 22 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>今天看到鸡尾酒排序，看名字就像了解下，之前好像有稍微听过，但是具体不知道是啥。</p>
<p>是冒泡排序的改进版，原来每次冒最大(小)到最后面，现在两端来回冒，这样有啥好处呢？<br>例如 23451这样的 只要一来一回就排好了，但是bubblesort却要很多次。</p>
<p>所以写算法，感觉是n/2个来回，n为偶正好冒完所有，n为奇，除掉中间的元素，最后肯定也是定好位置的，因为其他n-1个元素都订好位置了。<br>另外和bubblesort一样，加swap flag，如果一来或者一回没有交换，那么就排好序了，调用C++11的swap函数。</p>
<p>后来看了下wikipedia的，感觉实现不太一样，他是直接用swap就来判断外部循环，思路也是一致，每个来回长度都要缩减2，</p>
<pre><code><span class="keyword">void</span> CockTailSort(<span class="keyword">int</span>*a, <span class="keyword">int</span> n)
{
    <span class="keyword">bool</span> isswap;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)
    {
        isswap=<span class="keyword">false</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&lt;=n-i-<span class="number">1</span>;j++)
        {
            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])
                swap(a[j],a[j+<span class="number">1</span>]),isswap=<span class="keyword">true</span>;

        }
        <span class="keyword">if</span>(isswap==<span class="keyword">false</span>) <span class="keyword">break</span>;
        isswap=<span class="keyword">false</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> j=n-i-<span class="number">1</span>;j&gt;=i;j--)
        {
            <span class="keyword">if</span>(a[j-<span class="number">1</span>]&gt;a[j])
                swap(a[j],a[j-<span class="number">1</span>]),isswap=<span class="keyword">true</span>;
        }
        <span class="keyword">if</span>(isswap==<span class="keyword">false</span>) <span class="keyword">break</span>;
    }
}
</code></pre>
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 22 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/21/trim-variant-c-cpp-string/">trim variant c cpp string</a></h1>
  

      <time datetime="2014-07-21T12:33:56.000Z"><a href="/2014/07/21/trim-variant-c-cpp-string/">7月 21 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>实现trim的variant，将多个空格变为1个。但是逻辑似乎对我来说短时间不简单啊。</p>
<p>我开始尝试的是C++字符串，一个istringstream搞定，但是其实也会有问题，后来发现要试试C的，不然有点像调用了一个库或者class的感觉。</p>
<pre><code><span class="keyword">char</span> * trim(<span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">int</span> i=<span class="number">0</span>;
    <span class="keyword">int</span> len=strlen(<span class="keyword">str</span>),startpos;
    <span class="keyword">char</span>* a=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];

    <span class="keyword">int</span> offset=<span class="number">0</span>;
    <span class="keyword">while</span>(i&lt;len)
    {
        startpos=i;
        <span class="keyword">while</span>(i&lt;len&amp;&amp;<span class="keyword">str</span>[i]!=<span class="string">' '</span>)
            i++;
        <span class="keyword">if</span>(i==len) <span class="keyword">break</span>;
        <span class="keyword">for</span>(j=startpos;j&lt;i;j++)
        {
            a[offset]=<span class="keyword">str</span>[j];
            offset++;
        }
        a[offset]=<span class="string">' '</span>;
        offset++;

        <span class="keyword">while</span>(i&lt;len&amp;&amp;<span class="keyword">str</span>[i]==<span class="string">' '</span>)
            i++;
    }
    a[offset]=<span class="string">'\0'</span>;
    strcpy(<span class="keyword">str</span>,a);
    delete[] a;
    <span class="keyword">return</span> <span class="keyword">str</span>;
}
</code></pre><p>上面代码有点问题的，break早了，最后一个非空格的串还没copy过去，另外改成strncpy，提高可读性</p>
<pre><code><span class="keyword">char</span> * trim_new(<span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">int</span> i=<span class="number">0</span>,j;
    <span class="keyword">int</span> len=strlen(<span class="keyword">str</span>),startpos;
    <span class="keyword">char</span>* a=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];

    <span class="keyword">int</span> offset=<span class="number">0</span>;
    <span class="keyword">while</span>(i&lt;len)
    {
        startpos=i;
        <span class="keyword">while</span>(i&lt;len&amp;&amp;<span class="keyword">str</span>[i]!=<span class="string">' '</span>)
            i++;
        strncpy(a+offset,<span class="keyword">str</span>+startpos,i-startpos);
        <span class="comment">/*
        for(j=startpos;j&lt;i;j++)
        {
            a[offset]=str[j];
            offset++;
        }
        */</span>
        offset+=i-startpos;
        <span class="keyword">if</span>(i==len) <span class="keyword">break</span>;
        a[offset]=<span class="string">' '</span>;
        offset++;

        <span class="keyword">while</span>(i&lt;len&amp;&amp;<span class="keyword">str</span>[i]==<span class="string">' '</span>)
            i++;
    }
    a[offset]=<span class="string">'\0'</span>;
    strcpy(<span class="keyword">str</span>,a);
    delete[] a;
    <span class="keyword">return</span> <span class="keyword">str</span>;
}    
</code></pre><p>我已开始犯了一个严重，但是我一直因为没弄清楚字符数组，字符串的区别导致的，上一篇总结好了。我用char a[]=”” 最后return a, 发现其实返回之后这块地址因为是栈的被销毁了，所以挂了。。。。<br>于是改成堆，但是又要释放空间这样比较好，然后只能拷贝回str，而且逻辑似乎不好，好不如直接在源串上改。</p>
<p>于是有了下面两个指针的代码，i指向当前处理好的字符串后一个位置，j指向后面待处理的字符串，记得开始记录startpos，所以是[startpos,j) copy回 i开始的位置，里面有个地方容易忽视，就是如果最后面是非空格的一串，后面要避免被赋上空格，或者直接break返回<br>也可以的，不break也可以因为后面condition控制好了越界的情况。</p>
<pre><code><span class="keyword">char</span> *trim(<span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">int</span> len=strlen(<span class="keyword">str</span>);

    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,startpos;
    <span class="keyword">while</span>(j&lt;len)
    {
        startpos=j;
        <span class="keyword">while</span>(j&lt;len &amp;&amp; <span class="keyword">str</span>[j]!=<span class="string">' '</span>)
            j++;
        strncpy(<span class="keyword">str</span>+i,<span class="keyword">str</span>+startpos, j-startpos);

        i+=j-startpos;

        <span class="keyword">if</span>(j&lt;len)<span class="comment">//no more space add</span>
        {
            <span class="keyword">str</span>[i]=<span class="string">' '</span>;
            i++;
        }


        <span class="keyword">while</span>(j&lt;len &amp;&amp; <span class="keyword">str</span>[j]==<span class="string">' '</span>)
            j++;
    }
    <span class="keyword">str</span>[i]=<span class="string">'\0'</span>;

    <span class="keyword">return</span> <span class="keyword">str</span>;
}
</code></pre><p>另外还有一个简单的C++ istringstream版的，但是好像有问题，例如开头一串空格的一个空格就丢了，因为里面封装了太多了，改起来不易。。。</p>
<pre><code><span class="keyword">char</span> *trim(<span class="keyword">char</span> *<span class="keyword">str</span>)
{
    string strcpp=<span class="keyword">str</span>;
    istringstream istr(<span class="keyword">str</span>);
    istr&gt;&gt;outstr;
    <span class="keyword">while</span>(istr&gt;&gt;split)
        outstr+=<span class="string">" "</span>+split;


    strcpy(<span class="keyword">str</span>,outstr.c_str());

    <span class="keyword">return</span> <span class="keyword">str</span>;
}
</code></pre>
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 21 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/2/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/4/" class="alignright next">下一页</a>
  
</nav></div>
    </div>
    <div class="tabbar" onload="divideTabBar()">
	
      <div class="tabbaritem"><a class="next" href="/">Home</a></div>
    
      <div class="tabbaritem"><a class="next" href="/archives/">Archives</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a></div>
    
</div>


  </div>
</body>
</html>