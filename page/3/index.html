<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 3 页 | Richard</title>
  <meta name="author" content="Richard">
  
  <meta name="description" content="理查德爱闹">
  
  
  
  <meta property="og:site_name" content="Richard"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta property="og:image" content="undefined"/>
  
   <link rel="apple-touch-icon" href="/icon.png" />
   <link rel="shortcut icon" href="/favicon.png" >
   <link rel="alternate" href="http://xxx.xx/atom.xml" title="Richard" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
</head>


<body>
  <div id="content" class="inner">
    <aside id="sidebar" class="alignleft">
      <div class="navigationBar">
        <a href="/">Richard</a>
      </div>
    	
  <nav class="widget" id="menu">
	<ul>
    
      <li class="cell"><a class="next" href="/">Home</a><li>
    
      <li class="cell"><a class="next" href="/archives/">Archives</a><li>
    
      <li class="cell"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a><li>
    
      <li class="cell"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a><li>
    
      <li class="cell"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a><li>
    
    </ul>
</nav>

  <div class="widget weibo">
  <iframe width="100%" height="750" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=750&fansRow=2&ptype=1&speed=0&skin=6&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2689136623&verifier=c139aa37&dpc=1"></iframe>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/DFS/">DFS</a><small>1</small></li>
  
    <li><a href="/categories/DP/">DP</a><small>1</small></li>
  
    <li><a href="/categories/Recursive/">Recursive</a><small>1</small></li>
  
    <li><a href="/categories/algorithm/">algorithm</a><small>7</small></li>
  
    <li><a href="/categories/binary-search/">binary search</a><small>2</small></li>
  
    <li><a href="/categories/binary-tree/">binary tree</a><small>3</small></li>
  
    <li><a href="/categories/bit/">bit</a><small>1</small></li>
  
    <li><a href="/categories/bit-operation/">bit operation</a><small>2</small></li>
  
    <li><a href="/categories/blog/">blog</a><small>1</small></li>
  
    <li><a href="/categories/cpp/">cpp</a><small>9</small></li>
  
    <li><a href="/categories/cpp-string/">cpp string</a><small>1</small></li>
  
    <li><a href="/categories/data-structure/">data structure</a><small>2</small></li>
  
    <li><a href="/categories/dfs/">dfs</a><small>1</small></li>
  
    <li><a href="/categories/dp/">dp</a><small>2</small></li>
  
    <li><a href="/categories/ds/">ds</a><small>1</small></li>
  
    <li><a href="/categories/hash/">hash</a><small>1</small></li>
  
    <li><a href="/categories/hexo-configuration/">hexo configuration</a><small>1</small></li>
  
    <li><a href="/categories/hihocode/">hihocode</a><small>1</small></li>
  
    <li><a href="/categories/kmp/">kmp</a><small>1</small></li>
  
    <li><a href="/categories/linklist/">linklist</a><small>4</small></li>
  
    <li><a href="/categories/permutation/">permutation</a><small>2</small></li>
  
    <li><a href="/categories/quick-and-right-coding/">quick and right coding</a><small>1</small></li>
  
    <li><a href="/categories/web/">web</a><small>2</small></li>
  
    <li><a href="/categories/数字规律/">数字规律</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/BT/" style="font-size: 10.00px;">BT</a><a href="/tags/Backtrack/" style="font-size: 10.00px;">Backtrack</a><a href="/tags/Combinations/" style="font-size: 10.00px;">Combinations</a><a href="/tags/DP/" style="font-size: 10.00px;">DP</a><a href="/tags/Order/" style="font-size: 10.00px;">Order</a><a href="/tags/Permutation/" style="font-size: 10.00px;">Permutation</a><a href="/tags/algorithm/" style="font-size: 20.00px;">algorithm</a><a href="/tags/array/" style="font-size: 15.00px;">array</a><a href="/tags/backtrack/" style="font-size: 10.00px;">backtrack</a><a href="/tags/binary-search/" style="font-size: 12.50px;">binary search</a><a href="/tags/bit/" style="font-size: 15.00px;">bit</a><a href="/tags/brute-force/" style="font-size: 12.50px;">brute force</a><a href="/tags/c/" style="font-size: 10.00px;">c</a><a href="/tags/char/" style="font-size: 10.00px;">char*</a><a href="/tags/coding/" style="font-size: 10.00px;">coding</a><a href="/tags/complement/" style="font-size: 10.00px;">complement</a><a href="/tags/complex/" style="font-size: 12.50px;">complex</a><a href="/tags/complex-condition-analysis/" style="font-size: 10.00px;">complex condition analysis</a><a href="/tags/configuire/" style="font-size: 10.00px;">configuire</a><a href="/tags/convert/" style="font-size: 10.00px;">convert</a><a href="/tags/cpp/" style="font-size: 15.00px;">cpp</a><a href="/tags/cpp，inheritance/" style="font-size: 10.00px;">cpp，inheritance</a><a href="/tags/cycle/" style="font-size: 10.00px;">cycle</a><a href="/tags/data-structure/" style="font-size: 17.50px;">data structure</a><a href="/tags/data-type/" style="font-size: 12.50px;">data type</a><a href="/tags/digit/" style="font-size: 10.00px;">digit</a><a href="/tags/divide/" style="font-size: 10.00px;">divide</a><a href="/tags/divide-2/" style="font-size: 10.00px;">divide 2</a><a href="/tags/domain/" style="font-size: 10.00px;">domain</a><a href="/tags/dp/" style="font-size: 15.00px;">dp</a><a href="/tags/find/" style="font-size: 10.00px;">find</a><a href="/tags/finding-rule/" style="font-size: 10.00px;">finding rule</a><a href="/tags/git/" style="font-size: 10.00px;">git</a><a href="/tags/github/" style="font-size: 10.00px;">github</a><a href="/tags/graph/" style="font-size: 10.00px;">graph</a><a href="/tags/greedy/" style="font-size: 10.00px;">greedy</a><a href="/tags/hash/" style="font-size: 10.00px;">hash</a><a href="/tags/head-process/" style="font-size: 10.00px;">head process</a><a href="/tags/hexo/" style="font-size: 12.50px;">hexo</a><a href="/tags/initial/" style="font-size: 10.00px;">initial</a>
  </div>
</div>


    	<footer id="footer" class="inner"><div class="copyright">
  
  &copy; 2014 Richard
  
</div>



</footer>
    </aside>
    
    
    <div id="hidden-navigationBar" class="navigationBar">
      <a href="/">Richard</a>
    </div>
    <div id="main-col" class="alignright">
    <div id="wrapper">
      
  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/21/c-cpp-convert,-char-char-a[]/"></a></h1>
  

      <time datetime="2014-07-21T11:57:22.000Z"><a href="/2014/07/21/c-cpp-convert,-char-char-a[]/">7月 21 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>title: ‘c cpp convert, char char a’<br>date: 2014-07-21 19:57:22<br>categories：cpp</p>
<h2 id="tags:_[char,_c,_cpp]">tags: [char, c, cpp]</h2>
<p>对于这一块，fawks大神毫无疑问已经到了一个境界了，我还是个学习的菜鸟。</p>
<p>我当时学的时候，就觉得里面的语法太复杂了，而且各种陷阱，一不小心就掉到坑里去了。。。</p>
<p>先来两个case：</p>
<pre><code><span class="keyword">char</span>* <span class="operator">a</span>=<span class="string">"fawks"</span>
<span class="keyword">char</span> <span class="operator">a</span>[]=<span class="string">"fawks"</span>
</code></pre><p>下面本文从几个方面来比较区别</p>
<ol>
<li><p>两个的是前者a是字符串指针，后者a是字符数组。具体的来说，两者都会在常量区(常量区，堆，栈(通常说的堆栈), 全局\静态存储区)申请一个空间存放fawks这个字符串，<br>然后前者在栈申请一个空间存放字符串指针a，*86 占4B，值为这块常量区的首地址，但是如果cout&lt;&lt;a的时候又会输出这个字符串，而不会输出a的地址，之前李青老师的书记得写过，这是<br>C++的智能处理，包括输出字符数组首地址也是自动输出字符串内容。后者则是将常量区字符串copy到一个栈，然后首地址就是a的地址，这个是字符数组。并且要注意前者最好是写成</p>
<p> const char*a =”fawks”</p>
</li>
</ol>
<p>因为不能通过a来修改字符串所在常量区的值，所以const会比较安全，但是后面修改a的指向又是可以的。</p>
<ol>
<li><p>后面继续赋值：</p>
<p> a=”zrc”</p>
</li>
</ol>
<p>这句话对于前者是可以的，因为把栈中指针a的值改为zrc的地址，a指向了常量区另一个区域zrc的首地址，而后者是不可以的，因为a已经固定下来了指向一个栈中fawks的首地址，字符数组只能初始化不能赋值。</p>
<ol>
<li>另外还有一个区别要注意<br> sizeof(a);</li>
</ol>
<p>这句话对于前者输出4(*86),因为这个指针占得空间是4个字节，因为32bit地址，8bit占一个Byte，如果字节寻址的话(一般这么理解)，所以占4个存储单元。而后者则是输出5，注意与strlen(a)的区别，<br>因为sizeof()是看占得内存空间大小，所以包含结束符\0(ASCII 0)， strlen是字符串长度，不包含结束符。</p>
<p>4.所以如果函数返回一个char<em>, 如果你定义的char a[]=””, 然后return a就会挂，虽然过程是先返回了a指向的地址，然后再结束函数，但是这块是栈空间，函数结束就销毁了这块栈，所以位置是野值。。。<br>而后者是字符串存在常量去，随着程序开始就在那直到程序结束，所以char</em>a =””, return a完全没问题，而且函数先返回，后销毁栈变量也保证了他的正确性，a是栈中的一个指针变量。</p>
<ol>
<li>数组(char a[])可以转化为指针(char* a)，指向字符串的指针，但是指针未必可以转为数组，因为如果指向字符串常量的话，那么就不能作为数组了，因为没法修改它们的值。</li>
</ol>
<p>另外要注意字符串常量如果赋值(不是初始化)给char* 可能有警告，例如</p>
<pre><code><span class="keyword">char</span> *s;
s=<span class="string">"hello"</span>;
</code></pre><p>但是char* s=”hello” 是可以的，其实还是加个const安全些。附上</p>
<pre><code>string <span class="keyword">str</span>=(<span class="keyword">char</span>*)s;
<span class="keyword">char</span> *s=<span class="keyword">str</span>.c_str();
</code></pre><p>上面一句可以，二句不可以的，因为c_str()返回const char<em> ,不可以const char</em> 赋给char*, 但是反过来可以，我付给一个保证不修改内容的指针的嘛</p>
<pre><code><span class="keyword">const</span> <span class="built_in">char</span>* s=(<span class="built_in">char</span>*)<span class="built_in">cstr</span>;
</code></pre><p>引用 <a href="http://www.zhihu.com/question/20779337" target="_blank" rel="external">http://www.zhihu.com/question/20779337</a><br><a href="http://blog.csdn.net/hackbuteer1/article/details/6706562" target="_blank" rel="external">http://blog.csdn.net/hackbuteer1/article/details/6706562</a></p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 21 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/21/c-cpp-string-in-out-summary/"></a></h1>
  

      <time datetime="2014-07-21T09:39:28.000Z"><a href="/2014/07/21/c-cpp-string-in-out-summary/">7月 21 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>title: ‘c cpp string in out summary’<br>date: 2014-07-21 17:39:28<br>categories: cpp</p>
<h2 id="tags:[c,_cpp,_string]">tags:[c, cpp, string]</h2>
<p>比较熟悉的大神可以飘过了。。。之前对于C C++ string char* 尤其是输入的一堆东西弄得晕头转向，主要是用getline 输入string来处理，但是<br>如果让写C风格的，可能我就挂了。。。</p>
<p>getline(istream&amp; istr, string str, delim)//一般是用这个来输入字符串的</p>
<p>后来看到一个很像的cin.getline(char* str, delim=’\n’), 如果是读一行，还是建议写\n吧，默认参数这么多指不定那条搞晕了= =  如果是写C++，尽量用前者好像</p>
<p>于是后面有出来了 gets fgets scanf(), 这么一堆输入char<em>的函数，gets网上说是不安全的，因为没有设置输入缓存区，有溢出的风险，尽量<br>用fgets去代替，但是谁知道呢：<br>fgets(char </em>str, int num, FILE<em> stream),当然File</em> 也可以传入stdin来表示从标准输入，有点奇怪，后来查了才知道stdin就是File*类型的。<br>但是我后来漏看了cplusplus文档，有个重要的漏了，就是fgets如果输入的最后有个\n,最后读到str里面的字符串也会加一个\n,这不得不说是个巨大的隐患，还是应该相信fawks大神的，<br>用gets，先不管隐患，至少目前编的代码还不会有溢出的隐患。</p>
<p>cin&gt;&gt;输入的话，默认delim 是 space \t 和\n,这个要记住，因为没有参数的，所以数字由于中间不可能有这些delim，可以安全用，但是字符串不是通过<br>这些delim来区分的，所以完全可能中间有这些字符，用cin就悲剧了，cplusplus官网也说cin是notorious的，</p>
<p>scanf() ACMer C C++混编混C的部分主要是由于C++流输入输出比较慢，采用C的函数直接把输入写到内存地址处来提高效率。<br>scanf(“%d”, &amp;x);记住这个是输入地址，和printf只需要print值不一样</p>
<p>另外要特别留意输入int之后的string，如果敲回车的话，因为fgets gets getline cin.getline 这一系列输入字符串都是默认\n结束的，而如果前面整数是敲回车结束的(多数是这样的)，那么<br>后面输入字符串的就是空串，因为\n还留在输入缓冲区里，那么这些读取直到\n就相当于读了空串了，所以最好之前再读取一次把空串读掉，其实scanf cin都会存在这个问题。</p>
<p>总结下来tips就是，输入C字符串用gets可以不指定长度，感觉似乎方便，如果不写大的项目，隐患也还好，fgets需要指定长度和源stdin，可能麻烦点，也可以用cin.getline,而且这个优点在于还有<br>delim参数，因此如果有其他要求的话可能只能用cin.getline了。</p>
<p>C++字符串必须是getline(cin,str,delim=’\n’),输入字符串特别当心前面有int输入的时候，是否留了一个\n在缓冲区里，之前还有做法是cin.clear来清空。<br>另外stdin和cin是同步的，cin是C++的，但是好像stdin好像是标准输入，默认是键盘，如果需要freopen重定向的时候，一般都用stdin</p>
<p>基本delim默认都是\n, 例如getline(string::getline), cin.getline(istream::getline), cin是空格，\t \n来区分整数或者字符串的，用在字符串可能就挂了。</p>
<p>特别注意cin.getline(char*str, int num, delim=’\n’) 里面的num是指包含结束符的</p>
<p>另外今天看到一个代码还是不清楚为啥</p>
<pre><code><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="keyword">int</span> main()
{
    <span class="keyword">char</span> str[<span class="number">8</span>];
    <span class="built_in">cin</span>.getline(str, <span class="number">5</span>);
    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;endl;
    <span class="built_in">cin</span>.getline(str, <span class="number">5</span>);
    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;endl;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>代码来自 <a href="http://www.cnblogs.com/A-Song/archive/2012/01/29/2331204.html" target="_blank" rel="external">http://www.cnblogs.com/A-Song/archive/2012/01/29/2331204.html</a> 对notorious的cin进行了一番批评似乎</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 21 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/20/back-k-node-in-linklist/">back k node in linklist</a></h1>
  

      <time datetime="2014-07-20T15:37:33.000Z"><a href="/2014/07/20/back-k-node-in-linklist/">7月 20 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>今天偶然看到09CS考研题，DS的最后一题，之前肯定是做过的，但是今天看到又忘记了，面试问到估计后悔死了。。。</p>
<p>求链表倒数第k个结点，k&gt;=1, 这种题时属于另一类，并不会渐进意义上降低时间复杂度，但是可以减少比较次数，其实当数据量打上去之后，也会有明显的提升。<br>我还是想到最朴素的遍历一遍求长度，然后在便利到l-k+1个。</p>
<p>后来看到答案，设置两个指针，一开始就间隔k一直移后指针到尾，直接返回前一指针就可以啦。我愣是没想起来。<br>相比之前的算法，我感觉指针移动的次数是一样的，只是不需要记录链表长度这样一个变量而已啦，都是移动l+l-k次指针吧，但是舆论还是觉得后面的算法要好，感觉高端点么。。。所谓的逼格高。。。</p>
<p>于是总结链表经典题目的解法好像很多都是用多个指针，我当时都没想到多用几个指针，然后要么是快慢指针(每次移动的速度恒定，且不一样)，要么是interval 指针，始终保持<br>k的距离，感觉这几种思路都是这样，还有逆置链表是三个指针，prev，p, pnext这三个。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 20 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/20/数组跳跃遍历减少比较次数/">数组跳跃遍历减少比较次数</a></h1>
  

      <time datetime="2014-07-20T14:59:30.000Z"><a href="/2014/07/20/数组跳跃遍历减少比较次数/">7月 20 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>这道题目找了一个同学一起想，后来发现题目是野路子来的，最后题目意思理解除了偏差，衰。。。。再次表示诚挚的抱歉，是我错了。。。不过正好拓宽了思路，也把另一种问法解决了</p>
<p>原题描述：<br>在相邻元素相差1的数组中查找某一特定元素第一次出现的位置(非遍历)</p>
<p>通过各种渠道传到我这里，就变成了：<br>数组A中任意两个相邻元素大小相差1，现给定这样的数组A和目标整数t，找出t在数组A中的位置。</p>
<p>我想先自己思考，于是也没细究题目，认为题目是指找出所有的t的index出来，如果元素不重复的话，那就太简单了，直接定位i=|t-a[0]|，如果是的话返回index，不是的话，直接退出循环说找不到了。<br>我已开始以为这个是在时间复杂度渐进意义上要从线性减少，首先想到的是对数，但是感觉又想不到对数复杂度的算法。</p>
<p>思考这种题目，感觉就是需要归纳一些性质出来，提高效率，不论能够降低时间复杂度，都至少可以减少次数吧。</p>
<p>性质1：如果两个元素a[i] a[j]的差和index差相等，那么之间的元素一定是从(a[i],a[j])之间逐个递增或递减，也即不可能出现等于a[i]或a[j]</p>
<p>性质2：相邻2个元素一定是奇偶性相反，所以如果当前t和i同奇偶性,则解不可能是i-1 i+1的话，也一定只可能是i+2，不可能是i+1, i+3,</p>
<p>所以针对这些性质，如果对于问题输出所有t的index的话，我有了下面的代码：</p>
<pre><code>void FindXIndex(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> <span class="keyword">x</span>)
{
    <span class="keyword">int</span> xi,j,tmp;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)
    {
        <span class="keyword">if</span>(a[i]==<span class="keyword">x</span>)
        {
            xi=i;
            <span class="keyword">break</span>;
        }
    }
    <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span> "</span>, xi);
    <span class="keyword">while</span>(<span class="keyword">abs</span>(j-xi)&gt;=<span class="number">2</span>)
    {
        <span class="keyword">if</span>(<span class="keyword">abs</span>(a[j]-a[xi])==<span class="keyword">abs</span>(j-xi))
            <span class="keyword">break</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(a[j]==<span class="keyword">x</span>)
        {
            <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span> "</span>, j);
            <span class="keyword">if</span>(xi&lt;j)
            {
                tmp=xi, xi=j, j=tmp+<span class="number">1</span>;
            }
            <span class="keyword">else</span>
            {
                tmp=xi, xi=j, j=tmp-<span class="number">1</span>;
            }
        }
        <span class="keyword">else</span> 
        {
            <span class="keyword">if</span>(xi&lt;j) j--;
            <span class="keyword">else</span> j++;
        }
    }
    <span class="keyword">return</span>;
}
</code></pre><p>先从找到一个t的index，然后从另一端向这段搜索，如果存在差值等于index差值，则直接返回，因为中间不可能还有t了，也即区间收缩到0了。所以循环的条件是区间长度是否大于1，如果等于1的话也不用了，只有一个元素，必为已经搜过的xi，<br>且程序里a[xi]=t的。然后j始终从当前值向xi靠近，注意根据和xi大小关系，判断++ 还是 —</p>
<p>这个算法是输出所有的index，后来看了下题目，原始不需要全部，好吧，自己做了一道新题。。。。</p>
<p>如果是只要返回任意一个，当然效率尽可能高，也即如何最快找到t的一个index，可以先从一端开始，例如0，先和a[0]比较，|t-a[0]|+0,是可能的t的位置，而且从(0 , |t-a[0]|+0)之间 是不可能出现解的，因为最快的增长(下降)速度才能使得边界达到t，<br>如果t=a[0]的话，0也可能, 所以第一步就大胆往前跳，同时第一步跳到的一定是奇偶性和t一致的点，所以改点两边的点和t奇偶性反，不可能是解，于是乎可以大胆的两步一跳。</p>
<pre><code><span class="keyword">int</span> findpos(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> v)  
{  
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">abs</span>(v-a[<span class="number">0</span>]); i &lt; n; i+=<span class="number">2</span>)  
        <span class="keyword">if</span>(a[i] == v)  
            <span class="keyword">return</span> i;  
    <span class="keyword">return</span> -<span class="number">1</span>;  
}
</code></pre><p>代码来自：<a href="http://blog.csdn.net/u010590166/article/details/17250653#cpp" target="_blank" rel="external">http://blog.csdn.net/u010590166/article/details/17250653#cpp</a><br>后来发现这个其实还不够优，看到下面童鞋的代码，好像更优<br><a href="http://m.blog.csdn.net/blog/pein0119/11678997" target="_blank" rel="external">http://m.blog.csdn.net/blog/pein0119/11678997</a><br>不止是第一步跳跃，而是每次都是跳跃前进，直到找到或者遍历完位置，</p>
<pre><code><span class="built_in">i</span>=<span class="built_in">abs</span>(a<span class="matrix">[i]</span>-t);
</code></pre><p>通过这句代码来实现的。</p>
<p>另外再加深一下印象，C语言的scanf 后面参数是地址， printf后面是变量，为什么是这样呢？思考一下原因更容易记住用法，因为输入是要把变量从键盘输到内存某个地址去，自然需要地址了，而打印只需要这个值传过来就行了，例如输出缓冲区，<br>实际上C++已经封装好了一切，所以不需要我们考虑，一律都是变量名了。C语言会更底层一些。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 20 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/20/Difference-between-MSVC-and-gcc/">Difference between MSVC and gcc</a></h1>
  

      <time datetime="2014-07-20T07:37:35.000Z"><a href="/2014/07/20/Difference-between-MSVC-and-gcc/">7月 20 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>最近发现VS2010(MSVC系列编译器)， 和GCC比要弱很多，有些方便程序员的语法在GCC可以完美支持，到了VS就不行了，例如下面的代码：</p>
<pre><code><span class="keyword">double</span> findMedianSortedArrays(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n) 
{
    <span class="keyword">if</span>(m+n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span>(m+n==<span class="number">1</span>)
    {
        <span class="keyword">if</span>(m==<span class="number">0</span>)
            <span class="keyword">return</span> B[<span class="number">0</span>];
        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>)
            <span class="keyword">return</span> A[<span class="number">0</span>];
    }
    <span class="keyword">int</span> C[m+n];
    <span class="comment">//vector&lt;int&gt; C(100);</span>
    merge(A,A+m,B,A+n,C);
    <span class="keyword">int</span> mid=<span class="number">0</span>+(m+n-<span class="number">1</span>)/<span class="number">2</span>;
    <span class="keyword">if</span>((m+n)%<span class="number">2</span>==<span class="number">1</span>)
        <span class="keyword">return</span> C[mid];
    <span class="keyword">else</span>
    {
        <span class="keyword">return</span> <span class="keyword">double</span>(C[mid]+C[mid+<span class="number">1</span>])/<span class="number">2</span>;
    }

}

<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> a[]={}, b[]={<span class="number">2</span>,<span class="number">3</span>};
    <span class="built_in">cout</span>&lt;&lt;findMedianSortedArrays(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>),b,<span class="keyword">sizeof</span>(b)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))&lt;&lt;endl;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>我最近发现cplusplus站点有个很好的类似于脚本语言立马知道函数或者语法正确性的一个site，点击example代码右侧的edit run，可以直接在web里面<br>emulate cpp的执行，而且我也突然体会到为啥大家喜欢用脚本语言了，因为有个解释器，而不是编译器，不确定函数或者定义正确否，到解释器里一试便知，<br>只可惜之前最熟悉的脚本语言是几乎只被researcher玩的matlab= =，工业界几乎不用。。。。之前偶然看到某大神说的，python库按照比较方便，库也越来越多了，<br>如果不确定可以到解释器里试，我还是因为来一来debugger，觉得python不方便debug而一直没有上手，现在知道自己错了，python打法好，退*保平安！</p>
<p>回到正题，上面几处是符合GCC标准的，例如编译变长，执行定长的数组定义，int C[m+n]; 当时刚学C++发现了这个在VS中不允许的语法。</p>
<p>另外还有空数组 GCC允许，VS不允许int a[]={}，于是我在VS里写了代码，拿G++编译的= =，G++是包含GCC的一个编译器，多出一些C++的语法编译，G++ GCC对待<br>.c .cpp这四种组合，只有gcc 对.c 是当成C编译的，其他除非写个extern “C” 否则都是当CPP，默认是C98(C03和C98差别非常小，几乎当成一样，虽然是随后对C98的<br>小的修改)， 加上-std=c++0x, 是C++11， 可以用很多STL里面新的东西，例如unordered_*之类的。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 20 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/19/BinarySearch-and-its-variant/">BinarySearch and its variant</a></h1>
  

      <time datetime="2014-07-19T15:55:22.000Z"><a href="/2014/07/19/BinarySearch-and-its-variant/">7月 19 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>今天看到一道有点需要借助二分的一道leetcode题，于是想起当时编程之美(Beauty Of Programming)还有一系列课后题还没搞定，加之之前不经意见问了下高富帅思路，突然有了一些感觉，于是把这些题目都做一做，都是BinarySearch的一些变形。</p>
<p>今天博客看到比我这个变种还多的大神，实在是膜拜啊，<a href="http://blog.csdn.net/luckyxiaoqiang/article/details/8937978" target="_blank" rel="external">http://blog.csdn.net/luckyxiaoqiang/article/details/8937978</a></p>
<ol>
<li>正常BinarySearch<br>这个是基本的二分，之前还阅读编程珠玑(Progamming Pearls)证明过,注意low&lt;=high, 后面就是正常的high=mid-1, low&lt;high, 后面就是high=mid, 那些proof感觉不实用，难道写了代码，还花那么多时间去找一个assertion去proof它的correctness么？<br>因此我总结了一个方法，就是看是否每个分支是否会至少减小search size 1个大小(除掉return)，如果每次都减，一定不会死循环，因为size大小固定，&lt;0就exit loop了。关键就是mid=(low+high)/2这个语句了，因为奇数除会丢精度，<br>由于bit right shift的原因，所以这个是是否reduce size的关键。这个，我猜也是为啥46年就提出了BS的思想，但是62年才有第一个正确的algorithm吧。</li>
</ol>
<ol>
<li>find max i, arr[i]=x<br>这个是受高富帅点播的，如果找到相等了，low=mid, 包含当前元素向高区间找，然后如果区间size=1就返回这个mid，否则low=mid.但是一个样例测发现死循环了，后来分析发现了当时size=2,low+1=high, mid=(low+high)/2=low, 所以low=mid赋值就原地不动<br>，size不变，于是死循环了，所以两个element时候，特别处理，直接看a[low] a[high] 就行了，如果a[high]==x 就是high了，否则就是low了。</li>
</ol>
<p>代码如下：</p>
<pre><code><span class="keyword">int</span> BS_MaxiEqualX(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> x)
{
    <span class="keyword">int</span> low=<span class="number">0</span>,high=n-<span class="number">1</span>;
    <span class="keyword">while</span>(low&lt;=high)
    {
        <span class="keyword">int</span> mid=low+(high-low)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[mid]&lt;x)
            low=mid+<span class="number">1</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;a[mid])
            high=mid-<span class="number">1</span>;
        <span class="keyword">else</span>
        {
            <span class="keyword">if</span>(low==high)<span class="comment">//1 element</span>
                <span class="keyword">return</span> mid;
            <span class="keyword">else</span><span class="comment">//include mid, to higher part</span>
            {
                <span class="keyword">if</span>(low&lt;mid)<span class="comment">//&gt;=3 element</span>
                    low=mid;
                <span class="keyword">else</span><span class="comment">//low==mid, high=low+1,2 element</span>
                {
                    <span class="keyword">if</span>(a[high]==x)
                        <span class="keyword">return</span> high;
                    <span class="keyword">else</span> <span class="keyword">if</span>(a[low]==x)
                        <span class="keyword">return</span> low;
                }
            }
        }
    }
    <span class="keyword">return</span> -<span class="number">1</span>;
}
</code></pre><ol>
<li><p>find min i, arr[i]=x<br>这个和上面类似，但是其实比那个还简单一些，因为两个元素的时候，mid=(low+high)/2=low, high=mid使得size-1了，不会死循环。这个也是和上面的微妙差别</p>
<p> int BS_MiniEqualX(int *a, int n, int x)<br> {</p>
<pre><code> <span class="keyword">int</span> low=<span class="number">0</span>,high=n-<span class="number">1</span>;
 <span class="keyword">while</span>(low&lt;=high)
 {
     <span class="keyword">int</span> mid=low+(high-low)/<span class="number">2</span>;
     <span class="keyword">if</span>(a[mid]&lt;x)
         low=mid+<span class="number">1</span>;
     <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;a[mid])
         high=mid-<span class="number">1</span>;
     <span class="keyword">else</span>
     {
         <span class="keyword">if</span>(low==high)<span class="comment">//one element</span>
             <span class="keyword">return</span> mid;
         <span class="keyword">else</span><span class="comment">//include mid, to lower part, high&gt;low</span>
         {
             <span class="comment">//if(high=low+1)</span>
             high=mid;<span class="comment">//high&gt;low, must reduce array by 1</span>
         }
     }
 }
 <span class="keyword">return</span> -<span class="number">1</span>;
</code></pre><p> }</p>
</li>
<li><p>find max i  arr[i]&lt;x<br>和上面的区别在于分支修改不同，这里x&lt;=a[mid] 说明mid及以上的都不可能是解，于是修改a[mid]&lt;x 里面，解在这里面，一个元素直接return mid，两个元素注意unlimited loop了，x&lt;=a[high], high不可能了，所以return low，否则就return high了</p>
<p> int BS_MaxiLowerX(int *a, int n, int x)<br> {</p>
<pre><code> int low=<span class="number">0</span>,high=n-<span class="number">1</span><span class="comment">;</span>
 <span class="keyword">while</span>(low&lt;=high)
 {
     int mid=low+(high-low)/<span class="number">2</span><span class="comment">;</span>
     <span class="keyword">if</span>(<span class="literal">a</span>[mid]&lt;x)
     {
         <span class="keyword">if</span>(low==high) <span class="keyword">return</span> mid<span class="comment">;</span>
         <span class="keyword">else</span>
         {
             <span class="keyword">if</span>(low+<span class="number">1</span>&lt;high)
                 low=mid<span class="comment">;</span>
             <span class="keyword">else</span>//low+<span class="number">1</span>=high, two element, for <span class="keyword">if</span> this case, low=mid, would unlimited <span class="keyword">loop</span>, as <span class="literal">not</span> reduce the search size
             {
                 <span class="keyword">if</span>(x&lt;=<span class="literal">a</span>[high])
                     <span class="keyword">return</span> low<span class="comment">;</span>
                 <span class="keyword">else</span>
                     <span class="keyword">return</span> high<span class="comment">;</span>
             }
         }
     }
     <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;=<span class="literal">a</span>[mid])
         high=mid-<span class="number">1</span><span class="comment">;</span>
     //<span class="keyword">else</span>
     //    <span class="keyword">return</span> mid<span class="comment">;</span>
 }
 <span class="keyword">return</span> -<span class="number">1</span><span class="comment">;</span>
</code></pre><p> }</p>
<p> 另外这道算法是否可以直接改写基本的BS呢，我手动模拟感觉就是找不到，循环退出时的high，但是不知道怎么证明的. 感觉如果x一定是找不到的，这个写法似乎是对的，如果找得到就不知道了。如果对的话，同理可得下面的代码</p>
<p> int BS_MaxiLowerX(int *a, int n, int x)<br> {</p>
<pre><code> <span class="built_in">int</span> low=<span class="number">0</span>,high=n-<span class="number">1</span>;
 <span class="keyword">while</span>(low&lt;=high)
 {
     <span class="built_in">int</span> <span class="built_in">mid</span>=low+(high-low)/<span class="number">2</span>;
     <span class="keyword">if</span>(a[<span class="built_in">mid</span>]&lt;x)
     {
         low=<span class="built_in">mid</span>+<span class="number">1</span>;
     }
     <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;a[<span class="built_in">mid</span>])
         high=<span class="built_in">mid</span>-<span class="number">1</span>;
     <span class="keyword">else</span>
         return <span class="built_in">mid</span>;
 }
 return high;
</code></pre><p> }</p>
</li>
</ol>
<ol>
<li><p>find min i arr[i]&gt;x<br>同上，只是不需要特殊处理了，因为high=mid 必reduce search size</p>
<p> int BS_MiniHigherX(int *a, int n, int x)<br> {</p>
<pre><code> <span class="keyword">int</span> low=<span class="number">0</span>,high=n-<span class="number">1</span>;
 <span class="keyword">while</span>(low&lt;=high)
 {
     <span class="keyword">int</span> mid=low+(high-low)/<span class="number">2</span>;
     <span class="keyword">if</span>(a[mid]&lt;=x)
     {
         low=mid+<span class="number">1</span>;
     }
     <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;a[mid])
     {
         <span class="keyword">if</span>(low==high) <span class="keyword">return</span> mid;
         <span class="keyword">else</span><span class="comment">//even two elemnt, high=mid would at least reduce search size by 1</span>
             high=mid;
     }
     <span class="comment">//else</span>
     <span class="comment">//    return mid;</span>
 }
 <span class="keyword">return</span> -<span class="number">1</span>;
</code></pre><p> }</p>
</li>
</ol>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 19 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/19/Review-DFS-Permutation-Combination-NextPermutation/">Review DFS-Permutation-Combination-NextPermutation</a></h1>
  

      <time datetime="2014-07-19T14:38:16.000Z"><a href="/2014/07/19/Review-DFS-Permutation-Combination-NextPermutation/">7月 19 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>今天看到一道next_permutation的题目，于是打算串一下之前写的基于DFS或者backtrack的permutation和combination算法，顺便回顾了MS实习的一道题</p>
<p>突然发现next_permutation自己好像还不会，手动实现，而combination的下一个字典序当初也是直接调用next_permutation的。。。</p>
<pre><code><span class="preprocessor">#include &lt;map&gt;</span>
<span class="preprocessor">#include &lt;set&gt;</span>
<span class="preprocessor">#include &lt;queue&gt;</span>
<span class="preprocessor">#include &lt;stack&gt;</span>
<span class="preprocessor">#include &lt;math.h&gt;</span>
<span class="preprocessor">#include &lt;time.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;limits.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="preprocessor">#include &lt;iomanip&gt;</span>
<span class="preprocessor">#include &lt;unordered_set&gt;</span>
<span class="preprocessor">#define Min(a,b) (((a) &lt; (b)) ? (a) : (b))</span>
<span class="preprocessor">#define Max(a,b) (((a) &gt; (b)) ? (a) : (b))</span>
<span class="preprocessor">#define read freopen("in.txt","r",stdin)</span>
<span class="preprocessor">#define write freopen("out.txt","w",stdout)</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">void</span> permutation(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span>*a)
{
    <span class="keyword">if</span>(k==n)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)
            <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;
        <span class="built_in">cout</span>&lt;&lt;endl;
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n-<span class="number">1</span>;i++)
        {
            swap(a[k],a[i]);
            permutation(k+<span class="number">1</span>,n,a);
            swap(a[k],a[i]);
        }
    }
}

<span class="keyword">void</span> combination(<span class="keyword">bool</span>* select, <span class="keyword">int</span> selectk, <span class="keyword">int</span> k, <span class="keyword">int</span> selectn, <span class="keyword">int</span> n, <span class="keyword">int</span>*a, <span class="keyword">int</span> &amp;count, <span class="keyword">int</span> K)
{
    <span class="keyword">if</span>(selectn==n)
    {
        <span class="keyword">if</span>(selectk==k)
        {
            count++;
            <span class="keyword">if</span>(count==K)
            {
                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)
                {
                    <span class="keyword">if</span>(select[i])
                    {
                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"1"</span>;
                    }
                    <span class="keyword">else</span>
                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>;
                }
                <span class="built_in">cout</span>&lt;&lt;endl;
            }
        }
    }
    <span class="keyword">else</span>
    {
        select[selectn]=<span class="keyword">false</span>;
        combination(select,selectk,k,selectn+<span class="number">1</span>,n,a,count,K);
        select[selectn]=<span class="keyword">true</span>;
        combination(select,selectk+<span class="number">1</span>,k,selectn+<span class="number">1</span>,n,a,count,K);

    }
}

<span class="keyword">int</span> main()
{
    read;
    <span class="comment">//write;</span>
    <span class="keyword">int</span> a[]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};
    <span class="comment">//permutation(0,5,a);</span>
    <span class="keyword">bool</span> select[<span class="number">100</span>];
    <span class="built_in">memset</span>(select,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*<span class="number">10</span>);

    <span class="keyword">int</span> N,M,K,count=<span class="number">0</span>;
    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M&gt;&gt;K)
    {
        <span class="built_in">string</span> str;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)
            str+=<span class="string">'0'</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)
            str+=<span class="string">'1'</span>;
        <span class="keyword">int</span> i=<span class="number">1</span>;
        <span class="keyword">while</span>(i&lt;K)
        {
            <span class="keyword">bool</span> has=next_permutation(str.begin(),str.end());
            <span class="keyword">if</span>(has==<span class="keyword">false</span>) 
                <span class="keyword">break</span>; 
            i++;
        }
        <span class="keyword">if</span>(i&lt;K)
            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Impossible"</span>&lt;&lt;endl;
        <span class="keyword">else</span>
            <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;endl;
        <span class="comment">/*
        count=0;
        combination(select,0,M,0,N+M,a,count,K);
        if(count&lt;K)
            cout&lt;&lt;"Impossible"&lt;&lt;endl;
            */</span>
    }


<span class="keyword">return</span> <span class="number">0</span>;
</code></pre><p>}<br>分别用next_permutaion和自己手写的combination来实现 kth 01 string, C(n,k)这个会复杂些，参数比较多，我还用了一个count引用参数传递，这样是不好的，参数多了可能会有溢出的风险，或者定义全局变量也是一样的。<br>然后记住next_permutation如果回到头了，会返回一个false其他都是返回true。还有传入的k是M的话(1的个数)那么需要注意内部select true为1，false为0， 如果传入N的话，就反过来。然后递归出口，我一直都是这么写的，也没有剪枝，<br>搜完整个2^(N+M)的空间，之前剪枝好像逻辑出了点问题，就不敢剪了。。。。</p>
<p>另外有一点就是，int*a, a+1其实会自动地址值+4，自动定位到数组中下一个元素的地址</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 19 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/19/BinaryAdd/">BinaryAdd</a></h1>
  

      <time datetime="2014-07-19T11:48:46.000Z"><a href="/2014/07/19/BinaryAdd/">7月 19 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>这个题真的是自己摔了好多跤才爬起来的。。。自己还是考虑问题不全面，在软件测试的时候，估计会摔得更惨。。。<br>一开始想两种方案，二进制加，后者转十进制加，然后转回二进制，心想二进制加还要reverse才好加，不然对不齐，于是十进制，结果溢出了，用最大的unsigned long long还是溢出，这个可是20位十进制啊。。。<br>所以这种题目设计的就不是用十进制加法，而是要自己去实现一个加法，考虑各种情况，就像int的 +一样。</p>
<p>于是开始考虑情况，需要forward表示进位，然后还有长度不一样多出的怎么办，而且首先要reverse的，这样才对得齐。。。<br>于是由一般的写起，a[i]+b[i]+forward-2 &gt;= &lt;0来判断是否进位，然后后面也forward变为0 1,相应的，=0的我已开始忘记赋了，只记得比较重要的，进位需要赋1.。。<br>长度超出了怎么办？一定不能越界，于是判断是否超出任意一个的长度，如果超出了，且有进位，还要注意，可能一直进位，所以不能直接append后面多出的，如果forward=0 就append，然后还有最后多出一个<br>进位还要单独加一个”1”。我主要是一开始没有想清楚就coding，然后后面一个一个改，还是弄了一会儿，另外指针后移是每一个都后移，其他的break，我已开始最后全部 if else case都写了++，最后里面分支有的又<br>写了++，这个也忘记了。感觉这个逻辑的复杂度不亚于atoi函数的。。。。</p>
<p>summary：forward=0 且至少一个越界，直接append后面多出的部分，因为后面不再进位(注意此处两个都越界可以放到其中任意一个里，因为substr() startpos如果长度超过了，则返回空串，刚好符合要求)<br>         forward=1 且至少一个越界，区分拿一个越界，然后加上a[i]+foward 看是否有进位，i++(这里两个都越界要单独处理，因为访问b[i]会越界，不想substr()能够tackle这种case，然后看如果进位，直接+”1”)<br>         都不越界(forward=0 1可以统一起来)， 普通处理<br>附上代码：</p>
<pre><code><span class="keyword">string</span> addBinary(<span class="keyword">string</span> a, <span class="keyword">string</span> b)
    {
        reverse(a.begin(),a.end());
        reverse(b.begin(),b.end());
        <span class="keyword">int</span> forward=<span class="number">0</span>,i=<span class="number">0</span>;
        <span class="keyword">string</span> c=<span class="string">""</span>;
        <span class="keyword">while</span>(<span class="number">1</span>)
        {
            <span class="keyword">if</span>(forward==<span class="number">0</span> &amp;&amp; (i&gt;= a.<span class="keyword">size</span>() || i&gt;= b.<span class="keyword">size</span>()))
            {
                <span class="keyword">if</span>(i&gt;= a.<span class="keyword">size</span>())
                {
                    c+=b.substr(i);
                }
                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;= b.<span class="keyword">size</span>())
                    c+=a.substr(i);
                <span class="keyword">break</span>;
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(forward==<span class="number">1</span> &amp;&amp; (i&gt;= a.<span class="keyword">size</span>() || i&gt;= b.<span class="keyword">size</span>()))
            {
                <span class="keyword">if</span>(i&gt;=a.<span class="keyword">size</span>() &amp;&amp; i&lt; b.<span class="keyword">size</span>())
                {
                    <span class="keyword">if</span>(b[i]-<span class="string">'0'</span>+forward&gt;=<span class="number">2</span>)
                    {

                        c+=char(b[i]-<span class="string">'0'</span>+forward-<span class="number">2</span>+<span class="string">'0'</span>);
                        forward=<span class="number">1</span>;
                    }
                    <span class="keyword">else</span>
                    {
                        c+=char(b[i]-<span class="string">'0'</span>+forward+<span class="string">'0'</span>);
                        forward=<span class="number">0</span>;

                    }
                    i++;
                }
                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=b.<span class="keyword">size</span>() &amp;&amp; i&lt; a.<span class="keyword">size</span>())
                {
                    <span class="keyword">if</span>(a[i]-<span class="string">'0'</span>+forward&gt;=<span class="number">2</span>)
                    {

                        c+=char(a[i]-<span class="string">'0'</span>+forward-<span class="number">2</span>+<span class="string">'0'</span>);
                        forward=<span class="number">1</span>;
                    }
                    <span class="keyword">else</span>
                    {
                        c+=char(a[i]-<span class="string">'0'</span>+forward+<span class="string">'0'</span>);
                        forward=<span class="number">0</span>;

                    }
                    i++;
                }
                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=b.<span class="keyword">size</span>() &amp;&amp; i&gt;= a.<span class="keyword">size</span>())
                {
                    c+=<span class="string">"1"</span>;
                    <span class="keyword">break</span>;

                }

            }
            <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;a.<span class="keyword">size</span>()&amp;&amp;i&lt;b.<span class="keyword">size</span>())
            {
                <span class="keyword">if</span>(a[i]-<span class="string">'0'</span>+b[i]-<span class="string">'0'</span>+forward&gt;=<span class="number">2</span>)
                {

                    c+=char(a[i]-<span class="string">'0'</span>+b[i]-<span class="string">'0'</span>+forward-<span class="number">2</span>+<span class="string">'0'</span>);
                    forward=<span class="number">1</span>;
                }
                <span class="keyword">else</span>
                {
                    c+=char(a[i]-<span class="string">'0'</span>+b[i]-<span class="string">'0'</span>+forward+<span class="string">'0'</span>);
                    forward=<span class="number">0</span>;
                }
                i++;
            }

            <span class="comment">//i++;</span>
        }
        reverse(c.begin(),c.end());
        <span class="keyword">return</span> c;
    }
</code></pre><p>记得最后要reverse回来</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 19 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/19/Min-Path-Num--Typical-DP/">Min Path Num--Typical DP</a></h1>
  

      <time datetime="2014-07-19T09:08:54.000Z"><a href="/2014/07/19/Min-Path-Num--Typical-DP/">7月 19 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>我和刘辉师兄坐在一起，就是你做事情，我突然哈哈大笑，然后我做做事情，你突然哈哈大笑O(∩_∩)O</p>
<p>这道题目属于容易看出的DP，从曹博PPT了看到例子后就反应更快了，不过感觉这个已经是曹博PPT最容易make sense的DP了= =<br>二维表格记录DP，初始化0 0， 以及0 j， i 0, 这样保证后面计算的子问题前面都计算出来了，注意下表不越界，还有就是<br>leetcode题目都没给数据范围，因此都不敢用全局变量了，正如fawks大神说的，global的比较简单，于是我还是用heap了。。。</p>
<p>附上代码：</p>
<pre><code><span class="keyword">int</span> Min(<span class="keyword">int</span> x, <span class="keyword">int</span> y)
    {
        <span class="keyword">if</span>(x&lt;y) <span class="keyword">return</span> x;
        <span class="keyword">else</span> <span class="keyword">return</span> y;
    }
    <span class="keyword">int</span> minPathSum(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> &amp;grid) {
        <span class="keyword">int</span> row=grid.size();
        <span class="keyword">if</span>(row==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">int</span> col=grid.at(<span class="number">0</span>).size();
        <span class="keyword">if</span>(col==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;

        <span class="keyword">int</span> **dp=<span class="keyword">new</span> <span class="keyword">int</span>*[row];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)
            dp[i]=<span class="keyword">new</span> <span class="keyword">int</span>[col];

        dp[<span class="number">0</span>][<span class="number">0</span>]=grid.at(<span class="number">0</span>).at(<span class="number">0</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col;j++)
            dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j-<span class="number">1</span>]+grid.at(<span class="number">0</span>).at(j);
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row;i++)
            dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid.at(i).at(<span class="number">0</span>);

        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=row-<span class="number">1</span>;i++)
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=col-<span class="number">1</span>;j++)
            {
                dp[i][j]=Min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid.at(i).at(j);
            }
        }
        <span class="keyword">int</span> max=dp[row-<span class="number">1</span>][col-<span class="number">1</span>];


        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)
            <span class="keyword">delete</span>[] dp[i];
        <span class="keyword">delete</span>[] dp;
        <span class="keyword">return</span> max;
    }
</code></pre><p>里面需要注意的是没有C++11，所以没有min可能。。。另外我每次都是写完general case再在前面加exception case的，比较舒服，之前一次提交还忘记返回值了= =<br>自己要逐渐转向不debug，因为后面纸上代码比较多些，直接在leetcode写了，眼睛看了submit</p>
<p>另外今天突然意识到vector可以当数组用的[], 之前一直at写起来麻烦，但是[]不越界检查，后果自负，我还是习惯[]呢，只是list就没有[]了。。<br><a href="http://zhuyanfeng.com/archives/783" target="_blank" rel="external">http://zhuyanfeng.com/archives/783</a></p>
<p>最近发现小米手机Wifi老是断，其他的小米却没有。感觉排除了wifi信号的问题，于是还是之前一直怀疑的系统故意设计这样，节约资源，例如电之类的，不需要的时候自动断掉，但是我需要的时候<br>也经常断掉啊%&gt;_&lt;%，之前查到好像是德州电器写的wifi驱动里面代码有这么节约资源的设计，好像点到wifi他才连上。。。不太确定，之前想找找帖子解决这个问题的，一直没搞定o(╯□╰)o</p>
<p>一个阿三和我说，她又认识了一个美女，而且是fb主动勾引他的。。。这位可真是把把妹当成一生的主题啊，他还尤其喜欢Chinese girls，尤其是她们的hair style，说一看背后就知道中国女孩，她们都<br>比印度女孩漂亮，还问我是不是jealous = =</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 19 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/19/from-Word-Break-to-substr-function-note/">from Word Break to substr function note</a></h1>
  

      <time datetime="2014-07-19T08:35:44.000Z"><a href="/2014/07/19/from-Word-Break-to-substr-function-note/">7月 19 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p><a href="https://oj.leetcode.com/problems/word-break/" target="_blank" rel="external">https://oj.leetcode.com/problems/word-break/</a><br>这道题目不是重点，重点是用string::substr的一点体会。<br>substr(size_t pos, size_t len=string::npos)</p>
<p>这个是substr的document，默认第二个参数npos表示取到字符串源串最后面，而且特别注意都是size_t类型，<br>我有一次掉到坑里去了，第二个参数一定要是&gt;=0的，如果负数就会返回整个源串，要特别注意，另外pos也是&gt;=0，这个倒好理解。<br>而且这个比较好，只有一种参数列表，这样比较容易记忆使用，当然如果参数列表多，用多了一般也是用自己比较熟悉的那一种。</p>
<p>代码是错的，有些case不行，可能需要回溯，类似dfs这种</p>
<pre><code><span class="keyword">bool</span> wordBreak(<span class="built_in">string</span> s, <span class="stl_container"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;</span> &amp;dict) {
        <span class="keyword">if</span>(s==<span class="string">""</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">while</span>(<span class="number">1</span>)
        {
            <span class="keyword">if</span>(s==<span class="string">""</span>)
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="keyword">bool</span> found=<span class="keyword">false</span>;
            <span class="keyword">int</span> startpos;
            <span class="built_in">string</span> substr1,substr2;
            <span class="keyword">for</span>(<span class="stl_container"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;</span>::iterator it=dict.begin();it!=dict.end();it++)
            {
                <span class="keyword">if</span>((startpos=s.find(*it))!=<span class="built_in">string</span>::npos)
                {
                    found=<span class="keyword">true</span>;
                    <span class="keyword">if</span>(startpos-<span class="number">1</span>&gt;=<span class="number">0</span>)
                        substr1=s.substr(<span class="number">0</span>,startpos);
                    <span class="keyword">else</span>
                        substr1=<span class="string">""</span>;

                    <span class="built_in">string</span> substr2=s.substr(startpos+(*it).size(),s.size()-(startpos+(*it).size()));
                    s=substr1+substr2;
                }
            }
            <span class="keyword">if</span>(found==<span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        }
    }
</code></pre>
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 19 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/2/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/4/" class="alignright next">下一页</a>
  
</nav></div>
    </div>
    <div class="tabbar" onload="divideTabBar()">
	
      <div class="tabbaritem"><a class="next" href="/">Home</a></div>
    
      <div class="tabbaritem"><a class="next" href="/archives/">Archives</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a></div>
    
</div>


  </div>
</body>
</html>