<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 8 页 | Richard</title>
  <meta name="author" content="Richard">
  
  <meta name="description" content="理查德爱闹">
  
  
  
  <meta property="og:site_name" content="Richard"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta property="og:image" content="undefined"/>
  
   <link rel="apple-touch-icon" href="/icon.png" />
   <link rel="shortcut icon" href="/favicon.png" >
   <link rel="alternate" href="http://xxx.xx/atom.xml" title="Richard" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
</head>


<body>
  <div id="content" class="inner">
    <aside id="sidebar" class="alignleft">
      <div class="navigationBar">
        <a href="/">Richard</a>
      </div>
    	
  <nav class="widget" id="menu">
	<ul>
    
      <li class="cell"><a class="next" href="/">Home</a><li>
    
      <li class="cell"><a class="next" href="/archives/">Archives</a><li>
    
      <li class="cell"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a><li>
    
      <li class="cell"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a><li>
    
      <li class="cell"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a><li>
    
    </ul>
</nav>

  <div class="widget weibo">
  <iframe width="100%" height="750" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=750&fansRow=2&ptype=1&speed=0&skin=6&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2689136623&verifier=c139aa37&dpc=1"></iframe>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/BT/">BT</a><small>1</small></li>
  
    <li><a href="/categories/Binary-Tree/">Binary Tree</a><small>1</small></li>
  
    <li><a href="/categories/BinaryTree/">BinaryTree</a><small>1</small></li>
  
    <li><a href="/categories/C/">C</a><small>1</small></li>
  
    <li><a href="/categories/C++/">C++</a><small>1</small></li>
  
    <li><a href="/categories/DFS/">DFS</a><small>1</small></li>
  
    <li><a href="/categories/DP/">DP</a><small>1</small></li>
  
    <li><a href="/categories/Linklist/">Linklist</a><small>1</small></li>
  
    <li><a href="/categories/Machine-Learning/">Machine Learning</a><small>1</small></li>
  
    <li><a href="/categories/Recursive/">Recursive</a><small>1</small></li>
  
    <li><a href="/categories/Trie/">Trie</a><small>1</small></li>
  
    <li><a href="/categories/Union-find-set/">Union-find set</a><small>1</small></li>
  
    <li><a href="/categories/algorithm/">algorithm</a><small>15</small></li>
  
    <li><a href="/categories/app/">app</a><small>1</small></li>
  
    <li><a href="/categories/backtrack/">backtrack</a><small>2</small></li>
  
    <li><a href="/categories/bfs/">bfs</a><small>1</small></li>
  
    <li><a href="/categories/bfs,-dfs/">bfs, dfs</a><small>1</small></li>
  
    <li><a href="/categories/binary-search/">binary search</a><small>2</small></li>
  
    <li><a href="/categories/binary-tree/">binary tree</a><small>4</small></li>
  
    <li><a href="/categories/bit/">bit</a><small>1</small></li>
  
    <li><a href="/categories/bit-operation/">bit operation</a><small>2</small></li>
  
    <li><a href="/categories/blog/">blog</a><small>1</small></li>
  
    <li><a href="/categories/c-language/">c language</a><small>2</small></li>
  
    <li><a href="/categories/catalan/">catalan</a><small>1</small></li>
  
    <li><a href="/categories/complex-condition-anaysis/">complex condition anaysis</a><small>1</small></li>
  
    <li><a href="/categories/cpp/">cpp</a><small>12</small></li>
  
    <li><a href="/categories/cpp-string/">cpp string</a><small>1</small></li>
  
    <li><a href="/categories/data-structure/">data structure</a><small>4</small></li>
  
    <li><a href="/categories/dfs/">dfs</a><small>1</small></li>
  
    <li><a href="/categories/dfs,-non-recursive/">dfs, non-recursive</a><small>1</small></li>
  
    <li><a href="/categories/dp/">dp</a><small>4</small></li>
  
    <li><a href="/categories/ds/">ds</a><small>2</small></li>
  
    <li><a href="/categories/easy-programming/">easy programming</a><small>1</small></li>
  
    <li><a href="/categories/experience/">experience</a><small>1</small></li>
  
    <li><a href="/categories/hash/">hash</a><small>1</small></li>
  
    <li><a href="/categories/heap/">heap</a><small>2</small></li>
  
    <li><a href="/categories/hexo-configuration/">hexo configuration</a><small>1</small></li>
  
    <li><a href="/categories/hihocode/">hihocode</a><small>1</small></li>
  
    <li><a href="/categories/integer/">integer</a><small>1</small></li>
  
    <li><a href="/categories/kmp/">kmp</a><small>1</small></li>
  
    <li><a href="/categories/latex/">latex</a><small>1</small></li>
  
    <li><a href="/categories/linklist/">linklist</a><small>9</small></li>
  
    <li><a href="/categories/logic/">logic</a><small>1</small></li>
  
    <li><a href="/categories/number-theory/">number theory</a><small>1</small></li>
  
    <li><a href="/categories/permutation/">permutation</a><small>2</small></li>
  
    <li><a href="/categories/probability/">probability</a><small>1</small></li>
  
    <li><a href="/categories/programming/">programming</a><small>1</small></li>
  
    <li><a href="/categories/quick-and-right-coding/">quick and right coding</a><small>1</small></li>
  
    <li><a href="/categories/scanf/">scanf</a><small>1</small></li>
  
    <li><a href="/categories/screen/">screen</a><small>1</small></li>
  
    <li><a href="/categories/sorting/">sorting</a><small>1</small></li>
  
    <li><a href="/categories/string/">string</a><small>1</small></li>
  
    <li><a href="/categories/web/">web</a><small>2</small></li>
  
    <li><a href="/categories/数字规律/">数字规律</a><small>1</small></li>
  
    <li><a href="/categories/树形DP/">树形DP</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/BST/" style="font-size: 12.50px;">BST</a><a href="/tags/BT/" style="font-size: 15.00px;">BT</a><a href="/tags/Backtrack/" style="font-size: 10.00px;">Backtrack</a><a href="/tags/Bayesian-graph-model/" style="font-size: 10.00px;">Bayesian graph model</a><a href="/tags/C/" style="font-size: 12.50px;">C</a><a href="/tags/C++/" style="font-size: 10.00px;">C++</a><a href="/tags/Combinations/" style="font-size: 10.00px;">Combinations</a><a href="/tags/DP/" style="font-size: 12.50px;">DP</a><a href="/tags/OO/" style="font-size: 10.00px;">OO</a><a href="/tags/Order/" style="font-size: 10.00px;">Order</a><a href="/tags/Permutation/" style="font-size: 10.00px;">Permutation</a><a href="/tags/PostOrder/" style="font-size: 10.00px;">PostOrder</a><a href="/tags/Trie/" style="font-size: 10.00px;">Trie</a><a href="/tags/Union-find-set/" style="font-size: 10.00px;">Union-find set</a><a href="/tags/algorithm/" style="font-size: 20.00px;">algorithm</a><a href="/tags/app/" style="font-size: 10.00px;">app</a><a href="/tags/array/" style="font-size: 15.00px;">array</a><a href="/tags/back-n-node/" style="font-size: 10.00px;">back n node</a><a href="/tags/backtrack/" style="font-size: 10.00px;">backtrack</a><a href="/tags/bfs/" style="font-size: 12.50px;">bfs</a><a href="/tags/binary-search/" style="font-size: 15.00px;">binary search</a><a href="/tags/binary-search-tree/" style="font-size: 10.00px;">binary search tree</a><a href="/tags/bit/" style="font-size: 15.00px;">bit</a><a href="/tags/brute-force/" style="font-size: 12.50px;">brute force</a><a href="/tags/c/" style="font-size: 10.00px;">c</a><a href="/tags/c-language/" style="font-size: 12.50px;">c language</a><a href="/tags/catalan/" style="font-size: 10.00px;">catalan</a><a href="/tags/category-analysis/" style="font-size: 10.00px;">category analysis</a><a href="/tags/char/" style="font-size: 10.00px;">char*</a><a href="/tags/cin/" style="font-size: 10.00px;">cin</a><a href="/tags/coding/" style="font-size: 10.00px;">coding</a><a href="/tags/combination/" style="font-size: 10.00px;">combination</a><a href="/tags/complement/" style="font-size: 10.00px;">complement</a><a href="/tags/complex/" style="font-size: 12.50px;">complex</a><a href="/tags/complex-condition-analysis/" style="font-size: 12.50px;">complex condition analysis</a><a href="/tags/condition-analysis/" style="font-size: 10.00px;">condition analysis</a><a href="/tags/configuire/" style="font-size: 10.00px;">configuire</a><a href="/tags/convert/" style="font-size: 10.00px;">convert</a><a href="/tags/cpp/" style="font-size: 17.50px;">cpp</a><a href="/tags/cpp，inheritance/" style="font-size: 10.00px;">cpp，inheritance</a>
  </div>
</div>


    	<footer id="footer" class="inner"><div class="copyright">
  
  &copy; 2014 Richard
  
</div>



</footer>
    </aside>
    
    
    <div id="hidden-navigationBar" class="navigationBar">
      <a href="/">Richard</a>
    </div>
    <div id="main-col" class="alignright">
    <div id="wrapper">
      
  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/23/Median-of-two-array/">Median of two array</a></h1>
  

      <time datetime="2014-07-23T13:30:51.000Z"><a href="/2014/07/23/Median-of-two-array/">7月 23 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>两个数组的中位数，这道是11CS的DS最后一题，考研的童鞋一定不会陌生，都已经做烂了，但是想想看第一次做的时候，是否能写出正确的处理所有case的代码了。<br>我也不记得当时有没有写出来了。。。。</p>
<p>这道题目很多帖子，也是经典题目<br><a href="http://wenku.baidu.com/view/114e577a27284b73f242506b" target="_blank" rel="external">http://wenku.baidu.com/view/114e577a27284b73f242506b</a><br><a href="http://liubangchuan.iteye.com/blog/1870650" target="_blank" rel="external">http://liubangchuan.iteye.com/blog/1870650</a><br><a href="http://my.oschina.net/mustang/blog/58047" target="_blank" rel="external">http://my.oschina.net/mustang/blog/58047</a><br><a href="http://blog.csdn.net/hackbuteer1/article/details/7584838" target="_blank" rel="external">http://blog.csdn.net/hackbuteer1/article/details/7584838</a></p>
<p>先来个简单的，假设两个数组等长，且sorted，假设median定义为 两个数组中 中间两个数较小的一个<br>思路大家基本都知道，就是两个数组同时二分，然后比较, a[mid1]<b[mid2], 那么a往高处走，b往低处走，如果a[mid1]="">b[mid2],那么a往低处走，b往高处走，相等的话直接返回结果。<br>思想是基于这个：中位数必&gt;=至少”一半”的数，n奇，(n-1)/2 此处写的除都是数学的除，不是C++的除，避免混淆,如果偶数，必&gt;=(n-2)/2),对于等长数组，n比为偶数</b[mid2],></p>
<p>(中位数：如果长度为奇，就是排序后中间的数，如果偶，就是中间的两个数的任意一个(leetcode定义为均值))，那么接下来代码AC(如果面试官算法非常强的话，应该是知道你的代码是否可以AC的)之前需要回答几个问题：</p>
<ol>
<li>返回的出口在哪几个地方？</li>
<li>奇偶性处理</li>
</ol>
<p>对于第一个问题，首先如果相等的话，就找到了，因为&lt;=a[mid] 的数至少(n-2)/2， &gt;=a[mid]也一样，b[mid]也一样，所以直接返回中位数了，如果a[mid1]&lt;b[mid1]，a[0…mid1-1] b[0..mid1-1]最多这么多数小于。。。。<br>突然发现好像看的答案好像只能返回偶数时两个中位数中靠前的一个。。。。。呜呜呜。。。。。。</p>
<p>大致思想是如果&lt;=a[mid]的数都不到一半了，往上移的时候可以多移一位，否则要保留mid，b[]也是一样的。</p>
<p>现附上这个两个等长数组，返回中位数(如果偶数个数时返回中间两个任意都可以的话)代码(由于没有OJ测所以未必保证正确性)：</p>
<pre><code><span class="keyword">int</span> findMedianSortedArrays_EqualSize(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)
{
    <span class="keyword">int</span> low1=<span class="number">0</span>,high1=n-<span class="number">1</span>,low2=<span class="number">0</span>,high2=n-<span class="number">1</span>;
    <span class="keyword">while</span>(low1&lt;high1 || low2&lt;high2)
    {
        <span class="keyword">int</span> mid1=(low1+high1)/<span class="number">2</span>;
        <span class="keyword">int</span> mid2=(low2+high2)/<span class="number">2</span>;
        <span class="keyword">if</span>(A[mid1]&lt;B[mid2])
        {

            <span class="keyword">if</span>(n<span class="variable">%2</span>==<span class="number">0</span>)<span class="comment">//a[mid1] can not be median of a[]+b[], analyze...</span>
                low1=mid1+<span class="number">1</span>,high2=mid2;
            <span class="keyword">else</span>
                low1=mid1,high2=mid2;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(A[mid1]&gt;B[mid2])<span class="comment">//对称分析</span>
        {
            <span class="keyword">if</span>(n<span class="variable">%2</span>==<span class="number">0</span>)
                low2=mid2,high2=mid2-<span class="number">1</span>;
            <span class="keyword">else</span>
                low2=mid2,high2=mid2;
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">return</span> A[mid1];
        }
    }
    <span class="keyword">return</span> A[low1]&lt;B[low2]?A[low1]:B[low2];

}
</code></pre><p>这个等长的情况已经比较麻烦了，包括最后返回的这两个low1 low2的解释我还没有看到，而不等长的里面还嵌套了一个外部函数的递归，我本打算基于上述这个弄个不等长的，始终搞不出来o(╯□╰)o<br>不等长的就暂时放一放吧，这个从昨天一直搞到几天，断断续续弄，太浪费时间了，先暂时搁置吧，我用merge方向也过了leetcode，leetcode其实时间很松的。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 23 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/23/scanf-eof-cin/">scanf eof cin</a></h1>
  

      <time datetime="2014-07-23T07:05:04.000Z"><a href="/2014/07/23/scanf-eof-cin/">7月 23 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>今天发现遇到一个奇怪的问题，群里的童鞋说POJ这样写TLE</p>
<pre><code><span class="keyword">while</span>(~scanf(<span class="string">"<span class="variable">%s</span><span class="variable">%s</span>"</span>, <span class="keyword">s</span>,e))
</code></pre><p>但是这样写就AC了</p>
<pre><code><span class="keyword">while</span>(scanf(<span class="string">"<span class="variable">%s</span><span class="variable">%s</span>"</span>, <span class="keyword">s</span>,e)!=<span class="keyword">eof</span>)
</code></pre><p>后来发现，G++两个都可以，但是C++(MSVC)第一个就会TLE了</p>
<p>看了官方的scanf资料，<a href="http://www.cplusplus.com/reference/cstdio/scanf/?kw=scanf" target="_blank" rel="external">http://www.cplusplus.com/reference/cstdio/scanf/?kw=scanf</a><br>发现还是比较模糊，尤其是eof之前就有阴影，感觉有时候会很奇怪。看过一篇详细的eof博客，还是没理清头绪</p>
<pre><code><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e)
</code></pre><p>这种就不需要管eof的事情，OJ后台可能还是重定向到文件里，然后去读文件的</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 23 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/23/BFS-Knight/">BFS-Knight</a></h1>
  

      <time datetime="2014-07-23T06:49:20.000Z"><a href="/2014/07/23/BFS-Knight/">7月 23 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>看到群里童鞋说这个scanf会挂，于是我试了下，poj已提交网页就挂了，不知道为啥。</p>
<p>朴素的bfs，之前dfs练得多一些，图的dfs相比树的因为更复杂，需要visit来避免重复访问。poj2243, 这道就是基本的bfs了，好像也没有剪枝的策略。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;math.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;time.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;limits.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;iomanip&gt;</span>
<span class="comment">//#include &lt;unordered_set&gt;</span>
<span class="preprocessor">#<span class="keyword">define</span> Min(a,b) (((a) &lt; (b)) ? (a) : (b))</span>
<span class="preprocessor">#<span class="keyword">define</span> Max(a,b) (((a) &gt; (b)) ? (a) : (b))</span>
<span class="preprocessor">#<span class="keyword">define</span> read freopen("in.txt","r",stdin)</span>
<span class="preprocessor">#<span class="keyword">define</span> write freopen("out.txt","w",stdout)</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">struct</span> node
{
    <span class="keyword">int</span> row;
    <span class="keyword">int</span> col;
    <span class="keyword">int</span> path;

};

<span class="keyword">int</span> main()
{
    <span class="comment">//read;</span>
    <span class="comment">//write;</span>
    <span class="keyword">char</span> s[<span class="number">3</span>],e[<span class="number">3</span>];
    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s,e))
    {
        <span class="comment">//cin&gt;&gt;e;</span>

        node start,end;
        start.col=s[<span class="number">0</span>]-<span class="string">'a'</span>;
        start.row=s[<span class="number">1</span>]-<span class="string">'1'</span>;
        start.path=<span class="number">0</span>;
        end.col=e[<span class="number">0</span>]-<span class="string">'a'</span>;
        end.row=e[<span class="number">1</span>]-<span class="string">'1'</span>;

        <span class="stl_container"><span class="built_in">queue</span>&lt;node&gt;</span> q;

        q.push(start);
        node p;
        <span class="keyword">while</span>(!q.empty())
        {
            p=q.front();
            q.pop();
            <span class="keyword">if</span>(p.row==end.row &amp;&amp; p.col== end.col)
            {
                <span class="keyword">break</span>;
            }

            <span class="keyword">if</span>(p.row-<span class="number">2</span> &gt;=<span class="number">0</span> &amp;&amp; p.col+<span class="number">1</span>&lt;=<span class="number">7</span>)
            {
                node nd;
                nd.row=p.row-<span class="number">2</span>;nd.col=p.col+<span class="number">1</span>;
                nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }

            <span class="keyword">if</span>(p.row-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; p.col+<span class="number">2</span>&lt;=<span class="number">7</span>)
            {
                node nd;
                nd.row=p.row-<span class="number">1</span>;nd.col=p.col+<span class="number">2</span>;
                nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
            <span class="keyword">if</span>(p.row+<span class="number">1</span> &lt;=<span class="number">7</span> &amp;&amp; p.col+<span class="number">2</span>&lt;=<span class="number">7</span>)
            {
                node nd;
                nd.row=p.row+<span class="number">1</span>;nd.col=p.col+<span class="number">2</span>;
                nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
            <span class="keyword">if</span>(p.row+<span class="number">2</span> &lt;=<span class="number">7</span> &amp;&amp; p.col+<span class="number">1</span>&lt;=<span class="number">7</span>)
            {
                node nd;
                nd.row=p.row+<span class="number">2</span>;nd.col=p.col+<span class="number">1</span>;
                nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
            <span class="keyword">if</span>(p.row+<span class="number">2</span> &lt;=<span class="number">7</span> &amp;&amp; p.col-<span class="number">1</span>&gt;=<span class="number">0</span>)
            {
                node nd;
                nd.row=p.row+<span class="number">2</span>;nd.col=p.col-<span class="number">1</span>;
                nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
            <span class="keyword">if</span>(p.row+<span class="number">1</span> &lt;=<span class="number">7</span> &amp;&amp; p.col-<span class="number">2</span>&gt;=<span class="number">0</span>)
            {
                node nd;
                nd.row=p.row+<span class="number">1</span>;nd.col=p.col-<span class="number">2</span>;nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
            <span class="keyword">if</span>(p.row-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; p.col-<span class="number">2</span>&gt;=<span class="number">0</span>)
            {
                node nd;
                nd.row=p.row-<span class="number">1</span>;nd.col=p.col-<span class="number">2</span>;nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
            <span class="keyword">if</span>(p.row-<span class="number">2</span> &gt;=<span class="number">0</span> &amp;&amp; p.col-<span class="number">1</span>&gt;=<span class="number">0</span>)
            {
                node nd;
                nd.row=p.row-<span class="number">2</span>;nd.col=p.col-<span class="number">1</span>;nd.path=p.path+<span class="number">1</span>;
                q.push(nd);
            }
        }

        <span class="built_in">cout</span>&lt;&lt;<span class="string">"To get from "</span>&lt;&lt;s&lt;&lt;<span class="string">" to "</span>&lt;&lt;e&lt;&lt;<span class="string">" takes "</span>&lt;&lt;p.path&lt;&lt;<span class="string">" knight moves."</span>&lt;&lt;endl;
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 23 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/23/Recode-SubsetsSnum/">Recode SubsetsSnum</a></h1>
  

      <time datetime="2014-07-23T06:32:19.000Z"><a href="/2014/07/23/Recode-SubsetsSnum/">7月 23 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>看到邹博写的permutation，发现参数比较有意思，是from to这种，后来想想，确实这种比较make sense，之前写的的什么selectk，k，selectn,n都非常容易在边界之类的出错，递归出口处的逻辑等等，这种非常清晰，于是<br>学习邹博的coding风格重写了subsetsnum 问题。</p>
<p>先写了一个朴素的，遍历完2^n搜索空间的朴素，from是起点，to是终点，所以这么调用Sum(a, 0,n-1,sumx);表示从a[from…to]里面找到子集和为sumx的集合，<br>后来发现，这样每次都去想到底是n还是n-1，出口是k&gt;n还是k==n呢，每次都先写一个，然后拿个例子去测，还是邹博这种写法比较规范。</p>
<pre><code><span class="keyword">void</span> Sum(<span class="keyword">int</span> *a, <span class="keyword">int</span> <span class="keyword">from</span>, <span class="keyword">int</span> to, <span class="keyword">int</span> sumx)
{
    <span class="keyword">if</span>(<span class="keyword">from</span>&gt;to)
    {
        <span class="keyword">int</span> sum=<span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=to;i++)
            sum+=a[i]*<span class="keyword">select</span>[i];
        <span class="keyword">if</span>(sum==sumx)
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=to;i++)
                <span class="keyword">if</span>(<span class="keyword">select</span>[i])
                    cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;
            cout&lt;&lt;endl;
        }
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">select</span>[<span class="keyword">from</span>]=<span class="keyword">false</span>;
        Sum(a,<span class="keyword">from</span>+<span class="number">1</span>,to, sumx);
        <span class="keyword">select</span>[<span class="keyword">from</span>]=<span class="keyword">true</span>;
        Sum(a,<span class="keyword">from</span>+<span class="number">1</span>,to,sumx);
    }
}
</code></pre><p>一直都考虑到这种很多无用的搜索，例如之前和已经超了，还要去遍历，显然浪费了时间，于是将和&lt;0的剪枝，但是之前写总会出问题，改成这种写法决定试试：</p>
<pre><code>void Cut_Sum(int <span class="keyword">from</span>, int <span class="keyword">to</span>, int sumx)
{


    <span class="keyword">if</span>(sumx&lt;<span class="number">0</span>) <span class="constant">return</span>;
    <span class="keyword">else</span> <span class="keyword">if</span>(sumx==<span class="number">0</span>)
    {
        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&gt;=<span class="keyword">to</span>;i<span class="comment">--)</span>
        {
            <span class="keyword">if</span>(selectn[i])
                cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;
        }
        cout&lt;&lt;endl;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">from</span>&gt;<span class="keyword">to</span>)
<span class="command">        return</span>;
    <span class="keyword">else</span>
    {
        selectn[<span class="keyword">from</span>]=<span class="constant">false</span>;
        Cut_Sum(<span class="keyword">from</span>+<span class="number">1</span>,<span class="keyword">to</span>,sumx);
        selectn[<span class="keyword">from</span>]=<span class="constant">true</span>;
        Cut_Sum(<span class="keyword">from</span>+<span class="number">1</span>,<span class="keyword">to</span>,sumx-a[<span class="keyword">from</span>]);
    }
}
</code></pre><p>后来和上面朴素的结果比一比发现又错了，递归程序改改又挂了o(╯□╰)o</p>
<p>1,2,3,4,5，6 sum=6<br>又来了阴影，打算重新模拟一遍，发现了问题，其实不是完全乱了，而是在回溯到2 4的时候，我把5 6也打印出来了，发现这时候5 6 的select都为true，难怪print出来，怎么会出这个问题，为啥原来的没有？<br>后来分析一遍，发现区别了，原来每次找到解都要遍历完6个数，因此后面的自然变为false了，而我现在剪枝的话，前面一开始从false到true后是没有复原到false的，然后又从0-&gt;to print出来当然误以为5 6都选上了，所以解决方案<br>是只把0-&gt;from-1的根据select print出来，注意是from-1，因为sum=0 是处理0-&gt;from之后得出的和，from+1还没看，所以把上面sumx=0的for改为</p>
<pre><code><span class="keyword">for</span>(int <span class="built_in">i</span>=from-<span class="number">1</span>;<span class="built_in">i</span>&gt;=<span class="number">0</span>;<span class="built_in">i</span>--)
</code></pre><p>改成后面到前面是因为一道题目要求从大到小排序，我已开始把数组升序排了。<br>因此这是递归版剪枝的子集和问题代码，但是OJ由于时间掐的严，还是TLE了，因为递归还是很多重复调用，要改成非递归的，不过我都忘记了。。。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 23 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/22/quick-and-right-coding/">quick and right coding</a></h1>
  

      <time datetime="2014-07-22T12:25:40.000Z"><a href="/2014/07/22/quick-and-right-coding/">7月 22 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>昨天看了下邹博的PPT，邹博是负责July团队负责字符串一块的，包括Manachester算法，KMP，BP，字符串排列(其实是回溯法了)等等，<br>有一个不太重要的地方，就是邹博的代码比较短，而且看起来逻辑比较漂漂，而我的经常逻辑复杂，还写半天，还经常出bug，于是写点总结。</p>
<p>先拿最长回文子串朴素O(n^2)代码这个case来看，遍历回文串中心，我代码可能有问题，以为不需要首尾两个字符了，因为肯定是1了，但是忘记考虑偶数长回文子串了，如果后面Index=1(0-base)的没有考虑01为中心的偶长传可能就会有问题了，<br>末尾也是一样的。自己漏考虑。</p>
<pre><code><span class="keyword">int</span> maxdrome_centre(<span class="keyword">string</span> str)
{
    <span class="keyword">if</span>(str.<span class="keyword">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> maxlen=<span class="number">1</span>,<span class="keyword">max</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;str.<span class="keyword">size</span>()-<span class="number">1</span>;i++)
    {
        <span class="keyword">max</span>=<span class="number">1</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(str.<span class="keyword">size</span>()-<span class="number">1</span>)/<span class="number">2</span>;j++)<span class="comment">//two</span>
        {
            <span class="keyword">if</span>(i-j&gt;=<span class="number">0</span> &amp;&amp; i+j &lt;=str.<span class="keyword">size</span>()-<span class="number">1</span>)
            {
                <span class="keyword">if</span>(str[i-j] == str[i+j])
                    <span class="keyword">max</span>+=<span class="number">2</span>;
                <span class="keyword">else</span>
                    <span class="keyword">break</span>;
            }
            <span class="keyword">else</span>
                <span class="keyword">break</span>;
        }
        <span class="keyword">if</span>(<span class="keyword">max</span>&gt;maxlen)
            maxlen=<span class="keyword">max</span>;
        <span class="keyword">max</span>=<span class="number">1</span>;
        <span class="keyword">if</span>(str[i]==str[i+<span class="number">1</span>])
        {
            <span class="keyword">max</span>++;
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(str.<span class="keyword">size</span>()-<span class="number">2</span>)/<span class="number">2</span>;j++)
            {
                <span class="keyword">if</span>(i-j&gt;=<span class="number">0</span> &amp;&amp; i+<span class="number">1</span>+j&lt;=str.<span class="keyword">size</span>()-<span class="number">1</span> )
                {
                    <span class="keyword">if</span>(str[i-j]==str[i+<span class="number">1</span>+j])
                        <span class="keyword">max</span>+=<span class="number">2</span>;
                    <span class="keyword">else</span>
                        <span class="keyword">break</span>;
                }
                <span class="keyword">else</span>
                    <span class="keyword">break</span>;
            }
            <span class="keyword">if</span>(<span class="keyword">max</span>&gt;maxlen)
                maxlen=<span class="keyword">max</span>;
        }


    }
    <span class="keyword">return</span> maxlen;
}
</code></pre><p>看看这个代码里面，还嵌套了break，for条件判断之后，里面又判断了越界问题，其实是有重复的，for里面的条件其实没有必要，完全可以用if里面的替换掉，因为只要头尾都每越界，就可以一直两边extend，于是如果越界了，还break，如果写到for<br>条件里，刚好不用break了，里面如果长度相等就extend，没有的话break，这个是比较合理的，也需要的。而且这个max没必要每次加2，因为完全可以根据j计算出来。</p>
<p>因此代码修改后变成如下的：</p>
<pre><code><span class="keyword">int</span> maxdrome_centre(<span class="keyword">string</span> str)
{
    <span class="keyword">if</span>(str.<span class="keyword">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> maxlen=<span class="number">1</span>;<span class="comment">//total max, at least 1</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=str.<span class="keyword">size</span>()-<span class="number">1</span>;i++)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i-j&gt;=<span class="number">0</span> &amp;&amp; i+j &lt;=str.<span class="keyword">size</span>()-<span class="number">1</span>;j++)<span class="comment">//odd</span>
        {
            <span class="keyword">if</span>(str[i-j] != str[i+j])
                <span class="keyword">break</span>;
        }
        <span class="keyword">max</span>=<span class="number">2</span><span class="variable">*j</span>+<span class="number">1</span>;
        <span class="keyword">if</span>(<span class="keyword">max</span>&gt;maxlen)
            maxlen=<span class="keyword">max</span>;

        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;(i-j&gt;=<span class="number">0</span>) &amp;&amp; (i+j+<span class="number">1</span>) &lt;=str.<span class="keyword">size</span>()-<span class="number">1</span>;j++)<span class="comment">//odd</span>
        {
            <span class="keyword">if</span>(str[i-j] != str[i+j+<span class="number">1</span>])
                <span class="keyword">break</span>;
        }
        <span class="keyword">max</span>=<span class="number">2</span><span class="variable">*j</span>++<span class="number">2</span>;
        <span class="keyword">if</span>(<span class="keyword">max</span>&gt;maxlen)
            maxlen=<span class="keyword">max</span>;
    }
    <span class="keyword">return</span> maxlen;
}
</code></pre><p>这个逻辑几乎和邹博一样了，所以总结一下自己coding的一些不好的思维和设计逻辑的习惯<br>1.不要去根据不等式去计算i或者j的范围，这是计算机做的事情，例如i-j&gt;=0 i+j&lt;=str.size()-1 这个我有时候可能回想着推出i j范围，然后写在条件语句，这个其实直接写会比较好，计算机会处理好的<br>2.写逻辑语句要想清楚是否两个条件有重叠有包含关系，只要选那个更严格的条件就可以了，否则逻辑更复杂，例如我for里面先去限制j最大只能extend (n-1)/2长度，再在里面加if限制两边越界，其实越界包含了前者，<br>只需要这个条件，因此直接放到for条件里，这样少了break，还有计算长度直接有j决定，所以不需要里面每次max+2，当然这个问题会轻一点，但是没想到不应该。<br>3.另外后面偶数长度还先加if判断是否第一个成立，完全可以放到循环里面，不然逻辑复杂，易出bug，还有一个内部的max没必要，因为每次都是计算当期的与总的比较，不是两次max比较，也没想清楚。</p>
<p>总之代码写的还是naive，还是要多读别人的代码，例如fawkes，adhoc，邹博等，现在要求代码要写的快，逻辑简单清晰，精炼，越垄长的容易bug</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 22 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/22/Dijstra-proof/">Dijstra proof</a></h1>
  

      <time datetime="2014-07-22T06:44:23.000Z"><a href="/2014/07/22/Dijstra-proof/">7月 22 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>看到09CS 考研DS第一道大题，是对Dijstra的变形，问是否正确，于是回顾这一经典的greedy算法。</p>
<p>算法思想和代码之前已经联系过了，但是这道题目涉及到了正确性证明，如果变形了是否保证正确性，尽管答案只是举了一个反例来说明，但是我还是打算回顾下<br>当时的proof。其实一直都不算真正意义的理解了。</p>
<p>利用数学归纳的思想：</p>
<p>集合分为close-set表示，已经算出最短路径的点击，open-set为剩余的点击。</p>
<p>1(初始条件). 一开始肯定是source点u了，因为dist为0，不可能有比他更短的了。假设第二个点p，现在证明p一定是u-&gt;p为p的最短路径。<br>假设不是，假设存在open-set点x，使得u-&gt;x x-&gt;p为最短路径，那么u-&gt;x一定比u-&gt;p短(边&gt;0的性质)，x应该比p先加入close-set，与一直矛盾</p>
<p>2(递推证明).加入当前close-set有些点，那么现在加入p，那么u-&gt;p的最短路径的点一定都在close-set里。<br>假设不是，假设路径出现了一个点x在opens-set(假设只是路径最后一个点在open-set,其他情况是转化为这个的吧),那么u-&gt;x x-&gt;p比u-&gt;p(中间全是close-set中点)要短，那么u-&gt;x比u-&gt;p短，x应该比p先加入close-set，<br>产生矛盾。</p>
<p>思路来源这里<br><a href="http://blog.csdn.net/dog250/article/details/5303310" target="_blank" rel="external">http://blog.csdn.net/dog250/article/details/5303310</a> </p>
<p>另外还附上一个童鞋另一种思维方式的理解正确性 <a href="http://my.oschina.net/mustang/blog/56216" target="_blank" rel="external">http://my.oschina.net/mustang/blog/56216</a></p>
<p>当年算法书的证明感觉不make sense，所以弃掉了。</p>
<p>另外今天看到了一个priority_queue 也是在<queue>里面的，都是单向队列，只是加了优先级排序。</queue></p>
<p><dequeu> 则是双向队列，两边都可以插和删，</dequeu></p>
<p>STL与堆相关的主要是 make_heap push_heap, pop_heap 这样一些algorithm里的函数，用vector容器来装，可以实现heap</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 22 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/22/CockTailSort/">CockTailSort</a></h1>
  

      <time datetime="2014-07-21T16:11:47.000Z"><a href="/2014/07/22/CockTailSort/">7月 22 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>今天看到鸡尾酒排序，看名字就像了解下，之前好像有稍微听过，但是具体不知道是啥。</p>
<p>是冒泡排序的改进版，原来每次冒最大(小)到最后面，现在两端来回冒，这样有啥好处呢？<br>例如 23451这样的 只要一来一回就排好了，但是bubblesort却要很多次。</p>
<p>所以写算法，感觉是n/2个来回，n为偶正好冒完所有，n为奇，除掉中间的元素，最后肯定也是定好位置的，因为其他n-1个元素都订好位置了。<br>另外和bubblesort一样，加swap flag，如果一来或者一回没有交换，那么就排好序了，调用C++11的swap函数。</p>
<p>后来看了下wikipedia的，感觉实现不太一样，他是直接用swap就来判断外部循环，思路也是一致，每个来回长度都要缩减2，</p>
<pre><code><span class="keyword">void</span> CockTailSort(<span class="keyword">int</span>*a, <span class="keyword">int</span> n)
{
    <span class="keyword">bool</span> isswap;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)
    {
        isswap=<span class="keyword">false</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&lt;=n-i-<span class="number">1</span>;j++)
        {
            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])
                swap(a[j],a[j+<span class="number">1</span>]),isswap=<span class="keyword">true</span>;

        }
        <span class="keyword">if</span>(isswap==<span class="keyword">false</span>) <span class="keyword">break</span>;
        isswap=<span class="keyword">false</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> j=n-i-<span class="number">1</span>;j&gt;=i;j--)
        {
            <span class="keyword">if</span>(a[j-<span class="number">1</span>]&gt;a[j])
                swap(a[j],a[j-<span class="number">1</span>]),isswap=<span class="keyword">true</span>;
        }
        <span class="keyword">if</span>(isswap==<span class="keyword">false</span>) <span class="keyword">break</span>;
    }
}
</code></pre>
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 22 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/21/trim-variant-c-cpp-string/">trim variant c cpp string</a></h1>
  

      <time datetime="2014-07-21T12:33:56.000Z"><a href="/2014/07/21/trim-variant-c-cpp-string/">7月 21 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>实现trim的variant，将多个空格变为1个。但是逻辑似乎对我来说短时间不简单啊。</p>
<p>我开始尝试的是C++字符串，一个istringstream搞定，但是其实也会有问题，后来发现要试试C的，不然有点像调用了一个库或者class的感觉。</p>
<pre><code><span class="keyword">char</span> * trim(<span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">int</span> i=<span class="number">0</span>;
    <span class="keyword">int</span> len=strlen(<span class="keyword">str</span>),startpos;
    <span class="keyword">char</span>* a=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];

    <span class="keyword">int</span> offset=<span class="number">0</span>;
    <span class="keyword">while</span>(i&lt;len)
    {
        startpos=i;
        <span class="keyword">while</span>(i&lt;len&amp;&amp;<span class="keyword">str</span>[i]!=<span class="string">' '</span>)
            i++;
        <span class="keyword">if</span>(i==len) <span class="keyword">break</span>;
        <span class="keyword">for</span>(j=startpos;j&lt;i;j++)
        {
            a[offset]=<span class="keyword">str</span>[j];
            offset++;
        }
        a[offset]=<span class="string">' '</span>;
        offset++;

        <span class="keyword">while</span>(i&lt;len&amp;&amp;<span class="keyword">str</span>[i]==<span class="string">' '</span>)
            i++;
    }
    a[offset]=<span class="string">'\0'</span>;
    strcpy(<span class="keyword">str</span>,a);
    delete[] a;
    <span class="keyword">return</span> <span class="keyword">str</span>;
}
</code></pre><p>上面代码有点问题的，break早了，最后一个非空格的串还没copy过去，另外改成strncpy，提高可读性</p>
<pre><code><span class="keyword">char</span> * trim_new(<span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">int</span> i=<span class="number">0</span>,j;
    <span class="keyword">int</span> len=strlen(<span class="keyword">str</span>),startpos;
    <span class="keyword">char</span>* a=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];

    <span class="keyword">int</span> offset=<span class="number">0</span>;
    <span class="keyword">while</span>(i&lt;len)
    {
        startpos=i;
        <span class="keyword">while</span>(i&lt;len&amp;&amp;<span class="keyword">str</span>[i]!=<span class="string">' '</span>)
            i++;
        strncpy(a+offset,<span class="keyword">str</span>+startpos,i-startpos);
        <span class="comment">/*
        for(j=startpos;j&lt;i;j++)
        {
            a[offset]=str[j];
            offset++;
        }
        */</span>
        offset+=i-startpos;
        <span class="keyword">if</span>(i==len) <span class="keyword">break</span>;
        a[offset]=<span class="string">' '</span>;
        offset++;

        <span class="keyword">while</span>(i&lt;len&amp;&amp;<span class="keyword">str</span>[i]==<span class="string">' '</span>)
            i++;
    }
    a[offset]=<span class="string">'\0'</span>;
    strcpy(<span class="keyword">str</span>,a);
    delete[] a;
    <span class="keyword">return</span> <span class="keyword">str</span>;
}    
</code></pre><p>我已开始犯了一个严重，但是我一直因为没弄清楚字符数组，字符串的区别导致的，上一篇总结好了。我用char a[]=”” 最后return a, 发现其实返回之后这块地址因为是栈的被销毁了，所以挂了。。。。<br>于是改成堆，但是又要释放空间这样比较好，然后只能拷贝回str，而且逻辑似乎不好，好不如直接在源串上改。</p>
<p>于是有了下面两个指针的代码，i指向当前处理好的字符串后一个位置，j指向后面待处理的字符串，记得开始记录startpos，所以是[startpos,j) copy回 i开始的位置，里面有个地方容易忽视，就是如果最后面是非空格的一串，后面要避免被赋上空格，或者直接break返回<br>也可以的，不break也可以因为后面condition控制好了越界的情况。</p>
<pre><code><span class="keyword">char</span> *trim(<span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">int</span> len=strlen(<span class="keyword">str</span>);

    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,startpos;
    <span class="keyword">while</span>(j&lt;len)
    {
        startpos=j;
        <span class="keyword">while</span>(j&lt;len &amp;&amp; <span class="keyword">str</span>[j]!=<span class="string">' '</span>)
            j++;
        strncpy(<span class="keyword">str</span>+i,<span class="keyword">str</span>+startpos, j-startpos);

        i+=j-startpos;

        <span class="keyword">if</span>(j&lt;len)<span class="comment">//no more space add</span>
        {
            <span class="keyword">str</span>[i]=<span class="string">' '</span>;
            i++;
        }


        <span class="keyword">while</span>(j&lt;len &amp;&amp; <span class="keyword">str</span>[j]==<span class="string">' '</span>)
            j++;
    }
    <span class="keyword">str</span>[i]=<span class="string">'\0'</span>;

    <span class="keyword">return</span> <span class="keyword">str</span>;
}
</code></pre><p>另外还有一个简单的C++ istringstream版的，但是好像有问题，例如开头一串空格的一个空格就丢了，因为里面封装了太多了，改起来不易。。。</p>
<pre><code><span class="keyword">char</span> *trim(<span class="keyword">char</span> *<span class="keyword">str</span>)
{
    string strcpp=<span class="keyword">str</span>;
    istringstream istr(<span class="keyword">str</span>);
    istr&gt;&gt;outstr;
    <span class="keyword">while</span>(istr&gt;&gt;split)
        outstr+=<span class="string">" "</span>+split;


    strcpy(<span class="keyword">str</span>,outstr.c_str());

    <span class="keyword">return</span> <span class="keyword">str</span>;
}
</code></pre><p>今天再次写这个程设题，总结了一些经验，如果先找非空格，后找空格似乎控制麻烦，就换成先找空格后找费空格，代码很好控制，而且如果能一个一个copy就尽量这种，不要通过计算坐标<br>使得代码还麻烦，尽量不要把break出去的处理，在里面各个分支处理好就可以了。</p>
<pre><code>更简洁的就地双指针遍历版本如下：

<span class="keyword">char</span>* trimspace(<span class="keyword">char</span>* cstr)
{
    <span class="keyword">int</span> cstrlen=<span class="built_in">strlen</span>(cstr);
    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,start;
    <span class="keyword">while</span>(i&lt;cstrlen)
    {
        <span class="comment">//start=i;</span>
        <span class="keyword">bool</span> hasspace=<span class="keyword">false</span>;
        <span class="keyword">while</span>(i&lt;cstrlen &amp;&amp; cstr[i]==<span class="string">' '</span>)
            i++, hasspace=<span class="keyword">true</span>;

        <span class="keyword">if</span>(hasspace==<span class="keyword">true</span>)
            cstr[j]=<span class="string">' '</span>,j++;
        <span class="keyword">if</span>(i==cstrlen)
        {
            cstr[j]=<span class="string">'\0'</span>;
            <span class="keyword">break</span>;
        }
        <span class="keyword">while</span>(i&lt;cstrlen&amp;&amp; cstr[i]!=<span class="string">' '</span>)
            cstr[j++]=cstr[i++];
        <span class="keyword">if</span>(i==cstrlen)
            cstr[j]=<span class="string">'\0'</span>;
    }
    <span class="keyword">return</span> cstr;
}
</code></pre>
	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 21 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/21/c-cpp-convert,-char-char-a[]/">c cpp convert, char char a</a></h1>
  

      <time datetime="2014-07-21T11:57:22.000Z"><a href="/2014/07/21/c-cpp-convert,-char-char-a[]/">7月 21 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>对于这一块，fawks大神毫无疑问已经到了一个境界了，我还是个学习的菜鸟。</p>
<p>我当时学的时候，就觉得里面的语法太复杂了，而且各种陷阱，一不小心就掉到坑里去了。。。</p>
<p>先来两个case：</p>
<pre><code><span class="keyword">char</span>* <span class="operator">a</span>=<span class="string">"fawks"</span>
<span class="keyword">char</span> <span class="operator">a</span>[]=<span class="string">"fawks"</span>
</code></pre><p>下面本文从几个方面来比较区别</p>
<ol>
<li><p>两个的是前者a是字符串指针，后者a是字符数组。具体的来说，两者都会在常量区(常量区，堆，栈(通常说的堆栈), 全局\静态存储区)申请一个空间存放fawks这个字符串，<br>然后前者在栈申请一个空间存放字符串指针a，*86 占4B，值为这块常量区的首地址，但是如果cout&lt;&lt;a的时候又会输出这个字符串，而不会输出a的地址，之前李青老师的书记得写过，这是<br>C++的智能处理，包括输出字符数组首地址也是自动输出字符串内容。后者则是将常量区字符串copy到一个栈，然后首地址就是a的地址，这个是字符数组。并且要注意前者最好是写成</p>
<p> const char*a =”fawks”</p>
</li>
</ol>
<p>因为不能通过a来修改字符串所在常量区的值，所以const会比较安全，但是后面修改a的指向又是可以的。</p>
<ol>
<li><p>后面继续赋值：</p>
<p> a=”zrc”</p>
</li>
</ol>
<p>这句话对于前者是可以的，因为把栈中指针a的值改为zrc的地址，a指向了常量区另一个区域zrc的首地址，而后者是不可以的，因为a已经固定下来了指向一个栈中fawks的首地址，字符数组只能初始化不能赋值。</p>
<ol>
<li>另外还有一个区别要注意<br> sizeof(a);</li>
</ol>
<p>这句话对于前者输出4(*86),因为这个指针占得空间是4个字节，因为32bit地址，8bit占一个Byte，如果字节寻址的话(一般这么理解)，所以占4个存储单元。而后者则是输出5，注意与strlen(a)的区别，<br>因为sizeof()是看占得内存空间大小，所以包含结束符\0(ASCII 0)， strlen是字符串长度，不包含结束符。</p>
<p>4.所以如果函数返回一个char<em>, 如果你定义的char a[]=””, 然后return a就会挂，虽然过程是先返回了a指向的地址，然后再结束函数，但是这块是栈空间，函数结束就销毁了这块栈，所以位置是野值。。。<br>而后者是字符串存在常量去，随着程序开始就在那直到程序结束，所以char</em>a =””, return a完全没问题，而且函数先返回，后销毁栈变量也保证了他的正确性，a是栈中的一个指针变量。</p>
<ol>
<li>数组(char a[])可以转化为指针(char* a)，指向字符串的指针，但是指针未必可以转为数组，因为如果指向字符串常量的话，那么就不能作为数组了，因为没法修改它们的值。</li>
</ol>
<p>另外要注意字符串常量如果赋值(不是初始化)给char* 可能有警告，例如</p>
<pre><code><span class="keyword">char</span> *s;
s=<span class="string">"hello"</span>;
</code></pre><p>但是char* s=”hello” 是可以的，其实还是加个const安全些。附上</p>
<pre><code>string <span class="keyword">str</span>=(<span class="keyword">char</span>*)s;
<span class="keyword">char</span> *s=<span class="keyword">str</span>.c_str();
</code></pre><p>上面一句可以，二句不可以的，因为c_str()返回const char<em> ,不可以const char</em> 赋给char*, 但是反过来可以，我付给一个保证不修改内容的指针的嘛</p>
<pre><code><span class="keyword">const</span> <span class="built_in">char</span>* s=(<span class="built_in">char</span>*)<span class="built_in">cstr</span>;
</code></pre><p>引用 <a href="http://www.zhihu.com/question/20779337" target="_blank" rel="external">http://www.zhihu.com/question/20779337</a><br><a href="http://blog.csdn.net/hackbuteer1/article/details/6706562" target="_blank" rel="external">http://blog.csdn.net/hackbuteer1/article/details/6706562</a></p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 21 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/2014/07/21/c-cpp-string-in-out-summary/">c cpp string in out summary</a></h1>
  

      <time datetime="2014-07-21T09:39:28.000Z"><a href="/2014/07/21/c-cpp-string-in-out-summary/">7月 21 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>比较熟悉的大神可以飘过了。。。之前对于C C++ string char* 尤其是输入的一堆东西弄得晕头转向，主要是用getline 输入string来处理，但是<br>如果让写C风格的，可能我就挂了。。。</p>
<p>getline(istream&amp; istr, string str, delim)//一般是用这个来输入字符串的</p>
<p>后来看到一个很像的cin.getline(char* str, delim=’\n’), 如果是读一行，还是建议写\n吧，默认参数这么多指不定那条搞晕了= =  如果是写C++，尽量用前者好像</p>
<p>于是后面有出来了 gets fgets scanf(), 这么一堆输入char<em>的函数，gets网上说是不安全的，因为没有设置输入缓存区，有溢出的风险，尽量<br>用fgets去代替，但是谁知道呢：<br>fgets(char </em>str, int num, FILE<em> stream),当然File</em> 也可以传入stdin来表示从标准输入，有点奇怪，后来查了才知道stdin就是File*类型的。<br>但是我后来漏看了cplusplus文档，有个重要的漏了，就是fgets如果输入的最后有个\n,最后读到str里面的字符串也会加一个\n,这不得不说是个巨大的隐患，还是应该相信fawks大神的，<br>用gets，先不管隐患，至少目前编的代码还不会有溢出的隐患。</p>
<p>cin&gt;&gt;输入的话，默认delim 是 space \t 和\n,这个要记住，因为没有参数的，所以数字由于中间不可能有这些delim，可以安全用，但是字符串不是通过<br>这些delim来区分的，所以完全可能中间有这些字符，用cin就悲剧了，cplusplus官网也说cin是notorious的，</p>
<p>scanf() ACMer C C++混编混C的部分主要是由于C++流输入输出比较慢，采用C的函数直接把输入写到内存地址处来提高效率。<br>scanf(“%d”, &amp;x);记住这个是输入地址，和printf只需要print值不一样</p>
<p>另外要特别留意输入int之后的string，如果敲回车的话，因为fgets gets getline cin.getline 这一系列输入字符串都是默认\n结束的，而如果前面整数是敲回车结束的(多数是这样的)，那么<br>后面输入字符串的就是空串，因为\n还留在输入缓冲区里，那么这些读取直到\n就相当于读了空串了，所以最好之前再读取一次把空串读掉，其实scanf(%c)会有这个问题，scanf(%s) cin不会存在这个问题，但是字符串中间又空格就截断了。</p>
<p>总结下来tips就是，输入C字符串用gets可以不指定长度，感觉似乎方便，如果不写大的项目，隐患也还好，fgets需要指定长度和源stdin，可能麻烦点，也可以用cin.getline,而且这个优点在于还有<br>delim参数，因此如果有其他要求的话可能只能用cin.getline了。</p>
<p>C++字符串必须是getline(cin,str,delim=’\n’),输入字符串特别当心前面有int输入的时候，是否留了一个\n在缓冲区里，之前还有做法是cin.clear来清空。<br>另外stdin和cin是同步的，cin是C++的，但是好像stdin好像是标准输入，默认是键盘，如果需要freopen重定向的时候，一般都用stdin</p>
<p>基本delim默认都是\n, 例如getline(string::getline), cin.getline(istream::getline), cin是空格，\t \n来区分整数或者字符串的，用在字符串可能就挂了。</p>
<p>特别注意cin.getline(char*str, int num, delim=’\n’) 里面的num是指包含结束符的</p>
<p>另外今天看到一个代码还是不清楚为啥</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="keyword">int</span> main()
{
    <span class="keyword">char</span> str[<span class="number">8</span>];
    <span class="built_in">cin</span>.getline(str, <span class="number">5</span>);
    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;endl;
    <span class="built_in">cin</span>.getline(str, <span class="number">5</span>);
    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;endl;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>代码来自 <a href="http://www.cnblogs.com/A-Song/archive/2012/01/29/2331204.html" target="_blank" rel="external">http://www.cnblogs.com/A-Song/archive/2012/01/29/2331204.html</a> 对notorious的cin进行了一番批评似乎</p>
<p>34哥说过了，因为有一个问题，第一次输入就因为截断了，flag置1，然后后面就不读了。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 21 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/7/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/9/" class="alignright next">下一页</a>
  
</nav></div>
    </div>
    <div class="tabbar" onload="divideTabBar()">
	
      <div class="tabbaritem"><a class="next" href="/">Home</a></div>
    
      <div class="tabbaritem"><a class="next" href="/archives/">Archives</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a></div>
    
</div>


  </div>
</body>
</html>