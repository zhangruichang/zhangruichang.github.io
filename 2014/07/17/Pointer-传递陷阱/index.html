<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Pointer 传递陷阱 | Richard</title>
  <meta name="author" content="Richard">
  
  <meta name="description" content="理查德爱闹">
  
  
  <meta property="og:title" content="Pointer 传递陷阱"/>
  <meta property="og:site_name" content="Richard"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta property="og:image" content="undefined"/>
  
   <link rel="apple-touch-icon" href="/icon.png" />
   <link rel="shortcut icon" href="/favicon.png" >
   <link rel="alternate" href="http://xxx.xx/atom.xml" title="Richard" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
</head>


<body>
  <div id="content" class="inner">
    <aside id="sidebar" class="alignleft">
      <div class="navigationBar">
        <a href="/">Richard</a>
      </div>
    	
  <nav class="widget" id="menu">
	<ul>
    
      <li class="cell"><a class="next" href="/">Home</a><li>
    
      <li class="cell"><a class="next" href="/archives/">Archives</a><li>
    
      <li class="cell"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a><li>
    
      <li class="cell"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a><li>
    
      <li class="cell"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a><li>
    
    </ul>
</nav>

  <div class="widget weibo">
  <iframe width="100%" height="750" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=750&fansRow=2&ptype=1&speed=0&skin=6&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2689136623&verifier=c139aa37&dpc=1"></iframe>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Binary-Tree/">Binary Tree</a><small>1</small></li>
  
    <li><a href="/categories/DFS/">DFS</a><small>1</small></li>
  
    <li><a href="/categories/DP/">DP</a><small>1</small></li>
  
    <li><a href="/categories/Linklist/">Linklist</a><small>1</small></li>
  
    <li><a href="/categories/Recursive/">Recursive</a><small>1</small></li>
  
    <li><a href="/categories/algorithm/">algorithm</a><small>9</small></li>
  
    <li><a href="/categories/binary-search/">binary search</a><small>2</small></li>
  
    <li><a href="/categories/binary-tree/">binary tree</a><small>3</small></li>
  
    <li><a href="/categories/bit/">bit</a><small>1</small></li>
  
    <li><a href="/categories/bit-operation/">bit operation</a><small>2</small></li>
  
    <li><a href="/categories/blog/">blog</a><small>1</small></li>
  
    <li><a href="/categories/cpp/">cpp</a><small>10</small></li>
  
    <li><a href="/categories/cpp-string/">cpp string</a><small>1</small></li>
  
    <li><a href="/categories/data-structure/">data structure</a><small>4</small></li>
  
    <li><a href="/categories/dfs/">dfs</a><small>1</small></li>
  
    <li><a href="/categories/dp/">dp</a><small>2</small></li>
  
    <li><a href="/categories/ds/">ds</a><small>1</small></li>
  
    <li><a href="/categories/hash/">hash</a><small>1</small></li>
  
    <li><a href="/categories/hexo-configuration/">hexo configuration</a><small>1</small></li>
  
    <li><a href="/categories/hihocode/">hihocode</a><small>1</small></li>
  
    <li><a href="/categories/kmp/">kmp</a><small>1</small></li>
  
    <li><a href="/categories/linklist/">linklist</a><small>4</small></li>
  
    <li><a href="/categories/permutation/">permutation</a><small>2</small></li>
  
    <li><a href="/categories/quick-and-right-coding/">quick and right coding</a><small>1</small></li>
  
    <li><a href="/categories/web/">web</a><small>2</small></li>
  
    <li><a href="/categories/数字规律/">数字规律</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/BST/" style="font-size: 10.00px;">BST</a><a href="/tags/BT/" style="font-size: 10.00px;">BT</a><a href="/tags/Backtrack/" style="font-size: 10.00px;">Backtrack</a><a href="/tags/Combinations/" style="font-size: 10.00px;">Combinations</a><a href="/tags/DP/" style="font-size: 10.00px;">DP</a><a href="/tags/Order/" style="font-size: 10.00px;">Order</a><a href="/tags/Permutation/" style="font-size: 10.00px;">Permutation</a><a href="/tags/algorithm/" style="font-size: 20.00px;">algorithm</a><a href="/tags/array/" style="font-size: 15.00px;">array</a><a href="/tags/back-n-node/" style="font-size: 10.00px;">back n node</a><a href="/tags/backtrack/" style="font-size: 10.00px;">backtrack</a><a href="/tags/binary-search/" style="font-size: 15.00px;">binary search</a><a href="/tags/binary-search-tree/" style="font-size: 10.00px;">binary search tree</a><a href="/tags/bit/" style="font-size: 15.00px;">bit</a><a href="/tags/brute-force/" style="font-size: 12.50px;">brute force</a><a href="/tags/c/" style="font-size: 10.00px;">c</a><a href="/tags/char/" style="font-size: 10.00px;">char*</a><a href="/tags/cin/" style="font-size: 10.00px;">cin</a><a href="/tags/coding/" style="font-size: 10.00px;">coding</a><a href="/tags/complement/" style="font-size: 10.00px;">complement</a><a href="/tags/complex/" style="font-size: 12.50px;">complex</a><a href="/tags/complex-condition-analysis/" style="font-size: 10.00px;">complex condition analysis</a><a href="/tags/configuire/" style="font-size: 10.00px;">configuire</a><a href="/tags/convert/" style="font-size: 10.00px;">convert</a><a href="/tags/cpp/" style="font-size: 17.50px;">cpp</a><a href="/tags/cpp，inheritance/" style="font-size: 10.00px;">cpp，inheritance</a><a href="/tags/cycle/" style="font-size: 10.00px;">cycle</a><a href="/tags/data-structure/" style="font-size: 17.50px;">data structure</a><a href="/tags/data-type/" style="font-size: 12.50px;">data type</a><a href="/tags/digit/" style="font-size: 10.00px;">digit</a><a href="/tags/divide/" style="font-size: 10.00px;">divide</a><a href="/tags/divide-2/" style="font-size: 10.00px;">divide 2</a><a href="/tags/domain/" style="font-size: 10.00px;">domain</a><a href="/tags/double-linklist/" style="font-size: 10.00px;">double linklist</a><a href="/tags/dp/" style="font-size: 15.00px;">dp</a><a href="/tags/find/" style="font-size: 10.00px;">find</a><a href="/tags/finding-rule/" style="font-size: 10.00px;">finding rule</a><a href="/tags/getline/" style="font-size: 10.00px;">getline</a><a href="/tags/git/" style="font-size: 10.00px;">git</a><a href="/tags/github/" style="font-size: 10.00px;">github</a>
  </div>
</div>


    	<footer id="footer" class="inner"><div class="copyright">
  
  &copy; 2014 Richard
  
</div>



</footer>
    </aside>
    
    
    <div id="hidden-navigationBar" class="navigationBar">
      <a href="/">Richard</a>
    </div>
    <div id="main-col" class="alignright">
    <div id="wrapper">
      
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title">Pointer 传递陷阱</h1>
  

      <time datetime="2014-07-17T15:50:28.000Z"><a href="/2014/07/17/Pointer-传递陷阱/">7月 17 2014</a></time>
      
  </header>
    <div class="entry">
      
        <p>今天试了一道leetcode简单题，发现出现了一个很奇怪的错误，leetcode是按照层序的顺序来构建二叉树的，如果当前层都没有元素了，就不print，也就结束了，如果父亲没有 jing号(markdown语法都不知道怎么print jing号，他是强调的含义o(╯□╰)o)<br>也不print，总是有点怪怪的，可能和CreatBT这个函数有关，举个例子<br>   1<br>  / \<br> 2   3<br>    /<br>   4<br>    \<br>     5</p>
<p>构建BT的序列是 “{1,2,3,#,#,4,#,#,5}”， 如果二叉树显示的不好。详见<a href="https://oj.leetcode.com/problems/symmetric-tree/" target="_blank" rel="external">https://oj.leetcode.com/problems/symmetric-tree/</a></p>
<p>思路就是层序遍历，因为要区分层，所以采用了编程之美的经典算法(我没有看清题目说明，题目说了初始的next都是NULL，其实不需要区分层的，普通队列层序遍历就可以了，没有赋next的刚好都是应该赋NULL = = 就当又温习了一遍这个算法)，<br>vector模拟一个队列，利用current和last区分层，具体详见编程之美。题目说的constant空间 感觉好瞎啊，这个必须遍历BT，要么递归，要么用栈(先中后序)，要么队列(层序)，logn的空间我感觉都少不了的。。。。队列极端装了一层的点，<br>最大是最多结点的一层，2^(h-1)=n/2, h=下限(logn)+1 或者 上限(log(n+1)), 栈则是h，O(logn),递归也是栈一样，O(logn)</p>
<pre><code><span class="keyword">void</span> connect(TreeLinkNode *root)
{
    <span class="keyword">if</span>(root==NULL) <span class="keyword">return</span>;
    <span class="stl_container"><span class="built_in">vector</span>&lt;TreeLinkNode* &gt;</span> vec;
    vec.push_back(root);
    <span class="keyword">int</span> current=<span class="number">0</span>;
    TreeLinkNode* lastp;
    <span class="keyword">while</span>(current&lt;vec.size())
    {
        <span class="keyword">int</span> last=vec.size();<span class="comment">//the final one's next one</span>
        <span class="keyword">int</span> i=<span class="number">0</span>;
        <span class="keyword">while</span>(current&lt;last)
        {
            TreeLinkNode* p=vec.at(current);
            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)
                lastp-&gt;next=p;<span class="comment">//level first one, do not have last</span>

            lastp=p;
            <span class="built_in">cout</span>&lt;&lt;p-&gt;val;
            <span class="keyword">if</span>(p-&gt;left)
                vec.push_back(p-&gt;left);
            <span class="keyword">if</span>(p-&gt;right)
                vec.push_back(p-&gt;right);
            current++;
            i++;
        }
        lastp-&gt;next=NULL;<span class="comment">//level last next is null</span>
        <span class="built_in">cout</span>&lt;&lt;endl;
    }
}
</code></pre><p>后来发现第一个case死活过不了，而且感觉很奇怪，<br>Input:    {0}<br>Output:    0<br>Expected:    {0,#}<br>{0，#}是啥样的二叉树啊，如果是0 输出就是0啊，如果是有个左(右)孩子1，就是{0,1,#}({0,#,1})。。。不知道这个啥意思。。。导致现在都没过。。。<br>悲剧了，昨天收到邮件，一个回复说你的cout要删掉= = o(╯□╰)o 我才知道这个低级的错误，往往我们会忽视最简单的错误，而且写的这个可以处理各种二叉树，于是后面一道也过了。。。。</p>
<p>另外看到一个递归算法，中科大的一个童鞋写的，他也利用了初始值为NULL这个性质，将BT分为left right 两个BT，然后递归，两个子BT处理完了，还有一部分next没处理，也即两个BT 每一层，left最后一个指向right第一个，用一个用个<br>while一直探下去直到没有了为止</p>
<pre><code><span class="literal">void</span> connect(TreeLinkNode <span class="subst">*</span>root) {  
        <span class="keyword">if</span>( root <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">||</span> root<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">||</span> root<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span> )        <span class="comment">//{0}  有一个为空就不处理，其实不会出现left right一个空一个不空的，因为题目说了完全BT，而且即使有了，算法也会出问题。。。。</span>
        {  
           <span class="keyword">return</span>;  
        }  

        TreeLinkNode <span class="subst">*</span>p, <span class="subst">*</span>q;  
        p <span class="subst">=</span> root<span class="subst">-&gt;</span>left;  
        q <span class="subst">=</span> root<span class="subst">-&gt;</span>right;  
        p<span class="subst">-&gt;</span>next <span class="subst">=</span> q;  
        <span class="keyword">while</span>( p<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> q<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> )<span class="comment">//处理两个子BT之间的那些指针  </span>
        {  
            p <span class="subst">=</span> p<span class="subst">-&gt;</span>right;  
            q <span class="subst">=</span> q<span class="subst">-&gt;</span>left;  
            p<span class="subst">-&gt;</span>next <span class="subst">=</span> q;  
        }  

        connect( root<span class="subst">-&gt;</span>left );  
        connect( root<span class="subst">-&gt;</span>right );  
    }
</code></pre><p>看起来是elegant, 但是不能处理非完全二叉树，很有局限性，例如1左-&gt;2右-&gt;3， 2只有左子树4，无右子树，那么这个4是需要指向右孩子3子树的下一层第一个结点，这个指针指不到这个地方，这大概也是为啥这个题目分了两类吧。。。。<br><a href="https://wangxj.blog.ustc.edu.cn/?p=31" target="_blank" rel="external">https://wangxj.blog.ustc.edu.cn/?p=31</a></p>
<p>于是乎打算自己构建一颗二叉树来测，回想起当年CM老师教的(先序遍历)递归构建二叉树的算法(中序和后序递归建立BT可能会有问题，不太确定)，当时记得融神还不太熟悉这个算法，自己一个一个的手动insert左孩子或者右孩子。。。<br>于是乎我写一遍，一遍没好，调递归算法是最蛋疼的，你无法想象蛋会有多疼，一层一层的局部变量进去，我是先序或者某个序输出来看的，递归一定要记得有出口。后来终于发现了一个忽视的问题，指针传递其实也是值传递，也即传递这个指针变量的<br>值(地址值，指向一个变量存储的地址)，然后里面都是new出来的结点，于是穿进去之后，会是OS分配的一个新的某个地址，于是传入的参数就指不到这个地址了，于是树挂了。。。。我发现CM老师的课件也有这个问题好像当时还没人纠正。。。<br>这里应当也必须改为指针的引用传递，这样才可以保证传入的是指针变量，让这个指针变量申请一个新的堆空间，地址存在这个指针变量里。</p>
<p>修改后的先序遍历构建二叉树代码(-1 表示此处空)</p>
<pre><code><span class="title">void</span> <span class="type">Create</span>(<span class="type">TreeLinkNode</span>* &amp; root)
{
    int <span class="typedef"><span class="keyword">data</span>;</span>
    cin&gt;&gt;<span class="typedef"><span class="keyword">data</span>;</span>
    <span class="keyword">if</span>(<span class="typedef"><span class="keyword">data</span> == -1) root=<span class="type">NULL</span>;</span>
    <span class="keyword">else</span>
    {
        root=new <span class="type">TreeLinkNode</span>(<span class="typedef"><span class="keyword">data</span>);</span>
        <span class="type">Create</span>(root-&gt;left);
        <span class="type">Create</span>(root-&gt;right);
    }
}
</code></pre><p>这个递归其实也是有递归出口的，看起来大家都习惯了一上来必须是递归出口。如果输入-1，就不递归了，递归出口的定义就是这个分支不会继续递归下去，而是在有限步后就停止了，这也是某歌07年的笔试题里一个选择提到过的。<br>另外自己Copy代码的时候，经常会出问题，虽然fawks大神当时也建议我copy一些，提高效率，但是我总会忘记把改改的改完，例如先序Copy到中序，只有定义的函数名改了，里面递归调用没改，于是出现了一种全新的遍历顺序 #_#</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://www.weibo.com/u/2689136623"><strong>richard爱闹</strong></a> - 7月 17 2014</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhangruichang.com"><strong>Richard</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
	 
     		  
  
  <div class="categories">
    <a href="/categories/Recursive/">Recursive</a>
  </div>

       		
  
  <div class="tags">
    <a href="/tags/BT/">BT</a>, <a href="/tags/recursive/">recursive</a>, <a href="/tags/Order/">Order</a>
  </div>

     		  
       	 
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


</div>
    </div>
    <div class="tabbar" onload="divideTabBar()">
	
      <div class="tabbaritem"><a class="next" href="/">Home</a></div>
    
      <div class="tabbaritem"><a class="next" href="/archives/">Archives</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://admis.fudan.edu.cn/~rczhang">About Me</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://blog.csdn.net/richardzrc">Csdn Blog</a></div>
    
      <div class="tabbaritem"><a class="next" href="http://richard_zhang.drivehq.com/">Previous Page</a></div>
    
</div>


  </div>
</body>
</html>